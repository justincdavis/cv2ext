"""
This type stub file was generated by pyright.
"""

import contextlib
import os
import unittest
from contextlib import contextmanager
from functools import cached_property
from numba.core.compiler import CompilerBase

"""
Assorted utilities for use in tests.
"""
enable_pyobj_flags = ...
force_pyobj_flags = ...
no_pyobj_flags = ...
nrt_flags = ...
tag = ...
always_test = ...
_32bit = ...
is_parfors_unsupported = _32bit
skip_parfors_unsupported = ...
skip_unless_py10_or_later = ...
skip_unless_py10 = ...
skip_if_32bit = ...
def expected_failure_py311(fn):
    ...

def expected_failure_py312(fn):
    ...

_msg = ...
skip_unless_scipy = ...
skip_unless_cffi = ...
_lnx_reason = ...
linux_only = ...
_win_reason = ...
windows_only = ...
_is_armv7l = ...
disabled_test = ...
skip_ppc64le_issue4563 = ...
has_typeguard = ...
skip_unless_typeguard = ...
skip_if_typeguard = ...
skip_ppc64le_issue6465 = ...
_uname = ...
IS_OSX_ARM64 = ...
skip_m1_fenv_errors = ...
has_lapack = ...
needs_lapack = ...
has_blas = ...
needs_blas = ...
_exec_cond = ...
needs_subprocess = ...
has_setuptools = ...
needs_setuptools = ...
def ignore_internal_warnings(): # -> None:
    """Use in testing within a ` warnings.catch_warnings` block to filter out
    warnings that are unrelated/internally generated by Numba.
    """
    ...

class TestCase(unittest.TestCase):
    longMessage = ...
    @cached_property
    def random(self): # -> RandomState:
        ...
    
    def reset_module_warnings(self, module): # -> None:
        """
        Reset the warnings registry of a module.  This can be necessary
        as the warnings module is buggy in that regard.
        See http://bugs.python.org/issue4180
        """
        ...
    
    @contextlib.contextmanager
    def assertTypingError(self): # -> Generator[_AssertRaisesContext[LoweringError | TypingError | TypeError | NotImplementedError], Any, None]:
        """
        A context manager that asserts the enclosed code block fails
        compiling in nopython mode.
        """
        ...
    
    @contextlib.contextmanager
    def assertRefCount(self, *objects): # -> Generator[None, Any, None]:
        """
        A context manager that asserts the given objects have the
        same reference counts before and after executing the
        enclosed block.
        """
        ...
    
    def assertRefCountEqual(self, *objects): # -> None:
        ...
    
    @contextlib.contextmanager
    def assertNoNRTLeak(self): # -> Generator[None, Any, None]:
        """
        A context manager that asserts no NRT leak was created during
        the execution of the enclosed block.
        """
        ...
    
    _bool_types = ...
    _exact_typesets = ...
    _approx_typesets = ...
    _sequence_typesets = ...
    _float_types = ...
    _complex_types = ...
    def assertStridesEqual(self, first, second): # -> None:
        """
        Test that two arrays have the same shape and strides.
        """
        ...
    
    def assertPreciseEqual(self, first, second, prec=..., ulps=..., msg=..., ignore_sign_on_zero=..., abs_tol=...): # -> None:
        """
        Versatile equality testing function with more built-in checks than
        standard assertEqual().

        For arrays, test that layout, dtype, shape are identical, and
        recursively call assertPreciseEqual() on the contents.

        For other sequences, recursively call assertPreciseEqual() on
        the contents.

        For scalars, test that two scalars or have similar types and are
        equal up to a computed precision.
        If the scalars are instances of exact types or if *prec* is
        'exact', they are compared exactly.
        If the scalars are instances of inexact types (float, complex)
        and *prec* is not 'exact', then the number of significant bits
        is computed according to the value of *prec*: 53 bits if *prec*
        is 'double', 24 bits if *prec* is single.  This number of bits
        can be lowered by raising the *ulps* value.
        ignore_sign_on_zero can be set to True if zeros are to be considered
        equal regardless of their sign bit.
        abs_tol if this is set to a float value its value is used in the
        following. If, however, this is set to the string "eps" then machine
        precision of the type(first) is used in the following instead. This
        kwarg is used to check if the absolute difference in value between first
        and second is less than the value set, if so the numbers being compared
        are considered equal. (This is to handle small numbers typically of
        magnitude less than machine precision).

        Any value of *prec* other than 'exact', 'single' or 'double'
        will raise an error.
        """
        ...
    
    def subprocess_test_runner(self, test_module, test_class=..., test_name=..., envvars=..., timeout=...): # -> None:
        """
        Runs named unit test(s) as specified in the arguments as:
        test_module.test_class.test_name. test_module must always be supplied
        and if no further refinement is made with test_class and test_name then
        all tests in the module will be run. The tests will be run in a
        subprocess with environment variables specified in `envvars`.
        If given, envvars must be a map of form:
            environment variable name (str) -> value (str)
        It is most convenient to use this method in conjunction with
        @needs_subprocess as the decorator will cause the decorated test to be
        skipped unless the `SUBPROC_TEST` environment variable is set to 1
        (this special environment variable is set by this method such that the
        specified test(s) will not be skipped in the subprocess).


        Following execution in the subprocess this method will check the test(s)
        executed without error. The timeout kwarg can be used to allow more time
        for longer running tests, it defaults to 60 seconds.
        """
        ...
    
    def run_test_in_subprocess(maybefunc=..., timeout=..., envvars=...): # -> Callable[..., None] | Callable[..., Callable[..., None]]:
        """Runs the decorated test in a subprocess via invoking numba's test
        runner. kwargs timeout and envvars are passed through to
        subprocess_test_runner."""
        ...
    
    def make_dummy_type(self): # -> tuple[type[Dummy], type[_]]:
        """Use to generate a dummy type unique to this test. Returns a python
        Dummy class and a corresponding Numba type DummyType."""
        class Dummy:
            ...
        
        
    
    def skip_if_no_external_compiler(self): # -> None:
        """
        Call this to ensure the test is skipped if no suitable external compiler
        is found. This is a method on the TestCase opposed to a stand-alone
        decorator so as to make it "lazy" via runtime evaluation opposed to
        running at test-discovery time.
        """
        ...
    


class SerialMixin:
    """Mixin to mark test for serial execution.
    """
    _numba_parallel_test_ = ...


@contextlib.contextmanager
def override_config(name, value): # -> Generator[None, Any, None]:
    """
    Return a context manager that temporarily sets Numba config variable
    *name* to *value*.  *name* must be the name of an existing variable
    in numba.config.
    """
    ...

@contextlib.contextmanager
def override_env_config(name, value): # -> Generator[None, Any, None]:
    """
    Return a context manager that temporarily sets an Numba config environment
    *name* to *value*.
    """
    ...

def compile_function(name, code, globs):
    """
    Given a *code* string, compile it with globals *globs* and return
    the function named *name*.
    """
    ...

_trashcan_dir = ...
if os.name == 'nt':
    ...
else:
    _trashcan_dir = ...
_trashcan_timeout = ...
def temp_directory(prefix): # -> str:
    """
    Create a temporary directory with the given *prefix* that will survive
    at least as long as this process invocation.  The temporary directory
    will be eventually deleted when it becomes stale enough.

    This is necessary because a DLL file can't be deleted while in use
    under Windows.

    An interesting side-effect is to be able to inspect the test files
    shortly after a test suite run.
    """
    ...

def import_dynamic(modname): # -> ModuleType:
    """
    Import and return a module of the given name.  Care is taken to
    avoid issues due to Python's internal directory caching.
    """
    ...

@contextlib.contextmanager
def captured_output(stream_name): # -> Generator[Any, Any, None]:
    """Return a context manager used by captured_stdout/stdin/stderr
    that temporarily replaces the sys stream *stream_name* with a StringIO."""
    ...

def captured_stdout(): # -> _GeneratorContextManager[Any]:
    """Capture the output of sys.stdout:

       with captured_stdout() as stdout:
           print("hello")
       self.assertEqual(stdout.getvalue(), "hello\n")
    """
    ...

def captured_stderr(): # -> _GeneratorContextManager[Any]:
    """Capture the output of sys.stderr:

       with captured_stderr() as stderr:
           print("hello", file=sys.stderr)
       self.assertEqual(stderr.getvalue(), "hello\n")
    """
    ...

@contextlib.contextmanager
def capture_cache_log(): # -> Generator[Any, Any, None]:
    ...

class EnableNRTStatsMixin:
    """Mixin to enable the NRT statistics counters."""
    def setUp(self): # -> None:
        ...
    
    def tearDown(self): # -> None:
        ...
    


class MemoryLeak:
    __enable_leak_check = ...
    def memory_leak_setup(self): # -> None:
        ...
    
    def memory_leak_teardown(self): # -> None:
        ...
    
    def assert_no_memory_leak(self): # -> None:
        ...
    
    def disable_leak_check(self): # -> None:
        ...
    


class MemoryLeakMixin(EnableNRTStatsMixin, MemoryLeak):
    def setUp(self): # -> None:
        ...
    
    def tearDown(self): # -> None:
        ...
    


@contextlib.contextmanager
def forbid_codegen(): # -> Generator[None, Any, None]:
    """
    Forbid LLVM code generation during the execution of the context
    manager's enclosed block.

    If code generation is invoked, a RuntimeError is raised.
    """
    ...

@contextlib.contextmanager
def redirect_fd(fd): # -> Generator[TextIOWrapper, Any, None]:
    """
    Temporarily redirect *fd* to a pipe's write end and return a file object
    wrapping the pipe's read end.
    """
    ...

def redirect_c_stdout(): # -> _GeneratorContextManager[TextIOWrapper]:
    """Redirect C stdout
    """
    ...

def run_in_new_process_caching(func, cache_dir_prefix=..., verbose=...): # -> dict[str, Any]:
    """Spawn a new process to run `func` with a temporary cache directory.

    The childprocess's stdout and stderr will be captured and redirected to
    the current process's stdout and stderr.

    Returns
    -------
    ret : dict
        exitcode: 0 for success. 1 for exception-raised.
        stdout: str
        stderr: str
    """
    ...

def run_in_new_process_in_cache_dir(func, cache_dir, verbose=...): # -> dict[str, Any]:
    """Spawn a new process to run `func` with a temporary cache directory.

    The childprocess's stdout and stderr will be captured and redirected to
    the current process's stdout and stderr.

    Similar to ``run_in_new_process_caching()`` but the ``cache_dir`` is a
    directory path instead of a name prefix for the directory path.

    Returns
    -------
    ret : dict
        exitcode: 0 for success. 1 for exception-raised.
        stdout: str
        stderr: str
    """
    ...

class CheckWarningsMixin:
    @contextlib.contextmanager
    def check_warnings(self, messages, category=...): # -> Generator[None, Any, None]:
        ...
    


@contextlib.contextmanager
def create_temp_module(source_lines, **jit_options): # -> Generator[ModuleType, Any, None]:
    """A context manager that creates and imports a temporary module
    from sources provided in ``source_lines``.

    Optionally it is possible to provide jit options for ``jit_module`` if it
    is explicitly used in ``source_lines`` like ``jit_module({jit_options})``.
    """
    ...

def run_in_subprocess(code, flags=..., env=..., timeout=...): # -> tuple[bytes, bytes]:
    """Run a snippet of Python code in a subprocess with flags, if any are
    given. 'env' is passed to subprocess.Popen(). 'timeout' is passed to
    popen.communicate().

    Returns the stdout and stderr of the subprocess after its termination.
    """
    ...

def strace(work, syscalls, timeout=...): # -> list[str]:
    """Runs strace whilst executing the function work() in the current process,
    captures the listed syscalls (list of strings). Takes an optional timeout in
    seconds, default is 10, if this is exceeded the process will be sent a
    SIGKILL. Returns a list of lines that are output by strace.
    """
    ...

def strace_supported(): # -> bool:
    """Checks if strace is supported and working"""
    ...

class IRPreservingTestPipeline(CompilerBase):
    """ Same as the standard pipeline, but preserves the func_ir into the
    metadata store after legalisation, useful for testing IR changes"""
    def define_pipelines(self): # -> list[PassManager]:
        ...
    


def print_azure_matrix(): # -> None:
    """This is a utility function that prints out the map of NumPy to Python
    versions and how many of that combination are being tested across all the
    declared config for azure-pipelines. It is useful to run when updating the
    azure-pipelines config to be able to quickly see what the coverage is."""
    ...

