"""
This type stub file was generated by pyright.
"""

import threading

_kernel_context = ...
class FakeOverload:
    '''
    Used only to provide the max_cooperative_grid_blocks method
    '''
    def max_cooperative_grid_blocks(self, blockdim): # -> Literal[1]:
        ...
    


class FakeOverloadDict(dict):
    def __getitem__(self, key): # -> FakeOverload:
        ...
    


class FakeCUDAKernel:
    '''
    Wraps a @cuda.jit-ed function.
    '''
    def __init__(self, fn, device, fastmath=..., extensions=..., debug=...) -> None:
        ...
    
    def __call__(self, *args): # -> None:
        ...
    
    def __getitem__(self, configuration): # -> Self:
        ...
    
    def bind(self): # -> None:
        ...
    
    def specialize(self, *args): # -> Self:
        ...
    
    def forall(self, ntasks, tpb=..., stream=..., sharedmem=...): # -> Self:
        ...
    
    @property
    def overloads(self): # -> FakeOverloadDict:
        ...
    
    @property
    def py_func(self): # -> Any:
        ...
    


class BlockThread(threading.Thread):
    '''
    Manages the execution of a function for a single CUDA thread.
    '''
    def __init__(self, f, manager, blockIdx, threadIdx, debug) -> None:
        ...
    
    def run(self): # -> None:
        ...
    
    def syncthreads(self): # -> None:
        ...
    
    def syncthreads_count(self, value): # -> int:
        ...
    
    def syncthreads_and(self, value): # -> Literal[1, 0]:
        ...
    
    def syncthreads_or(self, value): # -> Literal[1, 0]:
        ...
    
    def __str__(self) -> str:
        ...
    


class BlockManager:
    '''
    Manages the execution of a thread block.

    When run() is called, all threads are started. Each thread executes until it
    hits syncthreads(), at which point it sets its own syncthreads_blocked to
    True so that the BlockManager knows it is blocked. It then waits on its
    syncthreads_event.

    The BlockManager polls threads to determine if they are blocked in
    syncthreads(). If it finds a blocked thread, it adds it to the set of
    blocked threads. When all threads are blocked, it unblocks all the threads.
    The thread are unblocked by setting their syncthreads_blocked back to False
    and setting their syncthreads_event.

    The polling continues until no threads are alive, when execution is
    complete.
    '''
    def __init__(self, f, grid_dim, block_dim, debug) -> None:
        ...
    
    def run(self, grid_point, *args): # -> None:
        ...
    


