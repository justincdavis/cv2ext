"""
This type stub file was generated by pyright.
"""

import operator
from numba.core import types
from numba.core.extending import intrinsic, lower_cast, overload, overload_method, register_jitable

"""Implements operations on bytes and str (unicode) array items."""
s1_dtype = ...
bytes_type = ...
u1_dtype = ...
unicode_byte_width = ...
unicode_uint = ...
unicode_kind = ...
def make_deref_codegen(bitsize): # -> Callable[..., Any]:
    ...

@intrinsic
def deref_uint8(typingctx, data, offset): # -> tuple[Any | Signature, Callable[..., Any]]:
    ...

@intrinsic
def deref_uint16(typingctx, data, offset): # -> tuple[Any | Signature, Callable[..., Any]]:
    ...

@intrinsic
def deref_uint32(typingctx, data, offset): # -> tuple[Any | Signature, Callable[..., Any]]:
    ...

@register_jitable(_nrt=False)
def charseq_get_code(a, i):
    """Access i-th item of CharSeq object via code value
    """
    ...

@register_jitable
def charseq_get_value(a, i):
    """Access i-th item of CharSeq object via code value.

    null code is interpreted as IndexError
    """
    ...

@register_jitable(_nrt=False)
def unicode_charseq_get_code(a, i):
    """Access i-th item of UnicodeCharSeq object via code value
    """
    ...

@register_jitable
def unicode_get_code(a, i): # -> Literal[0]:
    """Access i-th item of UnicodeType object.
    """
    ...

@register_jitable
def bytes_get_code(a, i):
    """Access i-th item of Bytes object.
        """
    ...

def is_default(x, default): # -> bool:
    ...

@register_jitable
def unicode_charseq_get_value(a, i): # -> ndarray[Any, dtype[Any]]:
    """Access i-th item of UnicodeCharSeq object via unicode value

    null code is interpreted as IndexError
    """
    ...

@lower_cast(types.Bytes, types.CharSeq)
def bytes_to_charseq(context, builder, fromty, toty, val):
    ...

@lower_cast(types.CharSeq, types.Bytes)
def charseq_to_bytes(context, builder, fromty, toty, val): # -> Any:
    ...

@lower_cast(types.UnicodeType, types.Bytes)
def unicode_to_bytes_cast(context, builder, fromty, toty, val): # -> Any:
    ...

@lower_cast(types.UnicodeType, types.UnicodeCharSeq)
def unicode_to_unicode_charseq(context, builder, fromty, toty, val):
    ...

@overload(operator.getitem)
def charseq_getitem(s, i): # -> Callable[..., ndarray[Any, dtype[Any]]] | None:
    ...

@overload(len)
def charseq_len(s): # -> Callable[..., Literal[0]] | None:
    ...

@overload(operator.add)
@overload(operator.iadd)
def charseq_concat(a, b): # -> Callable[..., Any] | None:
    ...

@overload(operator.mul)
def charseq_repeat(a, b): # -> Callable[..., Any] | None:
    ...

@overload(operator.not_)
def charseq_not(a): # -> Callable[..., bool] | None:
    ...

@overload(operator.eq)
def charseq_eq(a, b): # -> Callable[..., bool] | None:
    ...

@overload(operator.ne)
def charseq_ne(a, b): # -> Callable[..., bool] | None:
    ...

@overload(operator.lt)
def charseq_lt(a, b): # -> Callable[..., Any | bool] | None:
    ...

@overload(operator.gt)
def charseq_gt(a, b): # -> Callable[..., Any] | None:
    ...

@overload(operator.le)
def charseq_le(a, b): # -> Callable[..., bool] | None:
    ...

@overload(operator.ge)
def charseq_ge(a, b): # -> Callable[..., bool] | None:
    ...

@overload(operator.contains)
def charseq_contains(a, b): # -> Callable[..., bool] | None:
    ...

@overload_method(types.UnicodeCharSeq, 'isascii')
@overload_method(types.CharSeq, 'isascii')
@overload_method(types.Bytes, 'isascii')
def charseq_isascii(s): # -> Callable[..., bool]:
    ...

@overload_method(types.UnicodeCharSeq, '_get_kind')
@overload_method(types.CharSeq, '_get_kind')
def charseq_get_kind(s): # -> Callable[..., Any]:
    ...

@overload_method(types.UnicodeType, '_to_bytes')
def unicode_to_bytes_mth(s): # -> Callable[..., Any]:
    """Convert unicode_type object to Bytes object.

    Note: The usage of _to_bytes method can be eliminated once all
    Python bytes operations are implemented for numba Bytes objects.

    """
    ...

@overload_method(types.CharSeq, '_to_str')
@overload_method(types.Bytes, '_to_str')
def charseq_to_str_mth(s): # -> Callable[..., Any]:
    """Convert bytes array item or bytes instance to UTF-8 str.

    Note: The usage of _to_str method can be eliminated once all
    Python bytes operations are implemented for numba Bytes objects.
    """
    ...

@overload_method(types.UnicodeCharSeq, "__str__")
def charseq_str(s): # -> Callable[..., Any]:
    ...

@overload(bytes)
def charseq_bytes(s): # -> Callable[..., Any] | None:
    ...

@overload_method(types.UnicodeCharSeq, '__hash__')
def unicode_charseq_hash(s): # -> Callable[..., int]:
    ...

@overload_method(types.CharSeq, '__hash__')
def charseq_hash(s): # -> Callable[..., int]:
    ...

@overload_method(types.UnicodeCharSeq, 'isupper')
def unicode_charseq_isupper(s): # -> Callable[..., bool]:
    ...

@overload_method(types.CharSeq, 'isupper')
def charseq_isupper(s): # -> Callable[..., bool]:
    ...

@overload_method(types.UnicodeCharSeq, 'upper')
def unicode_charseq_upper(s): # -> Callable[..., str]:
    ...

@overload_method(types.CharSeq, 'upper')
def charseq_upper(s): # -> Callable[..., Any]:
    ...

@overload_method(types.UnicodeCharSeq, 'find')
@overload_method(types.CharSeq, 'find')
@overload_method(types.Bytes, 'find')
def unicode_charseq_find(a, b): # -> Callable[..., int] | None:
    ...

@overload_method(types.UnicodeCharSeq, 'rfind')
@overload_method(types.CharSeq, 'rfind')
@overload_method(types.Bytes, 'rfind')
def unicode_charseq_rfind(a, b): # -> Callable[..., int] | None:
    ...

@overload_method(types.UnicodeCharSeq, 'startswith')
@overload_method(types.CharSeq, 'startswith')
@overload_method(types.Bytes, 'startswith')
def unicode_charseq_startswith(a, b): # -> Callable[..., bool] | None:
    ...

@overload_method(types.UnicodeCharSeq, 'endswith')
@overload_method(types.CharSeq, 'endswith')
@overload_method(types.Bytes, 'endswith')
def unicode_charseq_endswith(a, b): # -> Callable[..., bool] | None:
    ...

@overload_method(types.UnicodeCharSeq, 'split')
@overload_method(types.CharSeq, 'split')
@overload_method(types.Bytes, 'split')
def unicode_charseq_split(a, sep=..., maxsplit=...): # -> Callable[..., list[str]] | None:
    ...

@overload_method(types.UnicodeCharSeq, 'ljust')
@overload_method(types.CharSeq, 'ljust')
@overload_method(types.Bytes, 'ljust')
def unicode_charseq_ljust(a, width, fillchar=...): # -> Callable[..., str] | None:
    ...

@overload_method(types.UnicodeCharSeq, 'rjust')
@overload_method(types.CharSeq, 'rjust')
@overload_method(types.Bytes, 'rjust')
def unicode_charseq_rjust(a, width, fillchar=...): # -> Callable[..., str] | None:
    ...

@overload_method(types.UnicodeCharSeq, 'center')
@overload_method(types.CharSeq, 'center')
@overload_method(types.Bytes, 'center')
def unicode_charseq_center(a, width, fillchar=...): # -> Callable[..., str] | None:
    ...

@overload_method(types.UnicodeCharSeq, 'zfill')
@overload_method(types.CharSeq, 'zfill')
@overload_method(types.Bytes, 'zfill')
def unicode_charseq_zfill(a, width): # -> Callable[..., str] | None:
    ...

@overload_method(types.UnicodeCharSeq, 'lstrip')
@overload_method(types.CharSeq, 'lstrip')
@overload_method(types.Bytes, 'lstrip')
def unicode_charseq_lstrip(a, chars=...): # -> Callable[..., str] | None:
    ...

@overload_method(types.UnicodeCharSeq, 'rstrip')
@overload_method(types.CharSeq, 'rstrip')
@overload_method(types.Bytes, 'rstrip')
def unicode_charseq_rstrip(a, chars=...): # -> Callable[..., str] | None:
    ...

@overload_method(types.UnicodeCharSeq, 'strip')
@overload_method(types.CharSeq, 'strip')
@overload_method(types.Bytes, 'strip')
def unicode_charseq_strip(a, chars=...): # -> Callable[..., str] | None:
    ...

@overload_method(types.UnicodeCharSeq, 'join')
@overload_method(types.CharSeq, 'join')
@overload_method(types.Bytes, 'join')
def unicode_charseq_join(a, parts): # -> Callable[..., str] | None:
    ...

