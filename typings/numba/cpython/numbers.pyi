"""
This type stub file was generated by pyright.
"""

import operator
from numba.core.imputils import lower_builtin, lower_cast, lower_constant, lower_getattr
from numba.core import types

def int_add_impl(context, builder, sig, args):
    ...

def int_sub_impl(context, builder, sig, args):
    ...

def int_mul_impl(context, builder, sig, args):
    ...

def int_divmod_signed(context, builder, ty, x, y): # -> tuple[Any, Any]:
    """
    Reference Objects/intobject.c
    xdivy = x / y;
    xmody = (long)(x - (unsigned long)xdivy * y);
    /* If the signs of x and y differ, and the remainder is non-0,
     * C89 doesn't define whether xdivy is now the floor or the
     * ceiling of the infinitely precise quotient.  We want the floor,
     * and we have it iff the remainder's sign matches y's.
     */
    if (xmody && ((y ^ xmody) < 0) /* i.e. and signs differ */) {
        xmody += y;
        --xdivy;
        assert(xmody && ((y ^ xmody) >= 0));
    }
    *p_xdivy = xdivy;
    *p_xmody = xmody;
    """
    ...

def int_divmod(context, builder, ty, x, y): # -> tuple[Any, Any]:
    """
    Integer divmod(x, y).  The caller must ensure that y != 0.
    """
    ...

@lower_builtin(divmod, types.Integer, types.Integer)
def int_divmod_impl(context, builder, sig, args): # -> Constant:
    ...

@lower_builtin(operator.floordiv, types.Integer, types.Integer)
@lower_builtin(operator.ifloordiv, types.Integer, types.Integer)
def int_floordiv_impl(context, builder, sig, args):
    ...

@lower_builtin(operator.truediv, types.Integer, types.Integer)
@lower_builtin(operator.itruediv, types.Integer, types.Integer)
def int_truediv_impl(context, builder, sig, args):
    ...

@lower_builtin(operator.mod, types.Integer, types.Integer)
@lower_builtin(operator.imod, types.Integer, types.Integer)
def int_rem_impl(context, builder, sig, args):
    ...

def int_power_impl(context, builder, sig, args):
    """
    a ^ b, where a is an integer or real, and b an integer
    """
    ...

@lower_builtin(operator.pow, types.Integer, types.IntegerLiteral)
@lower_builtin(operator.ipow, types.Integer, types.IntegerLiteral)
@lower_builtin(operator.pow, types.Float, types.IntegerLiteral)
@lower_builtin(operator.ipow, types.Float, types.IntegerLiteral)
def static_power_impl(context, builder, sig, args):
    """
    a ^ b, where a is an integer or real, and b a constant integer
    """
    ...

def int_slt_impl(context, builder, sig, args):
    ...

def int_sle_impl(context, builder, sig, args):
    ...

def int_sgt_impl(context, builder, sig, args):
    ...

def int_sge_impl(context, builder, sig, args):
    ...

def int_ult_impl(context, builder, sig, args):
    ...

def int_ule_impl(context, builder, sig, args):
    ...

def int_ugt_impl(context, builder, sig, args):
    ...

def int_uge_impl(context, builder, sig, args):
    ...

def int_eq_impl(context, builder, sig, args):
    ...

def int_ne_impl(context, builder, sig, args):
    ...

def int_signed_unsigned_cmp(op): # -> Callable[..., Any]:
    ...

def int_unsigned_signed_cmp(op): # -> Callable[..., Any]:
    ...

def int_abs_impl(context, builder, sig, args):
    ...

def uint_abs_impl(context, builder, sig, args):
    ...

def int_shl_impl(context, builder, sig, args):
    ...

def int_shr_impl(context, builder, sig, args):
    ...

def int_and_impl(context, builder, sig, args):
    ...

def int_or_impl(context, builder, sig, args):
    ...

def int_xor_impl(context, builder, sig, args):
    ...

def int_negate_impl(context, builder, sig, args):
    ...

def int_positive_impl(context, builder, sig, args):
    ...

def int_invert_impl(context, builder, sig, args):
    ...

def int_sign_impl(context, builder, sig, args):
    """
    np.sign(int)
    """
    ...

def bool_negate_impl(context, builder, sig, args):
    ...

def bool_unary_positive_impl(context, builder, sig, args):
    ...

def real_add_impl(context, builder, sig, args):
    ...

def real_sub_impl(context, builder, sig, args):
    ...

def real_mul_impl(context, builder, sig, args):
    ...

def real_div_impl(context, builder, sig, args):
    ...

def real_divmod(context, builder, x, y): # -> tuple[Any, Any]:
    ...

def real_divmod_func_body(context, builder, vx, wx): # -> tuple[Any, Any]:
    ...

@lower_builtin(divmod, types.Float, types.Float)
def real_divmod_impl(context, builder, sig, args, loc=...): # -> Constant:
    ...

def real_mod_impl(context, builder, sig, args, loc=...):
    ...

def real_floordiv_impl(context, builder, sig, args, loc=...):
    ...

def real_power_impl(context, builder, sig, args):
    ...

def real_lt_impl(context, builder, sig, args):
    ...

def real_le_impl(context, builder, sig, args):
    ...

def real_gt_impl(context, builder, sig, args):
    ...

def real_ge_impl(context, builder, sig, args):
    ...

def real_eq_impl(context, builder, sig, args):
    ...

def real_ne_impl(context, builder, sig, args):
    ...

def real_abs_impl(context, builder, sig, args):
    ...

def real_negate_impl(context, builder, sig, args):
    ...

def real_positive_impl(context, builder, sig, args):
    ...

def real_sign_impl(context, builder, sig, args):
    """
    np.sign(float)
    """
    ...

ty = ...
@lower_getattr(types.Complex, "real")
def complex_real_impl(context, builder, typ, value):
    ...

@lower_getattr(types.Complex, "imag")
def complex_imag_impl(context, builder, typ, value):
    ...

@lower_builtin("complex.conjugate", types.Complex)
def complex_conjugate_impl(context, builder, sig, args):
    ...

def real_real_impl(context, builder, typ, value):
    ...

def real_imag_impl(context, builder, typ, value):
    ...

def real_conjugate_impl(context, builder, sig, args):
    ...

@lower_builtin(operator.pow, types.Complex, types.Complex)
@lower_builtin(operator.ipow, types.Complex, types.Complex)
@lower_builtin(pow, types.Complex, types.Complex)
def complex_power_impl(context, builder, sig, args):
    ...

def complex_add_impl(context, builder, sig, args):
    ...

def complex_sub_impl(context, builder, sig, args):
    ...

def complex_mul_impl(context, builder, sig, args):
    """
    (a+bi)(c+di)=(ac-bd)+i(ad+bc)
    """
    ...

NAN = ...
def complex_div_impl(context, builder, sig, args):
    ...

def complex_negate_impl(context, builder, sig, args):
    ...

def complex_positive_impl(context, builder, sig, args):
    ...

def complex_eq_impl(context, builder, sig, args):
    ...

def complex_ne_impl(context, builder, sig, args):
    ...

def complex_abs_impl(context, builder, sig, args):
    """
    abs(z) := hypot(z.real, z.imag)
    """
    ...

ty = ...
@lower_builtin("number.item", types.Boolean)
@lower_builtin("number.item", types.Number)
def number_item_impl(context, builder, sig, args):
    """
    The no-op .item() method on booleans and numbers.
    """
    ...

def number_not_impl(context, builder, sig, args):
    ...

@lower_builtin(bool, types.Boolean)
def bool_as_bool(context, builder, sig, args):
    ...

@lower_builtin(bool, types.Integer)
def int_as_bool(context, builder, sig, args):
    ...

@lower_builtin(bool, types.Float)
def float_as_bool(context, builder, sig, args):
    ...

@lower_builtin(bool, types.Complex)
def complex_as_bool(context, builder, sig, args):
    ...

@lower_cast(types.IntegerLiteral, types.Integer)
@lower_cast(types.IntegerLiteral, types.Float)
@lower_cast(types.IntegerLiteral, types.Complex)
def literal_int_to_number(context, builder, fromty, toty, val):
    ...

@lower_cast(types.Integer, types.Integer)
def integer_to_integer(context, builder, fromty, toty, val):
    ...

@lower_cast(types.Integer, types.voidptr)
def integer_to_voidptr(context, builder, fromty, toty, val):
    ...

@lower_cast(types.Float, types.Float)
def float_to_float(context, builder, fromty, toty, val):
    ...

@lower_cast(types.Integer, types.Float)
def integer_to_float(context, builder, fromty, toty, val):
    ...

@lower_cast(types.Float, types.Integer)
def float_to_integer(context, builder, fromty, toty, val):
    ...

@lower_cast(types.Float, types.Complex)
@lower_cast(types.Integer, types.Complex)
def non_complex_to_complex(context, builder, fromty, toty, val):
    ...

@lower_cast(types.Complex, types.Complex)
def complex_to_complex(context, builder, fromty, toty, val):
    ...

@lower_cast(types.Any, types.Boolean)
def any_to_boolean(context, builder, fromty, toty, val):
    ...

@lower_cast(types.Boolean, types.Number)
def boolean_to_any(context, builder, fromty, toty, val):
    ...

@lower_cast(types.IntegerLiteral, types.Boolean)
@lower_cast(types.BooleanLiteral, types.Boolean)
def literal_int_to_boolean(context, builder, fromty, toty, val):
    ...

@lower_constant(types.Complex)
def constant_complex(context, builder, ty, pyval): # -> Constant:
    ...

@lower_constant(types.Integer)
@lower_constant(types.Float)
@lower_constant(types.Boolean)
def constant_integer(context, builder, ty, pyval):
    ...

def scalar_view(scalar, viewty): # -> Callable[..., Any] | None:
    """ Typing for the np scalar 'view' method. """
    ...

