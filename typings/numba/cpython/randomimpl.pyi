"""
This type stub file was generated by pyright.
"""

import random
import numpy as np
from numba.core.extending import overload, register_jitable

"""
Implement the random and np.random module functions.
"""
registry = ...
lower = ...
int32_t = ...
int64_t = ...
def const_int(x): # -> Constant:
    ...

double = ...
N = ...
N_const = ...
rnd_state_t = ...
rnd_state_ptr_t = ...
def get_state_ptr(context, builder, name):
    """
    Get a pointer to the given thread-local random state
    (depending on *name*: "py" or "np").
    If the state isn't initialized, it is lazily initialized with
    system entropy.
    """
    ...

def get_py_state_ptr(context, builder):
    """
    Get a pointer to the thread-local Python random state.
    """
    ...

def get_np_state_ptr(context, builder):
    """
    Get a pointer to the thread-local Numpy random state.
    """
    ...

def get_internal_state_ptr(context, builder):
    """
    Get a pointer to the thread-local internal random state.
    """
    ...

def get_index_ptr(builder, state_ptr):
    ...

def get_array_ptr(builder, state_ptr):
    ...

def get_has_gauss_ptr(builder, state_ptr):
    ...

def get_gauss_ptr(builder, state_ptr):
    ...

def get_rnd_shuffle(builder): # -> Function:
    """
    Get the internal function to shuffle the MT taste.
    """
    ...

def get_next_int32(context, builder, state_ptr):
    """
    Get the next int32 generated by the PRNG at *state_ptr*.
    """
    ...

def get_next_double(context, builder, state_ptr):
    """
    Get the next double generated by the PRNG at *state_ptr*.
    """
    ...

def get_next_int(context, builder, state_ptr, nbits, is_numpy):
    """
    Get the next integer with width *nbits*.
    """
    ...

@overload(random.seed)
def seed_impl(a): # -> Callable[..., Any] | None:
    ...

@overload(np.random.seed)
def seed_impl(seed): # -> Callable[..., Any] | None:
    ...

@overload(random.random)
def random_impl(): # -> Callable[[], Any]:
    ...

@overload(np.random.random)
@overload(np.random.random_sample)
@overload(np.random.sample)
@overload(np.random.ranf)
def random_impl0(): # -> Callable[[], Any]:
    ...

@overload(np.random.random)
@overload(np.random.random_sample)
@overload(np.random.sample)
@overload(np.random.ranf)
def random_impl1(size=...): # -> Callable[..., float] | Callable[..., NDArray[float64]] | None:
    ...

@overload(random.gauss)
@overload(random.normalvariate)
def gauss_impl(mu, sigma): # -> Callable[..., Any] | None:
    ...

@overload(np.random.standard_normal)
@overload(np.random.normal)
def np_gauss_impl0(): # -> Callable[[], float]:
    ...

@overload(np.random.normal)
def np_gauss_impl1(loc): # -> Callable[..., Any] | None:
    ...

@overload(np.random.normal)
def np_gauss_impl2(loc, scale): # -> Callable[..., Any] | None:
    ...

@overload(np.random.standard_normal)
def standard_normal_impl1(size): # -> Callable[..., float] | Callable[..., NDArray[float64]] | None:
    ...

@overload(np.random.normal)
def np_gauss_impl3(loc, scale, size): # -> Callable[..., Any] | Callable[..., NDArray[float64]] | None:
    ...

@overload(random.getrandbits)
def getrandbits_impl(k): # -> Callable[..., Any] | None:
    ...

@overload(random.randrange)
def randrange_impl_1(start): # -> Callable[..., int] | None:
    ...

@overload(random.randrange)
def randrange_impl_2(start, stop): # -> Callable[..., int] | None:
    ...

@overload(random.randrange)
def randrange_impl_3(start, stop, step): # -> Callable[..., Any] | None:
    ...

@overload(random.randint)
def randint_impl_1(a, b): # -> Callable[..., int] | None:
    ...

@overload(np.random.randint)
def np_randint_impl_1(low): # -> Callable[..., Any] | None:
    ...

@overload(np.random.randint)
def np_randint_impl_2(low, high): # -> Callable[..., Any] | None:
    ...

@overload(np.random.randint)
def np_randint_impl_3(low, high, size): # -> Callable[..., Any] | Callable[..., NDArray[float64]] | None:
    ...

@overload(np.random.uniform)
def np_uniform_impl0(): # -> Callable[[], float]:
    ...

@overload(random.uniform)
def uniform_impl2(a, b): # -> Callable[..., Any] | None:
    ...

@overload(np.random.uniform)
def np_uniform_impl2(low, high): # -> Callable[..., Any] | None:
    ...

def uniform_impl(state, a_preprocessor, b_preprocessor): # -> Callable[..., Any]:
    ...

@overload(np.random.uniform)
def np_uniform_impl3(low, high, size): # -> Callable[..., Any] | Callable[..., NDArray[float64]] | None:
    ...

@overload(random.triangular)
def triangular_impl_2(low, high): # -> Callable[..., Any] | None:
    ...

@overload(random.triangular)
def triangular_impl_3(low, high, mode): # -> Callable[..., Any] | None:
    ...

@overload(np.random.triangular)
def triangular_impl_3(left, mode, right): # -> Callable[..., Any] | None:
    ...

@overload(np.random.triangular)
def triangular_impl(left, mode, right, size=...): # -> Callable[..., Any] | Callable[..., NDArray[float64]] | None:
    ...

@overload(random.gammavariate)
def gammavariate_impl(alpha, beta): # -> Callable[..., Any | None] | None:
    ...

@overload(np.random.standard_gamma)
@overload(np.random.gamma)
def ol_np_random_gamma1(shape): # -> Callable[..., Any] | None:
    ...

@overload(np.random.gamma)
def ol_np_random_gamma2(shape, scale): # -> Callable[..., Any] | None:
    ...

@overload(np.random.gamma)
def gamma_impl(shape, scale, size): # -> Callable[..., Any] | Callable[..., NDArray[float64]] | None:
    ...

@overload(np.random.standard_gamma)
def standard_gamma_impl(shape, size): # -> Callable[..., Any] | Callable[..., NDArray[float64]] | None:
    ...

@overload(random.betavariate)
def betavariate_impl(alpha, beta): # -> Callable[..., float | Any] | None:
    ...

@overload(np.random.beta)
def ol_np_random_beta(a, b): # -> Callable[..., Any] | None:
    ...

@overload(np.random.beta)
def beta_impl(a, b, size): # -> Callable[..., Any] | Callable[..., NDArray[float64]] | None:
    ...

@overload(random.expovariate)
def expovariate_impl(lambd): # -> Callable[..., Any] | None:
    ...

@overload(np.random.exponential)
def exponential_impl(scale): # -> Callable[..., Any] | None:
    ...

@overload(np.random.exponential)
def exponential_impl(scale, size): # -> Callable[..., Any] | Callable[..., NDArray[float64]] | None:
    ...

@overload(np.random.standard_exponential)
@overload(np.random.exponential)
def exponential_impl(): # -> Callable[[], float]:
    ...

@overload(np.random.standard_exponential)
def standard_exponential_impl(size): # -> Callable[..., float] | Callable[..., NDArray[float64]] | None:
    ...

@overload(np.random.lognormal)
def np_lognormal_impl0(): # -> Callable[[], float]:
    ...

@overload(np.random.lognormal)
def np_log_normal_impl1(mean): # -> Callable[..., Any] | None:
    ...

@overload(np.random.lognormal)
def np_log_normal_impl2(mean, sigma): # -> Callable[..., Any] | None:
    ...

@overload(np.random.lognormal)
def lognormal_impl(mean, sigma, size): # -> Callable[..., Any] | Callable[..., NDArray[float64]] | None:
    ...

@overload(random.lognormvariate)
def lognormvariate_impl(mu, sigma): # -> Callable[..., Any] | None:
    ...

@overload(random.paretovariate)
def paretovariate_impl(alpha): # -> Callable[..., Any] | None:
    ...

@overload(np.random.pareto)
def pareto_impl(a): # -> Callable[..., Any] | None:
    ...

@overload(np.random.pareto)
def pareto_impl(a, size): # -> Callable[..., Any] | Callable[..., NDArray[float64]] | None:
    ...

@overload(random.weibullvariate)
def weibullvariate_impl(alpha, beta): # -> Callable[..., Any] | None:
    ...

@overload(np.random.weibull)
def weibull_impl(a): # -> Callable[..., Any] | None:
    ...

@overload(np.random.weibull)
def weibull_impl2(a, size): # -> Callable[..., Any] | Callable[..., NDArray[float64]] | None:
    ...

@overload(random.vonmisesvariate)
def vonmisesvariate_impl(mu, kappa): # -> Callable[..., Any] | None:
    ...

@overload(np.random.vonmises)
def vonmisesvariate_impl(mu, kappa): # -> Callable[..., Any] | None:
    ...

@overload(np.random.vonmises)
def vonmises_impl(mu, kappa, size): # -> Callable[..., Any] | Callable[..., NDArray[float64]] | None:
    ...

@overload(np.random.binomial)
def binomial_impl(n, p): # -> Callable[..., Any | int] | None:
    ...

@overload(np.random.binomial)
def binomial_impl(n, p, size): # -> Callable[..., Any] | Callable[..., NDArray[Any]] | None:
    ...

@overload(np.random.chisquare)
def chisquare_impl(df): # -> Callable[..., Any] | None:
    ...

@overload(np.random.chisquare)
def chisquare_impl2(df, size): # -> Callable[..., Any] | Callable[..., NDArray[float64]] | None:
    ...

@overload(np.random.f)
def f_impl(dfnum, dfden): # -> Callable[..., Any] | None:
    ...

@overload(np.random.f)
def f_impl(dfnum, dfden, size): # -> Callable[..., Any] | Callable[..., NDArray[float64]] | None:
    ...

@overload(np.random.geometric)
def geometric_impl(p): # -> Callable[..., int] | None:
    ...

@overload(np.random.geometric)
def geometric_impl(p, size): # -> Callable[..., Any] | Callable[..., NDArray[Any]] | None:
    ...

@overload(np.random.gumbel)
def gumbel_impl(loc, scale): # -> Callable[..., Any] | None:
    ...

@overload(np.random.gumbel)
def gumbel_impl3(loc, scale, size): # -> Callable[..., Any] | Callable[..., NDArray[float64]] | None:
    ...

@overload(np.random.hypergeometric)
def hypergeometric_impl(ngood, nbad, nsample): # -> Callable[..., int] | None:
    ...

@overload(np.random.hypergeometric)
def hypergeometric_impl(ngood, nbad, nsample, size): # -> Callable[..., Any] | Callable[..., NDArray[Any]] | None:
    ...

@overload(np.random.laplace)
def laplace_impl0(): # -> Callable[[], float]:
    ...

@overload(np.random.laplace)
def laplace_impl1(loc): # -> Callable[..., Any] | None:
    ...

@overload(np.random.laplace)
def laplace_impl2(loc, scale): # -> Callable[..., Any] | None:
    ...

@overload(np.random.laplace)
def laplace_impl3(loc, scale, size): # -> Callable[..., Any] | Callable[..., NDArray[float64]] | None:
    ...

def laplace_impl(loc, scale):
    ...

@overload(np.random.logistic)
def logistic_impl0(): # -> Callable[[], float]:
    ...

@overload(np.random.logistic)
def logistic_impl1(loc): # -> Callable[..., Any] | None:
    ...

@overload(np.random.logistic)
def logistic_impl2(loc, scale): # -> Callable[..., Any] | None:
    ...

@overload(np.random.logistic)
def logistic_impl3(loc, scale, size): # -> Callable[..., Any] | Callable[..., NDArray[float64]] | None:
    ...

def logistic_impl(loc, scale):
    ...

@overload(np.random.logseries)
def logseries_impl(p): # -> Callable[..., int64 | Literal[1, 2] | None] | None:
    ...

@overload(np.random.logseries)
def logseries_impl(p, size): # -> Callable[..., Any] | Callable[..., NDArray[Any]] | None:
    ...

@overload(np.random.negative_binomial)
def negative_binomial_impl(n, p): # -> Callable[..., Any] | None:
    ...

@overload(np.random.poisson)
def poisson_impl0(): # -> Callable[[], int]:
    ...

@overload(np.random.poisson)
def poisson_impl1(lam): # -> Callable[..., Any] | None:
    ...

@overload(np.random.poisson)
def poisson_impl2(lam, size): # -> Callable[..., Any] | Callable[..., NDArray[Any]] | None:
    ...

@overload(np.random.power)
def power_impl(a): # -> Callable[..., float] | None:
    ...

@overload(np.random.power)
def power_impl(a, size): # -> Callable[..., Any] | Callable[..., NDArray[float64]] | None:
    ...

@overload(np.random.rayleigh)
def rayleigh_impl0(): # -> Callable[[], float]:
    ...

@overload(np.random.rayleigh)
def rayleigh_impl1(scale): # -> Callable[..., Any] | None:
    ...

@overload(np.random.rayleigh)
def rayleigh_impl2(scale, size): # -> Callable[..., Any] | Callable[..., NDArray[float64]] | None:
    ...

@overload(np.random.standard_cauchy)
def cauchy_impl(): # -> Callable[[], float]:
    ...

@overload(np.random.standard_cauchy)
def standard_cauchy_impl(size): # -> Callable[..., float] | Callable[..., NDArray[float64]] | None:
    ...

@overload(np.random.standard_t)
def standard_t_impl(df): # -> Callable[..., float] | None:
    ...

@overload(np.random.standard_t)
def standard_t_impl2(df, size): # -> Callable[..., Any] | Callable[..., NDArray[float64]] | None:
    ...

@overload(np.random.wald)
def wald_impl(mean, scale): # -> Callable[..., Any] | None:
    ...

@overload(np.random.wald)
def wald_impl2(mean, scale, size): # -> Callable[..., Any] | Callable[..., NDArray[float64]] | None:
    ...

@overload(np.random.zipf)
def zipf_impl(a): # -> Callable[..., int | None] | None:
    ...

@overload(np.random.zipf)
def zipf_impl(a, size): # -> Callable[..., Any] | Callable[..., NDArray[Any]] | None:
    ...

def do_shuffle_impl(x, rng): # -> Callable[..., None]:
    ...

@overload(random.shuffle)
def shuffle_impl(x): # -> Callable[..., None]:
    ...

@overload(np.random.shuffle)
def shuffle_impl(x): # -> Callable[..., None]:
    ...

@overload(np.random.permutation)
def permutation_impl(x): # -> Callable[..., Any]:
    ...

@overload(np.random.rand)
def rand(*size): # -> Callable[..., float]:
    ...

@overload(np.random.randn)
def randn(*size): # -> Callable[..., float]:
    ...

@overload(np.random.choice)
def choice(a, size=..., replace=...): # -> Callable[..., Any]:
    ...

@overload(np.random.multinomial)
def multinomial(n, pvals, size=...): # -> Callable[..., NDArray[Any]]:
    ...

@overload(np.random.dirichlet)
def dirichlet(alpha): # -> Callable[..., NDArray[float64]] | None:
    ...

@overload(np.random.dirichlet)
def dirichlet(alpha, size=...): # -> Callable[..., NDArray[float64]]:
    ...

@register_jitable
def dirichlet_arr(alpha, out): # -> None:
    ...

@overload(np.random.noncentral_chisquare)
def noncentral_chisquare(df, nonc): # -> Callable[..., float | Any] | None:
    ...

@overload(np.random.noncentral_chisquare)
def noncentral_chisquare(df, nonc, size=...): # -> Callable[..., float | Any]:
    ...

@register_jitable
def noncentral_chisquare_single(df, nonc): # -> float:
    ...

@register_jitable
def validate_noncentral_chisquare_input(df, nonc): # -> None:
    ...

