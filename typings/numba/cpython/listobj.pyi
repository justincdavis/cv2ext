"""
This type stub file was generated by pyright.
"""

import operator
from numba.core import types
from numba.core.imputils import RefType, iternext_impl, lower_builtin, lower_cast
from numba.core.extending import overload, overload_method

"""
Support for native homogeneous lists.
"""
def get_list_payload(context, builder, list_type, value):
    """
    Given a list value and type, get its payload structure (as a
    reference, so that mutations are seen by all).
    """
    ...

def get_itemsize(context, list_type):
    """
    Return the item size for the given list type.
    """
    ...

class _ListPayloadMixin:
    @property
    def size(self):
        ...
    
    @size.setter
    def size(self, value): # -> None:
        ...
    
    @property
    def dirty(self):
        ...
    
    @property
    def data(self):
        ...
    
    def getitem(self, idx):
        ...
    
    def fix_index(self, idx):
        """
        Fix negative indices by adding the size to them.  Positive
        indices are left untouched.
        """
        ...
    
    def is_out_of_bounds(self, idx):
        """
        Return whether the index is out of bounds.
        """
        ...
    
    def clamp_index(self, idx):
        """
        Clamp the index in [0, size].
        """
        ...
    
    def guard_index(self, idx, msg): # -> None:
        """
        Raise an error if the index is out of bounds.
        """
        ...
    
    def fix_slice(self, slice): # -> None:
        """
        Fix slice start and stop to be valid (inclusive and exclusive, resp)
        indexing bounds.
        """
        ...
    
    def incref_value(self, val): # -> None:
        "Incref an element value"
        ...
    
    def decref_value(self, val): # -> None:
        "Decref an element value"
        ...
    


class ListPayloadAccessor(_ListPayloadMixin):
    """
    A helper object to access the list attributes given the pointer to the
    payload type.
    """
    def __init__(self, context, builder, list_type, payload_ptr) -> None:
        ...
    


class ListInstance(_ListPayloadMixin):
    def __init__(self, context, builder, list_type, list_val) -> None:
        ...
    
    @property
    def dtype(self):
        ...
    
    @property
    def parent(self):
        ...
    
    @parent.setter
    def parent(self, value): # -> None:
        ...
    
    @property
    def value(self):
        ...
    
    @property
    def meminfo(self):
        ...
    
    def set_dirty(self, val): # -> None:
        ...
    
    def clear_value(self, idx): # -> None:
        """Remove the value at the location
        """
        ...
    
    def setitem(self, idx, val, incref, decref_old_value=...): # -> None:
        ...
    
    def inititem(self, idx, val, incref=...): # -> None:
        ...
    
    def zfill(self, start, stop): # -> None:
        """Zero-fill the memory at index *start* to *stop*

        *stop* MUST not be smaller than *start*.
        """
        ...
    
    @classmethod
    def allocate_ex(cls, context, builder, list_type, nitems): # -> tuple[Any, Self]:
        """
        Allocate a ListInstance with its storage.
        Return a (ok, instance) tuple where *ok* is a LLVM boolean and
        *instance* is a ListInstance object (the object's contents are
        only valid when *ok* is true).
        """
        ...
    
    def define_dtor(self): # -> Function:
        "Define the destructor if not already defined"
        ...
    
    def get_dtor(self):
        """"Get the element dtor function pointer as void pointer.

        It's safe to be called multiple times.
        """
        ...
    
    @classmethod
    def allocate(cls, context, builder, list_type, nitems): # -> Self:
        """
        Allocate a ListInstance with its storage.  Same as allocate_ex(),
        but return an initialized *instance*.  If allocation failed,
        control is transferred to the caller using the target's current
        call convention.
        """
        ...
    
    @classmethod
    def from_meminfo(cls, context, builder, list_type, meminfo): # -> Self:
        """
        Allocate a new list instance pointing to an existing payload
        (a meminfo pointer).
        Note the parent field has to be filled by the caller.
        """
        ...
    
    def resize(self, new_size): # -> None:
        """
        Ensure the list is properly sized for the new size.
        """
        ...
    
    def move(self, dest_idx, src_idx, count): # -> None:
        """
        Move `count` elements from `src_idx` to `dest_idx`.
        """
        ...
    


class ListIterInstance(_ListPayloadMixin):
    def __init__(self, context, builder, iter_type, iter_val) -> None:
        ...
    
    @classmethod
    def from_list(cls, context, builder, iter_type, list_val): # -> Self:
        ...
    
    @property
    def value(self):
        ...
    
    @property
    def index(self):
        ...
    
    @index.setter
    def index(self, value): # -> None:
        ...
    


def build_list(context, builder, list_type, items):
    """
    Build a list of the given type, containing the given items.
    """
    ...

@lower_builtin(list, types.IterableType)
def list_constructor(context, builder, sig, args):
    ...

@lower_builtin(list)
def list_constructor(context, builder, sig, args):
    ...

@lower_builtin(len, types.List)
def list_len(context, builder, sig, args):
    ...

@lower_builtin('getiter', types.List)
def getiter_list(context, builder, sig, args):
    ...

@lower_builtin('iternext', types.ListIter)
@iternext_impl(RefType.BORROWED)
def iternext_listiter(context, builder, sig, args, result): # -> None:
    ...

@lower_builtin(operator.getitem, types.List, types.Integer)
def getitem_list(context, builder, sig, args):
    ...

@lower_builtin(operator.setitem, types.List, types.Integer, types.Any)
def setitem_list(context, builder, sig, args):
    ...

@lower_builtin(operator.getitem, types.List, types.SliceType)
def getslice_list(context, builder, sig, args):
    ...

@lower_builtin(operator.setitem, types.List, types.SliceType, types.Any)
def setitem_list(context, builder, sig, args):
    ...

@lower_builtin(operator.delitem, types.List, types.Integer)
def delitem_list_index(context, builder, sig, args):
    ...

@lower_builtin(operator.delitem, types.List, types.SliceType)
def delitem_list(context, builder, sig, args):
    ...

@lower_builtin(operator.contains, types.Sequence, types.Any)
def in_seq(context, builder, sig, args):
    ...

@lower_builtin(bool, types.Sequence)
def sequence_bool(context, builder, sig, args):
    ...

@overload(operator.truth)
def sequence_truth(seq): # -> Callable[..., bool] | None:
    ...

@lower_builtin(operator.add, types.List, types.List)
def list_add(context, builder, sig, args):
    ...

@lower_builtin(operator.iadd, types.List, types.List)
def list_add_inplace(context, builder, sig, args):
    ...

@lower_builtin(operator.mul, types.List, types.Integer)
@lower_builtin(operator.mul, types.Integer, types.List)
def list_mul(context, builder, sig, args):
    ...

@lower_builtin(operator.imul, types.List, types.Integer)
def list_mul_inplace(context, builder, sig, args):
    ...

@lower_builtin(operator.is_, types.List, types.List)
def list_is(context, builder, sig, args):
    ...

@lower_builtin(operator.eq, types.List, types.List)
def list_eq(context, builder, sig, args):
    ...

def all_list(*args): # -> bool:
    ...

@overload(operator.ne)
def impl_list_ne(a, b): # -> Callable[..., bool] | None:
    ...

@overload(operator.le)
def impl_list_le(a, b): # -> Callable[..., bool] | None:
    ...

@overload(operator.lt)
def impl_list_lt(a, b): # -> Callable[..., bool] | None:
    ...

@overload(operator.ge)
def impl_list_ge(a, b): # -> Callable[..., Any] | None:
    ...

@overload(operator.gt)
def impl_list_gt(a, b): # -> Callable[..., Any] | None:
    ...

@lower_builtin("list.append", types.List, types.Any)
def list_append(context, builder, sig, args):
    ...

@lower_builtin("list.clear", types.List)
def list_clear(context, builder, sig, args):
    ...

@overload_method(types.List, "copy")
def list_copy(lst): # -> Callable[..., list[Any]]:
    ...

@overload_method(types.List, "count")
def list_count(lst, value): # -> Callable[..., int]:
    ...

@lower_builtin("list.extend", types.List, types.IterableType)
def list_extend(context, builder, sig, args):
    ...

intp_max = ...
@overload_method(types.List, "index")
def list_index(lst, value, start=..., stop=...): # -> Callable[..., int]:
    ...

@lower_builtin("list.insert", types.List, types.Integer, types.Any)
def list_insert(context, builder, sig, args):
    ...

@lower_builtin("list.pop", types.List)
def list_pop(context, builder, sig, args):
    ...

@lower_builtin("list.pop", types.List, types.Integer)
def list_pop(context, builder, sig, args):
    ...

@overload_method(types.List, "remove")
def list_remove(lst, value): # -> Callable[..., None]:
    ...

@overload_method(types.List, "reverse")
def list_reverse(lst): # -> Callable[..., None]:
    ...

def gt(a, b):
    ...

sort_forwards = ...
sort_backwards = ...
arg_sort_forwards = ...
arg_sort_backwards = ...
@overload_method(types.List, "sort")
def ol_list_sort(lst, key=..., reverse=...): # -> Callable[..., None]:
    ...

@overload(sorted)
def ol_sorted(iterable, key=..., reverse=...): # -> Callable[..., list[Any]] | Literal[False]:
    ...

@lower_cast(types.List, types.List)
def list_to_list(context, builder, fromty, toty, val):
    ...

_banned_error = ...
@overload_method(types.LiteralList, 'append')
def literal_list_banned_append(lst, obj):
    ...

@overload_method(types.LiteralList, 'extend')
def literal_list_banned_extend(lst, iterable):
    ...

@overload_method(types.LiteralList, 'insert')
def literal_list_banned_insert(lst, index, obj):
    ...

@overload_method(types.LiteralList, 'remove')
def literal_list_banned_remove(lst, value):
    ...

@overload_method(types.LiteralList, 'pop')
def literal_list_banned_pop(lst, index=...):
    ...

@overload_method(types.LiteralList, 'clear')
def literal_list_banned_clear(lst):
    ...

@overload_method(types.LiteralList, 'sort')
def literal_list_banned_sort(lst, key=..., reverse=...):
    ...

@overload_method(types.LiteralList, 'reverse')
def literal_list_banned_reverse(lst):
    ...

_index_end = ...
@overload_method(types.LiteralList, 'index')
def literal_list_index(lst, x, start=..., end=...): # -> None:
    ...

@overload_method(types.LiteralList, 'count')
def literal_list_count(lst, x): # -> Callable[..., int] | None:
    ...

@overload_method(types.LiteralList, 'copy')
def literal_list_count(lst): # -> Callable[..., Any] | None:
    ...

@overload(operator.delitem)
def literal_list_delitem(lst, index): # -> None:
    ...

@overload(operator.setitem)
def literal_list_setitem(lst, index, value): # -> None:
    ...

@overload(operator.getitem)
def literal_list_getitem(lst, *args): # -> None:
    ...

@overload(len)
def literal_list_len(lst): # -> Callable[..., int] | None:
    ...

@overload(operator.contains)
def literal_list_contains(lst, item): # -> Callable[..., bool] | None:
    ...

@lower_cast(types.LiteralList, types.LiteralList)
def literallist_to_literallist(context, builder, fromty, toty, val):
    ...

