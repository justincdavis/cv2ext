"""
This type stub file was generated by pyright.
"""

import operator
import numpy as np
from numba import pndindex
from numba.core import cgutils, extending, types
from numba.np.numpy_support import carray, farray
from numba.core.imputils import RefType, iternext_impl, lower_builtin, lower_cast, lower_constant, lower_getattr, lower_getattr_generic, lower_setattr_generic
from numba.core.types import StringLiteral
from numba.core.extending import intrinsic, overload, overload_attribute, overload_method, register_jitable

"""
Implementation of operations on Array objects and objects supporting
the buffer protocol.
"""
def set_range_metadata(builder, load, lower_bound, upper_bound): # -> None:
    """
    Set the "range" metadata on a load instruction.
    Note the interval is in the form [lower_bound, upper_bound).
    """
    ...

def mark_positive(builder, load): # -> None:
    """
    Mark the result of a load instruction as positive (or zero).
    """
    ...

def make_array(array_type): # -> type[ArrayStruct]:
    """
    Return the Structure representation of the given *array_type*
    (an instance of types.ArrayCompatible).

    Note this does not call __array_wrap__ in case a new array structure
    is being created (rather than populated).
    """
    class ArrayStruct(base):
        ...
    
    

def get_itemsize(context, array_type):
    """
    Return the item size for the given array or buffer type.
    """
    ...

def load_item(context, builder, arrayty, ptr):
    """
    Load the item at the given array pointer.
    """
    ...

def store_item(context, builder, arrayty, val, ptr):
    """
    Store the item at the given array pointer.
    """
    ...

def fix_integer_index(context, builder, idxty, idx, size):
    """
    Fix the integer index' type and value for the given dimension size.
    """
    ...

def normalize_index(context, builder, idxty, idx): # -> tuple[Integer, Any] | tuple[Any | Array, Any]:
    """
    Normalize the index type and value.  0-d arrays are converted to scalars.
    """
    ...

def normalize_indices(context, builder, index_types, indices): # -> tuple[Any, Any]:
    """
    Same as normalize_index(), but operating on sequences of
    index types and values.
    """
    ...

def populate_array(array, data, shape, strides, itemsize, meminfo, parent=...):
    """
    Helper function for populating array structures.
    This avoids forgetting to set fields.

    *shape* and *strides* can be Python tuples or LLVM arrays.
    """
    ...

def update_array_info(aryty, array): # -> None:
    """
    Update some auxiliary information in *array* after some of its fields
    were changed.  `itemsize` and `nitems` are updated.
    """
    ...

def normalize_axis(func_name, arg_name, ndim, axis):
    """Constrain axis values to valid positive values."""
    ...

@overload(normalize_axis)
def normalize_axis_overloads(func_name, arg_name, ndim, axis): # -> Callable[..., Any]:
    ...

@lower_builtin('getiter', types.Buffer)
def getiter_array(context, builder, sig, args):
    ...

@lower_builtin('iternext', types.ArrayIterator)
@iternext_impl(RefType.BORROWED)
def iternext_array(context, builder, sig, args, result): # -> None:
    ...

def basic_indexing(context, builder, aryty, ary, index_types, indices, boundscheck=...): # -> tuple[Any, list[Any], list[Any]]:
    """
    Perform basic indexing on the given array.
    A (data pointer, shapes, strides) tuple is returned describing
    the corresponding view.
    """
    ...

def make_view(context, builder, aryty, ary, return_type, data, shapes, strides): # -> ArrayStruct:
    """
    Build a view over the given array with the given parameters.
    """
    ...

@lower_builtin(operator.getitem, types.Buffer, types.Integer)
@lower_builtin(operator.getitem, types.Buffer, types.SliceType)
def getitem_arraynd_intp(context, builder, sig, args): # -> Any:
    """
    Basic indexing with an integer or a slice.
    """
    ...

@lower_builtin(operator.getitem, types.Buffer, types.BaseTuple)
def getitem_array_tuple(context, builder, sig, args): # -> Any:
    """
    Basic or advanced indexing with a tuple.
    """
    ...

@lower_builtin(operator.setitem, types.Buffer, types.Any, types.Any)
def setitem_array(context, builder, sig, args): # -> None:
    """
    array[a] = scalar_or_array
    array[a,..,b] = scalar_or_array
    """
    ...

@lower_builtin(len, types.Buffer)
def array_len(context, builder, sig, args):
    ...

@lower_builtin("array.item", types.Array)
def array_item(context, builder, sig, args):
    ...

@lower_builtin("array.itemset", types.Array, types.Any)
def array_itemset(context, builder, sig, args):
    ...

class Indexer:
    """
    Generic indexer interface, for generating indices over a fancy indexed
    array on a single dimension.
    """
    def prepare(self):
        """
        Prepare the indexer by initializing any required variables, basic
        blocks...
        """
        ...
    
    def get_size(self):
        """
        Return this dimension's size as an integer.
        """
        ...
    
    def get_shape(self):
        """
        Return this dimension's shape as a tuple.
        """
        ...
    
    def get_index_bounds(self):
        """
        Return a half-open [lower, upper) range of indices this dimension
        is guaranteed not to step out of.
        """
        ...
    
    def loop_head(self):
        """
        Start indexation loop.  Return a (index, count) tuple.
        *index* is an integer LLVM value representing the index over this
        dimension.
        *count* is either an integer LLVM value representing the current
        iteration count, or None if this dimension should be omitted from
        the indexation result.
        """
        ...
    
    def loop_tail(self):
        """
        Finish indexation loop.
        """
        ...
    


class EntireIndexer(Indexer):
    """
    Compute indices along an entire array dimension.
    """
    def __init__(self, context, builder, aryty, ary, dim) -> None:
        ...
    
    def prepare(self): # -> None:
        ...
    
    def get_size(self):
        ...
    
    def get_shape(self): # -> tuple[Any]:
        ...
    
    def get_index_bounds(self): # -> tuple[Any, Any]:
        ...
    
    def loop_head(self): # -> tuple[Any, Any]:
        ...
    
    def loop_tail(self): # -> None:
        ...
    


class IntegerIndexer(Indexer):
    """
    Compute indices from a single integer.
    """
    def __init__(self, context, builder, idx) -> None:
        ...
    
    def prepare(self): # -> None:
        ...
    
    def get_size(self): # -> Constant:
        ...
    
    def get_shape(self): # -> tuple[()]:
        ...
    
    def get_index_bounds(self): # -> tuple[Any, Any]:
        ...
    
    def loop_head(self): # -> tuple[Any, None]:
        ...
    
    def loop_tail(self): # -> None:
        ...
    


class IntegerArrayIndexer(Indexer):
    """
    Compute indices from an array of integer indices.
    """
    def __init__(self, context, builder, idxty, idxary, size) -> None:
        ...
    
    def prepare(self): # -> None:
        ...
    
    def get_size(self):
        ...
    
    def get_shape(self): # -> tuple[Any]:
        ...
    
    def get_index_bounds(self): # -> tuple[Any, Any]:
        ...
    
    def loop_head(self): # -> tuple[Any, Any]:
        ...
    
    def loop_tail(self): # -> None:
        ...
    


class BooleanArrayIndexer(Indexer):
    """
    Compute indices from an array of boolean predicates.
    """
    def __init__(self, context, builder, idxty, idxary) -> None:
        ...
    
    def prepare(self): # -> None:
        ...
    
    def get_size(self):
        ...
    
    def get_shape(self): # -> tuple[Any]:
        ...
    
    def get_index_bounds(self): # -> tuple[Any, Any]:
        ...
    
    def loop_head(self): # -> tuple[Any, Any]:
        ...
    
    def loop_tail(self): # -> None:
        ...
    


class SliceIndexer(Indexer):
    """
    Compute indices along a slice.
    """
    def __init__(self, context, builder, aryty, ary, dim, idxty, slice) -> None:
        ...
    
    def prepare(self): # -> None:
        ...
    
    def get_size(self):
        ...
    
    def get_shape(self): # -> tuple[Any]:
        ...
    
    def get_index_bounds(self): # -> tuple[Any, Any]:
        ...
    
    def loop_head(self): # -> tuple[Any, Any]:
        ...
    
    def loop_tail(self): # -> None:
        ...
    


class FancyIndexer:
    """
    Perform fancy indexing on the given array.
    """
    def __init__(self, context, builder, aryty, ary, index_types, indices) -> None:
        ...
    
    def prepare(self): # -> None:
        ...
    
    def get_shape(self): # -> tuple[()]:
        """
        Get the resulting data shape as Python tuple.
        """
        ...
    
    def get_offset_bounds(self, strides, itemsize): # -> tuple[Any, Any]:
        """
        Get a half-open [lower, upper) range of byte offsets spanned by
        the indexer with the given strides and itemsize.  The indexer is
        guaranteed to not go past those bounds.
        """
        ...
    
    def begin_loops(self): # -> tuple[Any, Any]:
        ...
    
    def end_loops(self): # -> None:
        ...
    


def fancy_getitem(context, builder, sig, args, aryty, ary, index_types, indices): # -> Any:
    ...

@lower_builtin(operator.getitem, types.Buffer, types.Array)
def fancy_getitem_array(context, builder, sig, args): # -> Any:
    """
    Advanced or basic indexing with an array.
    """
    ...

def offset_bounds_from_strides(context, builder, arrty, arr, shapes, strides): # -> tuple[Any, Any]:
    """
    Compute a half-open range [lower, upper) of byte offsets from the
    array's data pointer, that bound the in-memory extent of the array.

    This mimics offset_bounds_from_strides() from
    numpy/core/src/private/mem_overlap.c
    """
    ...

def compute_memory_extents(context, builder, lower, upper, data): # -> tuple[Any, Any]:
    """
    Given [lower, upper) byte offsets and a base data pointer,
    compute the memory pointer bounds as pointer-sized integers.
    """
    ...

def get_array_memory_extents(context, builder, arrty, arr, shapes, strides, data): # -> tuple[Any, Any]:
    """
    Compute a half-open range [start, end) of pointer-sized integers
    which fully contain the array data.
    """
    ...

def extents_may_overlap(context, builder, a_start, a_end, b_start, b_end):
    """
    Whether two memory extents [a_start, a_end) and [b_start, b_end)
    may overlap.
    """
    ...

def maybe_copy_source(context, builder, use_copy, srcty, src, src_shapes, src_strides, src_data): # -> tuple[Callable[..., Any], Callable[[], None]]:
    ...

@intrinsic
def get_readonly_array(typingctx, arr): # -> tuple[Any, Callable[..., Any]]:
    ...

@overload(np.broadcast_to)
def numpy_broadcast_to(array, shape): # -> Callable[..., NDArray[Any]]:
    ...

@register_jitable
def numpy_broadcast_shapes_list(r, m, shape): # -> None:
    ...

@overload(np.broadcast_shapes)
def ol_numpy_broadcast_shapes(*args): # -> Callable[..., tuple[()]] | Callable[..., tuple[Literal[1], ...] | Any]:
    ...

@overload(np.broadcast_arrays)
def numpy_broadcast_arrays(*args): # -> Callable[..., list[Any]]:
    ...

def fancy_setslice(context, builder, sig, args, index_types, indices):
    """
    Implement slice assignment for arrays.  This implementation works for
    basic as well as fancy indexing, since there's no functional difference
    between the two for indexed assignment.
    """
    ...

def vararg_to_tuple(context, builder, sig, args): # -> tuple[Signature, tuple[Any, Constant | Any]]:
    ...

@lower_builtin('array.transpose', types.Array)
def array_transpose(context, builder, sig, args): # -> Any:
    ...

def permute_arrays(axis, shape, strides): # -> None:
    ...

@lower_builtin('array.transpose', types.Array, types.BaseTuple)
def array_transpose_tuple(context, builder, sig, args): # -> Any:
    ...

@lower_builtin('array.transpose', types.Array, types.VarArg(types.Any))
def array_transpose_vararg(context, builder, sig, args): # -> Any:
    ...

@overload(np.transpose)
def numpy_transpose(a, axes=...): # -> Callable[..., Any]:
    ...

@lower_getattr(types.Array, 'T')
def array_T(context, builder, typ, value): # -> Any:
    ...

@overload(np.logspace)
def numpy_logspace(start, stop, num=...): # -> Callable[..., Any]:
    ...

@overload(np.geomspace)
def numpy_geomspace(start, stop, num=...): # -> Callable[..., Any]:
    ...

@overload(np.rot90)
def numpy_rot90(m, k=...): # -> Callable[..., Any | NDArray[Any]]:
    ...

def normalize_reshape_value(origsize, shape): # -> None:
    ...

@lower_builtin('array.reshape', types.Array, types.BaseTuple)
def array_reshape(context, builder, sig, args): # -> Any:
    ...

@lower_builtin('array.reshape', types.Array, types.VarArg(types.Any))
def array_reshape_vararg(context, builder, sig, args): # -> Any:
    ...

@overload(np.reshape)
def np_reshape(a, newshape): # -> Callable[..., Any]:
    ...

@overload(np.resize)
def numpy_resize(a, new_shape): # -> Callable[..., NDArray[Any]]:
    ...

@overload(np.append)
def np_append(arr, values, axis=...): # -> Callable[..., NDArray[Any]]:
    ...

@lower_builtin('array.ravel', types.Array)
def array_ravel(context, builder, sig, args):
    ...

@lower_builtin(np.ravel, types.Array)
def np_ravel(context, builder, sig, args):
    ...

@lower_builtin('array.flatten', types.Array)
def array_flatten(context, builder, sig, args):
    ...

@overload(np.clip)
def np_clip(a, a_min, a_max, out=...): # -> Callable[..., NoReturn]:
    ...

@overload_method(types.Array, 'clip')
def array_clip(a, a_min=..., a_max=..., out=...): # -> Callable[..., Any]:
    ...

@overload(np.shape)
def np_shape(a): # -> Callable[..., _Shape]:
    ...

@overload(np.unique)
def np_unique(ar): # -> Callable[..., NDArray[Any]]:
    ...

@overload(np.repeat)
def np_repeat(a, repeats): # -> Callable[..., NDArray[Any]] | None:
    ...

@register_jitable
def np_repeat_impl_repeats_scaler(a, repeats): # -> NDArray[Any]:
    ...

@extending.overload_method(types.Array, 'repeat')
def array_repeat(a, repeats): # -> Callable[..., NDArray[Any]]:
    ...

@overload(_compatible_view, target='generic')
def ol_compatible_view(a, dtype): # -> Callable[..., None]:
    """Determines if the array and dtype are compatible for forming a view."""
    ...

@lower_builtin('array.view', types.Array, types.DTypeSpec)
def array_view(context, builder, sig, args): # -> Any:
    ...

@lower_getattr(types.Array, "dtype")
def array_dtype(context, builder, typ, value):
    ...

@lower_getattr(types.Array, "shape")
@lower_getattr(types.MemoryView, "shape")
def array_shape(context, builder, typ, value): # -> Any | Constant:
    ...

@lower_getattr(types.Array, "strides")
@lower_getattr(types.MemoryView, "strides")
def array_strides(context, builder, typ, value): # -> Any:
    ...

@lower_getattr(types.Array, "ndim")
@lower_getattr(types.MemoryView, "ndim")
def array_ndim(context, builder, typ, value):
    ...

@lower_getattr(types.Array, "size")
def array_size(context, builder, typ, value): # -> Any:
    ...

@lower_getattr(types.Array, "itemsize")
@lower_getattr(types.MemoryView, "itemsize")
def array_itemsize(context, builder, typ, value): # -> Any:
    ...

@lower_getattr(types.Array, "nbytes")
@lower_getattr(types.MemoryView, "nbytes")
def array_nbytes(context, builder, typ, value):
    """
    nbytes = size * itemsize
    """
    ...

@lower_getattr(types.MemoryView, "contiguous")
def array_contiguous(context, builder, typ, value):
    ...

@lower_getattr(types.MemoryView, "c_contiguous")
def array_c_contiguous(context, builder, typ, value):
    ...

@lower_getattr(types.MemoryView, "f_contiguous")
def array_f_contiguous(context, builder, typ, value):
    ...

@lower_getattr(types.MemoryView, "readonly")
def array_readonly(context, builder, typ, value):
    ...

@lower_getattr(types.Array, "ctypes")
def array_ctypes(context, builder, typ, value):
    ...

@lower_getattr(types.ArrayCTypes, "data")
def array_ctypes_data(context, builder, typ, value):
    ...

@lower_cast(types.ArrayCTypes, types.CPointer)
@lower_cast(types.ArrayCTypes, types.voidptr)
def array_ctypes_to_pointer(context, builder, fromty, toty, val):
    ...

@lower_getattr(types.Array, "flags")
def array_flags(context, builder, typ, value):
    ...

@lower_getattr(types.ArrayFlags, "contiguous")
@lower_getattr(types.ArrayFlags, "c_contiguous")
def array_flags_c_contiguous(context, builder, typ, value):
    ...

@lower_getattr(types.ArrayFlags, "f_contiguous")
def array_flags_f_contiguous(context, builder, typ, value):
    ...

@lower_getattr(types.Array, "real")
def array_real_part(context, builder, typ, value): # -> Any:
    ...

@lower_getattr(types.Array, "imag")
def array_imag_part(context, builder, typ, value): # -> Any:
    ...

def array_complex_attr(context, builder, typ, value, attr): # -> Any:
    """
    Given a complex array, it's memory layout is:

        R C R C R C
        ^   ^   ^

    (`R` indicates a float for the real part;
     `C` indicates a float for the imaginary part;
     the `^` indicates the start of each element)

    To get the real part, we can simply change the dtype and itemsize to that
    of the underlying float type.  The new layout is:

        R x R x R x
        ^   ^   ^

    (`x` indicates unused)

    A load operation will use the dtype to determine the number of bytes to
    load.

    To get the imaginary part, we shift the pointer by 1 float offset and
    change the dtype and itemsize.  The new layout is:

        x C x C x C
          ^   ^   ^
    """
    ...

@overload_method(types.Array, 'conj')
@overload_method(types.Array, 'conjugate')
def array_conj(arr): # -> Callable[..., Any]:
    ...

def dtype_type(context, builder, dtypety, dtypeval):
    ...

@lower_builtin('static_getitem', types.NumberClass, types.Any)
def static_getitem_number_clazz(context, builder, sig, args):
    """This handles the "static_getitem" when a Numba type is subscripted e.g:
    var = typed.List.empty_list(float64[::1, :])
    It only allows this on simple numerical types. Compound types, like
    records, are not supported.
    """
    ...

@lower_getattr_generic(types.Array)
def array_record_getattr(context, builder, typ, value, attr): # -> Any:
    """
    Generic getattr() implementation for record arrays: fetch the given
    record member, i.e. a subarray.
    """
    ...

@lower_builtin('static_getitem', types.Array, types.StringLiteral)
def array_record_getitem(context, builder, sig, args): # -> Any:
    ...

@lower_getattr_generic(types.Record)
def record_getattr(context, builder, typ, value, attr): # -> Any:
    """
    Generic getattr() implementation for records: get the given record member.
    """
    ...

@lower_setattr_generic(types.Record)
def record_setattr(context, builder, sig, args, attr): # -> None:
    """
    Generic setattr() implementation for records: set the given record member.
    """
    ...

@lower_builtin('static_getitem', types.Record, types.StringLiteral)
def record_static_getitem_str(context, builder, sig, args):
    """
    Record.__getitem__ redirects to getattr()
    """
    ...

@lower_builtin('static_getitem', types.Record, types.IntegerLiteral)
def record_static_getitem_int(context, builder, sig, args):
    """
    Record.__getitem__ redirects to getattr()
    """
    ...

@lower_builtin('static_setitem', types.Record, types.StringLiteral, types.Any)
def record_static_setitem_str(context, builder, sig, args):
    """
    Record.__setitem__ redirects to setattr()
    """
    ...

@lower_builtin('static_setitem', types.Record, types.IntegerLiteral, types.Any)
def record_static_setitem_int(context, builder, sig, args):
    """
    Record.__setitem__ redirects to setattr()
    """
    ...

@lower_constant(types.Array)
def constant_array(context, builder, ty, pyval):
    """
    Create a constant array (mechanism is target-dependent).
    """
    ...

@lower_constant(types.Record)
def constant_record(context, builder, ty, pyval):
    """
    Create a record constant as a stack-allocated array of bytes.
    """
    ...

@lower_constant(types.Bytes)
def constant_bytes(context, builder, ty, pyval):
    """
    Create a constant array from bytes (mechanism is target-dependent).
    """
    ...

@lower_builtin(operator.is_, types.Array, types.Array)
def array_is(context, builder, sig, args): # -> Constant:
    ...

@overload_attribute(types.Array, "__hash__")
def ol_array_hash(arr): # -> Callable[..., None]:
    ...

def make_array_flat_cls(flatiterty): # -> type[CContiguousFlatIter] | type[FlatIter]:
    """
    Return the Structure representation of the given *flatiterty* (an
    instance of types.NumpyFlatType).
    """
    ...

def make_array_ndenumerate_cls(nditerty): # -> type[CContiguousFlatIter] | type[FlatIter]:
    """
    Return the Structure representation of the given *nditerty* (an
    instance of types.NumpyNdEnumerateType).
    """
    ...

def make_nditer_cls(nditerty): # -> type[NdIter]:
    """
    Return the Structure representation of the given *nditerty* (an
    instance of types.NumpyNdIterType).
    """
    class BaseSubIter:
        """
        Base class for sub-iterators of a nditer() instance.
        """
        ...
    
    
    class FlatSubIter(BaseSubIter):
        """
        Sub-iterator walking a contiguous array in physical order, with
        support for broadcasting (the index is reset on the outer dimension).
        """
        ...
    
    
    class TrivialFlatSubIter(BaseSubIter):
        """
        Sub-iterator walking a contiguous array in physical order,
        *without* support for broadcasting.
        """
        ...
    
    
    class IndexedSubIter(BaseSubIter):
        """
        Sub-iterator walking an array in logical order.
        """
        ...
    
    
    class ZeroDimSubIter(BaseSubIter):
        """
        Sub-iterator "walking" a 0-d array.
        """
        ...
    
    
    class ScalarSubIter(BaseSubIter):
        """
        Sub-iterator "walking" a scalar value.
        """
        ...
    
    
    class NdIter(cgutils.create_struct_proxy(nditerty)):
        """
        .nditer() implementation.

        Note: 'F' layout means the shape is iterated in reverse logical order,
        so indices and shapes arrays have to be reversed as well.
        """
        ...
    
    

def make_ndindex_cls(nditerty): # -> type[NdIndexIter]:
    """
    Return the Structure representation of the given *nditerty* (an
    instance of types.NumpyNdIndexType).
    """
    class NdIndexIter(cgutils.create_struct_proxy(nditerty)):
        """
        .ndindex() implementation.
        """
        ...
    
    

@lower_getattr(types.Array, "flat")
def make_array_flatiter(context, builder, arrty, arr): # -> Any:
    ...

@lower_builtin('iternext', types.NumpyFlatType)
@iternext_impl(RefType.BORROWED)
def iternext_numpy_flatiter(context, builder, sig, args, result): # -> None:
    ...

@lower_builtin(operator.getitem, types.NumpyFlatType, types.Integer)
def iternext_numpy_getitem(context, builder, sig, args):
    ...

@lower_builtin(operator.setitem, types.NumpyFlatType, types.Integer, types.Any)
def iternext_numpy_getitem_any(context, builder, sig, args):
    ...

@lower_builtin(len, types.NumpyFlatType)
def iternext_numpy_getitem_flat(context, builder, sig, args):
    ...

@lower_builtin(np.ndenumerate, types.Array)
def make_array_ndenumerate(context, builder, sig, args): # -> Any:
    ...

@lower_builtin('iternext', types.NumpyNdEnumerateType)
@iternext_impl(RefType.BORROWED)
def iternext_numpy_nditer(context, builder, sig, args, result): # -> None:
    ...

@lower_builtin(pndindex, types.VarArg(types.Integer))
@lower_builtin(np.ndindex, types.VarArg(types.Integer))
def make_array_ndindex(context, builder, sig, args): # -> Any:
    """ndindex(*shape)"""
    ...

@lower_builtin(pndindex, types.BaseTuple)
@lower_builtin(np.ndindex, types.BaseTuple)
def make_array_ndindex_tuple(context, builder, sig, args): # -> Any:
    """ndindex(shape)"""
    ...

@lower_builtin('iternext', types.NumpyNdIndexType)
@iternext_impl(RefType.BORROWED)
def iternext_numpy_ndindex(context, builder, sig, args, result): # -> None:
    ...

@lower_builtin(np.nditer, types.Any)
def make_array_nditer(context, builder, sig, args): # -> Any:
    """
    nditer(...)
    """
    ...

@lower_builtin('iternext', types.NumpyNdIterType)
@iternext_impl(RefType.BORROWED)
def iternext_numpy_nditer2(context, builder, sig, args, result): # -> None:
    ...

@lower_builtin(operator.eq, types.DType, types.DType)
def dtype_eq_impl(context, builder, sig, args): # -> Constant:
    ...

@intrinsic
def intrin_alloc(typingctx, allocsize, align): # -> tuple[Signature, Callable[..., Any]]:
    """Intrinsic to call into the allocator for Array
    """
    ...

@intrinsic
def numpy_empty_nd(tyctx, ty_shape, ty_dtype, ty_retty_ref): # -> tuple[Any, Callable[..., Any]]:
    ...

@overload(np.empty)
def ol_np_empty(shape, dtype=...): # -> Callable[..., Any]:
    ...

@intrinsic
def numpy_empty_like_nd(tyctx, ty_prototype, ty_dtype, ty_retty_ref): # -> tuple[Any, Callable[..., Any]]:
    ...

@overload(np.empty_like)
def ol_np_empty_like(arr, dtype=...): # -> Callable[..., Any]:
    ...

@overload_method(types.Array, '_zero_fill')
def ol_array_zero_fill(self): # -> Callable[..., None]:
    """Adds a `._zero_fill` method to zero fill an array using memset."""
    ...

@overload(np.zeros)
def ol_np_zeros(shape, dtype=...): # -> Callable[..., NDArray[Any]]:
    ...

@overload(np.zeros_like)
def ol_np_zeros_like(a, dtype=...): # -> Callable[..., Any]:
    ...

@overload(np.ones_like)
def ol_np_ones_like(a, dtype=...): # -> Callable[..., Any]:
    ...

@overload(np.full)
def impl_np_full(shape, fill_value, dtype=...): # -> Callable[..., Any]:
    ...

@overload(np.full_like)
def impl_np_full_like(a, fill_value, dtype=...): # -> Callable[..., Any]:
    ...

@overload(np.ones)
def ol_np_ones(shape, dtype=...): # -> Callable[..., NDArray[float64]]:
    ...

@overload(np.identity)
def impl_np_identity(n, dtype=...): # -> Callable[..., Any]:
    ...

@extending.overload(np.eye)
def numpy_eye(N, M=..., k=..., dtype=...): # -> Callable[..., Any]:
    ...

@overload(np.diag)
def impl_np_diag(v, k=...): # -> Callable[..., NDArray[float64]] | None:
    ...

@overload(np.indices)
def numpy_indices(dimensions): # -> Callable[..., NDArray[Any]]:
    ...

@overload(np.diagflat)
def numpy_diagflat(v, k=...): # -> Callable[..., NDArray[Any]]:
    ...

@overload(np.take)
@overload_method(types.Array, 'take')
def numpy_take(a, indices): # -> Callable[..., Any] | None:
    ...

@overload(np.arange)
def np_arange(start, stop=..., step=..., dtype=...): # -> Callable[..., Any] | None:
    ...

@overload(np.linspace)
def numpy_linspace(start, stop, num=...): # -> Callable[..., Any] | None:
    ...

@lower_builtin("array.copy", types.Array)
def array_copy(context, builder, sig, args): # -> Any:
    ...

@overload(np.copy)
def impl_numpy_copy(a): # -> Callable[..., Any]:
    ...

@overload(np.ascontiguousarray)
def array_ascontiguousarray(a): # -> Callable[..., NDArray[Any]]:
    ...

@overload(np.asfortranarray)
def array_asfortranarray(a): # -> Callable[..., NDArray[Any]] | None:
    ...

@lower_builtin("array.astype", types.Array, types.DTypeSpec)
@lower_builtin("array.astype", types.Array, types.StringLiteral)
def array_astype(context, builder, sig, args): # -> Any:
    ...

@intrinsic
def np_frombuffer(typingctx, buffer, dtype, retty): # -> tuple[Any, Callable[..., Any]]:
    ...

@overload(np.frombuffer)
def impl_np_frombuffer(buffer, dtype=...): # -> Callable[..., Any]:
    ...

@overload(carray)
def impl_carray(ptr, shape, dtype=...): # -> Callable[..., Any] | None:
    ...

@overload(farray)
def impl_farray(ptr, shape, dtype=...): # -> Callable[..., Any] | None:
    ...

def get_cfarray_intrinsic(layout, dtype_): # -> Callable[..., tuple[Signature, Callable[..., Any]]]:
    ...

def np_cfarray(context, builder, sig, args): # -> Any:
    """
    numba.numpy_support.carray(...) and
    numba.numpy_support.farray(...).
    """
    ...

def compute_sequence_shape(context, builder, ndim, seqty, seq): # -> tuple[Any, ...]:
    """
    Compute the likely shape of a nested sequence (possibly 0d).
    """
    ...

def check_sequence_shape(context, builder, seqty, seq, shapes): # -> None:
    """
    Check the nested sequence matches the given *shapes*.
    """
    ...

def assign_sequence_to_array(context, builder, data, shapes, strides, arrty, seqty, seq): # -> None:
    """
    Assign a nested sequence contents to an array.  The shape must match
    the sequence's structure.
    """
    ...

def np_array_typer(typingctx, object, dtype): # -> Array | None:
    ...

@intrinsic
def np_array(typingctx, obj, dtype): # -> tuple[Any | Signature, Callable[..., Any]]:
    ...

@overload(np.array)
def impl_np_array(object, dtype=...): # -> Callable[..., Any]:
    ...

def expand_dims(context, builder, sig, args, axis): # -> Any:
    """
    np.expand_dims() with the given axis.
    """
    ...

@intrinsic
def np_expand_dims(typingctx, a, axis): # -> tuple[Any, Callable[..., Any]]:
    ...

@overload(np.expand_dims)
def impl_np_expand_dims(a, axis): # -> Callable[..., Any]:
    ...

@overload(np.atleast_1d)
def np_atleast_1d(*args): # -> Callable[..., tuple[Signature, Callable[..., Any]]] | None:
    ...

@overload(np.atleast_2d)
def np_atleast_2d(*args): # -> Callable[..., tuple[Signature, Callable[..., Any]]] | None:
    ...

@overload(np.atleast_3d)
def np_atleast_3d(*args): # -> Callable[..., tuple[Signature, Callable[..., Any]]] | None:
    ...

def np_concatenate_typer(typingctx, arrays, axis): # -> Array | None:
    ...

@intrinsic
def np_concatenate(typingctx, arrays, axis): # -> tuple[Any | Signature, Callable[..., Any]]:
    ...

@overload(np.concatenate)
def impl_np_concatenate(arrays, axis=...): # -> Callable[..., Any] | None:
    ...

@intrinsic
def np_column_stack(typingctx, tup): # -> tuple[Any | Signature, Callable[..., Any]]:
    ...

@overload(np.column_stack)
def impl_column_stack(tup): # -> Callable[..., Any] | None:
    ...

@intrinsic
def np_stack_common(typingctx, arrays, axis): # -> tuple[Any | Signature, Callable[..., Any]]:
    ...

@overload(np.stack)
def impl_np_stack(arrays, axis=...): # -> Callable[..., Any] | None:
    ...

def NdStack_typer(typingctx, func_name, arrays, ndim_min): # -> Array:
    ...

@overload(np.hstack)
def impl_np_hstack(tup): # -> Callable[..., Any] | None:
    ...

@overload(np.vstack)
def impl_np_vstack(tup): # -> Callable[..., Any] | None:
    ...

@overload(np.dstack)
def impl_np_dstack(tup): # -> Callable[..., Any] | None:
    ...

@extending.overload_method(types.Array, 'fill')
def arr_fill(arr, val): # -> Callable[..., None]:
    ...

@extending.overload_method(types.Array, 'dot')
def array_dot(arr, other): # -> Callable[..., Any]:
    ...

@overload(np.fliplr)
def np_flip_lr(m): # -> Callable[..., ndarray[Any, dtype[Any]]]:
    ...

@overload(np.flipud)
def np_flip_ud(m): # -> Callable[..., ndarray[Any, dtype[Any]]]:
    ...

@overload(np.flip)
def np_flip(m): # -> Callable[..., Any]:
    ...

@overload(np.array_split)
def np_array_split(ary, indices_or_sections, axis=...): # -> Callable[..., list[NDArray[Any]]] | None:
    ...

@overload(np.split)
def np_split(ary, indices_or_sections, axis=...): # -> Callable[..., list[NDArray[Any]]] | None:
    ...

@overload(np.vsplit)
def numpy_vsplit(ary, indices_or_sections): # -> Callable[..., list[NDArray[Any]]]:
    ...

@overload(np.hsplit)
def numpy_hsplit(ary, indices_or_sections): # -> Callable[..., list[NDArray[Any]]]:
    ...

@overload(np.dsplit)
def numpy_dsplit(ary, indices_or_sections): # -> Callable[..., list[NDArray[Any]]]:
    ...

_sorts = ...
def default_lt(a, b):
    """
    Trivial comparison function between two keys.
    """
    ...

def get_sort_func(kind, lt_impl, is_argsort=...):
    """
    Get a sort implementation of the given kind.
    """
    ...

def lt_implementation(dtype): # -> Callable[..., Any | bool] | Callable[..., Any]:
    ...

@lower_builtin("array.sort", types.Array)
def array_sort(context, builder, sig, args):
    ...

@overload(np.sort)
def impl_np_sort(a): # -> Callable[..., Any]:
    ...

@lower_builtin("array.argsort", types.Array, types.StringLiteral)
@lower_builtin(np.argsort, types.Array, types.StringLiteral)
def array_argsort(context, builder, sig, args):
    ...

@lower_cast(types.Array, types.Array)
def array_to_array(context, builder, fromty, toty, val):
    ...

@lower_cast(types.Array, types.UnicodeCharSeq)
@lower_cast(types.Array, types.Float)
@lower_cast(types.Array, types.Integer)
@lower_cast(types.Array, types.Complex)
@lower_cast(types.Array, types.Boolean)
@lower_cast(types.Array, types.NPTimedelta)
@lower_cast(types.Array, types.NPDatetime)
def array0d_to_scalar(context, builder, fromty, toty, val):
    ...

@lower_cast(types.Array, types.UnicodeCharSeq)
def array_to_unichrseq(context, builder, fromty, toty, val):
    ...

def reshape_unchecked(a, shape, strides):
    """
    An intrinsic returning a derived array with the given shape and strides.
    """
    ...

@extending.type_callable(reshape_unchecked)
def type_reshape_unchecked(context): # -> Callable[..., Array | None]:
    ...

@lower_builtin(reshape_unchecked, types.Array, types.BaseTuple, types.BaseTuple)
def impl_shape_unchecked(context, builder, sig, args): # -> Any:
    ...

@extending.overload(np.lib.stride_tricks.as_strided)
def as_strided(x, shape=..., strides=...): # -> Callable[..., NoReturn]:
    ...

@extending.overload(np.lib.stride_tricks.sliding_window_view)
def sliding_window_view(x, window_shape, axis=...): # -> Callable[..., NoReturn]:
    ...

@overload(bool)
def ol_bool(arr): # -> Callable[..., bool] | None:
    ...

@overload(np.swapaxes)
def numpy_swapaxes(a, axis1, axis2): # -> Callable[..., NDArray[Any]]:
    ...

@overload(np.take_along_axis)
def arr_take_along_axis(arr, indices, axis): # -> Callable[..., NDArray[Any]]:
    ...

@overload(np.nan_to_num)
def nan_to_num_impl(x, copy=..., nan=...): # -> Callable[..., Any]:
    ...

