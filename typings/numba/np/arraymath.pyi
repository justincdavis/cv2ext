"""
This type stub file was generated by pyright.
"""

import operator
import numpy as np
from numba.core import types
from numba.core.extending import overload, overload_method, register_jitable
from numba.core.imputils import lower_builtin

"""
Implementation of math operations on Array objects.
"""
_HAVE_BLAS = ...
@lower_builtin(np.sum, types.Array)
@lower_builtin("array.sum", types.Array)
def array_sum(context, builder, sig, args):
    ...

def gen_sum_axis_impl(is_axis_const, const_axis_val, op, zero): # -> Callable[..., Any]:
    ...

@lower_builtin(np.sum, types.Array, types.intp, types.DTypeSpec)
@lower_builtin(np.sum, types.Array, types.IntegerLiteral, types.DTypeSpec)
@lower_builtin("array.sum", types.Array, types.intp, types.DTypeSpec)
@lower_builtin("array.sum", types.Array, types.IntegerLiteral, types.DTypeSpec)
def array_sum_axis_dtype(context, builder, sig, args):
    ...

@lower_builtin(np.sum, types.Array, types.DTypeSpec)
@lower_builtin("array.sum", types.Array, types.DTypeSpec)
def array_sum_dtype(context, builder, sig, args):
    ...

@lower_builtin(np.sum, types.Array, types.intp)
@lower_builtin(np.sum, types.Array, types.IntegerLiteral)
@lower_builtin("array.sum", types.Array, types.intp)
@lower_builtin("array.sum", types.Array, types.IntegerLiteral)
def array_sum_axis(context, builder, sig, args):
    ...

def get_accumulator(dtype, value): # -> int64:
    ...

@overload(np.prod)
@overload_method(types.Array, "prod")
def array_prod(a): # -> Callable[..., Any | bool_ | int64 | void | object_] | None:
    ...

@overload(np.cumsum)
@overload_method(types.Array, "cumsum")
def array_cumsum(a): # -> Callable[..., NDArray[bool_ | object_ | void]] | None:
    ...

@overload(np.cumprod)
@overload_method(types.Array, "cumprod")
def array_cumprod(a): # -> Callable[..., NDArray[bool_ | object_ | void]] | None:
    ...

@overload(np.mean)
@overload_method(types.Array, "mean")
def array_mean(a): # -> Callable[..., Any] | None:
    ...

@overload(np.var)
@overload_method(types.Array, "var")
def array_var(a): # -> Callable[..., Any] | None:
    ...

@overload(np.std)
@overload_method(types.Array, "std")
def array_std(a): # -> Callable[..., Any] | None:
    ...

@register_jitable
def min_comparator(a, min_val):
    ...

@register_jitable
def max_comparator(a, min_val):
    ...

@register_jitable
def return_false(a): # -> Literal[False]:
    ...

@overload(np.min)
@overload(np.amin)
@overload_method(types.Array, "min")
def npy_min(a): # -> Callable[..., Any] | None:
    ...

@overload(np.max)
@overload(np.amax)
@overload_method(types.Array, "max")
def npy_max(a): # -> Callable[..., Any] | None:
    ...

@register_jitable
def array_argmin_impl_datetime(arry): # -> int:
    ...

@register_jitable
def array_argmin_impl_float(arry): # -> int:
    ...

@register_jitable
def array_argmin_impl_generic(arry): # -> int:
    ...

@overload(np.argmin)
@overload_method(types.Array, "argmin")
def array_argmin(a, axis=...): # -> Callable[..., int] | Callable[..., Any]:
    ...

@register_jitable
def array_argmax_impl_datetime(arry): # -> int:
    ...

@register_jitable
def array_argmax_impl_float(arry): # -> int:
    ...

@register_jitable
def array_argmax_impl_generic(arry): # -> int:
    ...

def build_argmax_or_argmin_with_axis_impl(a, axis, flatten_impl): # -> Callable[..., Any]:
    """
    Given a function that implements the logic for handling a flattened
    array, return the implementation function.
    """
    ...

@overload(np.argmax)
@overload_method(types.Array, "argmax")
def array_argmax(a, axis=...): # -> Callable[..., int] | Callable[..., Any]:
    ...

@overload(np.all)
@overload_method(types.Array, "all")
def np_all(a): # -> Callable[..., bool]:
    ...

@overload(np.allclose)
@overload_method(types.Array, "allclose")
def np_allclose(a, b, rtol=..., atol=..., equal_nan=...): # -> Callable[..., Any | bool] | None:
    ...

@overload(np.any)
@overload_method(types.Array, "any")
def np_any(a): # -> Callable[..., bool]:
    ...

@overload(np.average)
def np_average(a, axis=..., weights=...): # -> Callable[..., floating[Any]]:
    ...

def get_isnan(dtype): # -> _UFunc_Nin1_Nout1[Literal['isnan'], Literal[20], None] | Callable[..., Literal[False]]:
    """
    A generic isnan() function
    """
    ...

@overload(np.iscomplex)
def np_iscomplex(x): # -> Callable[..., Any] | None:
    ...

@overload(np.isreal)
def np_isreal(x): # -> Callable[..., Any] | None:
    ...

@overload(np.iscomplexobj)
def iscomplexobj(x): # -> Callable[..., bool]:
    ...

@overload(np.isrealobj)
def isrealobj(x): # -> Callable[..., bool]:
    ...

@overload(np.isscalar)
def np_isscalar(element): # -> Callable[..., bool]:
    ...

def is_np_inf_impl(x, out, fn): # -> Callable[..., Any]:
    ...

@overload(np.isneginf)
def isneginf(x, out=...): # -> Callable[..., Any]:
    ...

@overload(np.isposinf)
def isposinf(x, out=...): # -> Callable[..., Any]:
    ...

@register_jitable
def less_than(a, b):
    ...

@register_jitable
def greater_than(a, b):
    ...

@register_jitable
def check_array(a): # -> None:
    ...

def nan_min_max_factory(comparison_op, is_complex_dtype): # -> Callable[..., Any]:
    ...

real_nanmin = ...
real_nanmax = ...
complex_nanmin = ...
complex_nanmax = ...
@overload(np.isclose)
def isclose(a, b, rtol=..., atol=..., equal_nan=...): # -> Callable[..., ndarray[Any, dtype[Any]]]:
    ...

@overload(np.nanmin)
def np_nanmin(a): # -> Callable[..., Any]:
    ...

@overload(np.nanmax)
def np_nanmax(a): # -> Callable[..., Any]:
    ...

@overload(np.nanmean)
def np_nanmean(a): # -> Callable[..., Any] | None:
    ...

@overload(np.nanvar)
def np_nanvar(a): # -> Callable[..., Any] | None:
    ...

@overload(np.nanstd)
def np_nanstd(a): # -> Callable[..., floating[Any]] | None:
    ...

@overload(np.nansum)
def np_nansum(a): # -> Callable[..., Any | Signature] | None:
    ...

@overload(np.nanprod)
def np_nanprod(a): # -> Callable[..., Any | Signature] | None:
    ...

@overload(np.nancumprod)
def np_nancumprod(a): # -> Callable[..., Any] | Callable[..., NDArray[float64]] | None:
    ...

@overload(np.nancumsum)
def np_nancumsum(a): # -> Callable[..., Any] | Callable[..., NDArray[float64]] | None:
    ...

@register_jitable
def prepare_ptp_input(a): # -> None:
    ...

@overload_method(types.Array, 'ptp')
@overload(np.ptp)
def np_ptp(a): # -> Callable[..., Any]:
    ...

@register_jitable
def nan_aware_less_than(a, b): # -> bool:
    ...

_partition = ...
_partition_w_nan = ...
_argpartition_w_nan = ...
_select = ...
_select_w_nan = ...
_arg_select_w_nan = ...
@overload(np.median)
def np_median(a): # -> Callable[..., Any] | None:
    ...

@register_jitable
def check_valid(q, q_upper_bound): # -> bool:
    ...

@register_jitable
def percentile_is_valid(q): # -> None:
    ...

@register_jitable
def quantile_is_valid(q): # -> None:
    ...

@overload(np.percentile)
def np_percentile(a, q): # -> Callable[..., Any]:
    ...

@overload(np.nanpercentile)
def np_nanpercentile(a, q): # -> Callable[..., Any]:
    ...

@overload(np.quantile)
def np_quantile(a, q): # -> Callable[..., Any]:
    ...

@overload(np.nanquantile)
def np_nanquantile(a, q): # -> Callable[..., Any]:
    ...

@overload(np.nanmedian)
def np_nanmedian(a): # -> Callable[..., float | Any] | None:
    ...

@register_jitable
def np_partition_impl_inner(a, kth_array):
    ...

@register_jitable
def np_argpartition_impl_inner(a, kth_array): # -> NDArray[Any]:
    ...

@register_jitable
def valid_kths(a, kth):
    """
    Returns a sorted, unique array of kth values which serve
    as indexers for partitioning the input array, a.

    If the absolute value of any of the provided values
    is greater than a.shape[-1] an exception is raised since
    we are partitioning along the last axis (per Numpy default
    behaviour).

    Values less than 0 are transformed to equivalent positive
    index values.
    """
    ...

@overload(np.partition)
def np_partition(a, kth): # -> Callable[..., Any]:
    ...

@overload(np.argpartition)
def np_argpartition(a, kth): # -> Callable[..., Any | NDArray[Any]]:
    ...

@overload(np.tri)
def np_tri(N, M=..., k=...): # -> Callable[..., NDArray[Any]]:
    ...

@register_jitable
def np_tril_impl_2d(m, k=...): # -> NDArray[Any]:
    ...

@overload(np.tril)
def my_tril(m, k=...): # -> Callable[..., NDArray[Any]]:
    ...

@overload(np.tril_indices)
def np_tril_indices(n, k=..., m=...): # -> Callable[..., tuple[NDArray[intp], ...]]:
    ...

@overload(np.tril_indices_from)
def np_tril_indices_from(arr, k=...): # -> Callable[..., tuple[NDArray[int_], NDArray[int_]]]:
    ...

@register_jitable
def np_triu_impl_2d(m, k=...): # -> NDArray[Any]:
    ...

@overload(np.triu)
def my_triu(m, k=...): # -> Callable[..., NDArray[Any]]:
    ...

@overload(np.triu_indices)
def np_triu_indices(n, k=..., m=...): # -> Callable[..., tuple[NDArray[intp], ...]]:
    ...

@overload(np.triu_indices_from)
def np_triu_indices_from(arr, k=...): # -> Callable[..., tuple[NDArray[int_], NDArray[int_]]]:
    ...

@overload(np.ediff1d)
def np_ediff1d(ary, to_end=..., to_begin=...): # -> Callable[..., NDArray[float64]]:
    ...

@overload(_get_d)
def get_d_impl(x, dx): # -> Callable[..., NDArray[Any]]:
    ...

@overload(np.trapz)
def np_trapz(y, x=..., dx=...): # -> Callable[..., None]:
    ...

@overload(np.vander)
def np_vander(x, N=..., increasing=...): # -> Callable[..., NDArray[Any]] | None:
    ...

@overload(np.roll)
def np_roll(a, shift): # -> Callable[..., NDArray[Any]]:
    ...

LIKELY_IN_CACHE_SIZE = ...
@register_jitable
def binary_search_with_guess(key, arr, length, guess): # -> int:
    ...

@register_jitable
def np_interp_impl_complex_inner(x, xp, fp, dtype): # -> NDArray[Any] | NDArray[float64]:
    ...

@register_jitable
def np_interp_impl_inner(x, xp, fp, dtype): # -> NDArray[Any] | NDArray[float64]:
    ...

@overload(np.interp)
def np_interp(x, xp, fp): # -> Callable[..., Any | float64]:
    ...

@register_jitable
def row_wise_average(a): # -> NDArray[float64]:
    ...

@register_jitable
def np_cov_impl_inner(X, bias, ddof): # -> Any:
    ...

_handle_m_dim_nop = ...
def determine_dtype(array_like): # -> dtype[Any] | dtype[bool_] | dtype[void] | dtype[object_] | float64:
    ...

def check_dimensions(array_like, name): # -> None:
    ...

_handle_ddof_nop = ...
def scalar_result_expected(mandatory_input, optional_input): # -> bool:
    ...

@overload(np.cov)
def np_cov(m, y=..., rowvar=..., bias=..., ddof=...): # -> Callable[..., NDArray[Any]]:
    ...

@overload(np.corrcoef)
def np_corrcoef(x, y=..., rowvar=...): # -> Callable[..., Any]:
    ...

@overload(np.argwhere)
def np_argwhere(a): # -> Callable[..., Any | NDArray[intp]]:
    ...

@overload(np.flatnonzero)
def np_flatnonzero(a): # -> Callable[..., NDArray[intp]]:
    ...

_check_nop = ...
@overload(np.fill_diagonal)
def np_fill_diagonal(a, val, wrap=...): # -> Callable[..., None] | None:
    ...

@register_jitable
def round_ndigits(x, ndigits):
    ...

@overload(np.around)
@overload(np.round)
@overload(np.round_)
def impl_np_round(a, decimals=..., out=...): # -> Callable[..., Any] | None:
    ...

@overload(np.sinc)
def impl_np_sinc(x): # -> Callable[..., Any]:
    ...

@overload(np.angle)
def ov_np_angle(z, deg=...): # -> Callable[..., Any] | None:
    ...

@lower_builtin(np.nonzero, types.Array)
@lower_builtin("array.nonzero", types.Array)
def array_nonzero(context, builder, sig, args):
    ...

@overload(np.where)
def ov_np_where(condition): # -> Callable[..., tuple[ndarray[Any, _dtype], ...]]:
    ...

@overload(np.where)
def ov_np_where_x_y(condition, x, y): # -> Callable[..., NDArray[Any]]:
    ...

@overload(np.real)
def np_real(val): # -> Callable[..., Any]:
    ...

@overload(np.imag)
def np_imag(val): # -> Callable[..., Any]:
    ...

@overload(operator.contains)
def np_contains(arr, key): # -> Callable[..., bool] | None:
    ...

@overload(np.count_nonzero)
def np_count_nonzero(a, axis=...): # -> Callable[..., Any]:
    ...

np_delete_handler_isslice = ...
np_delete_handler_isarray = ...
@overload(np.delete)
def np_delete(arr, obj): # -> Callable[..., ndarray[Any, dtype[Any]]]:
    ...

@overload(np.diff)
def np_diff_impl(a, n=...): # -> Callable[..., Any | NDArray[float64]] | None:
    ...

@overload(np.array_equal)
def np_array_equal(a1, a2): # -> Callable[..., Any]:
    ...

@overload(np.intersect1d)
def jit_np_intersect1d(ar1, ar2): # -> Callable[..., ndarray[Any, dtype[Any]]]:
    ...

def validate_1d_array_like(func_name, seq): # -> None:
    ...

@overload(np.bincount)
def np_bincount(a, weights=..., minlength=...): # -> Callable[..., Any] | None:
    ...

less_than_float = ...
less_than_complex = ...
@register_jitable
def less_than_or_equal_complex(a, b): # -> Any | bool:
    ...

VALID_SEARCHSORTED_SIDES = ...
def make_searchsorted_implementation(np_dtype, side): # -> Callable[..., Any]:
    ...

@overload(np.searchsorted)
def searchsorted(a, v, side=...): # -> Callable[..., Any]:
    ...

@overload(np.digitize)
def np_digitize(x, bins, right=...): # -> Callable[..., Any]:
    ...

_range = range
@overload(np.histogram)
def np_histogram(a, bins=..., range=...): # -> Callable[..., tuple[NDArray[Any], NDArray[Any]]]:
    ...

_mach_ar_supported = ...
MachAr = ...
_finfo_supported = ...
finfo = ...
_iinfo_supported = ...
iinfo = ...
def generate_xinfo_body(arg, np_func, container, attr): # -> Callable[..., Any] | None:
    ...

@overload(np.finfo)
def ol_np_finfo(dtype): # -> Callable[..., Any]:
    ...

@overload(np.iinfo)
def ol_np_iinfo(int_type): # -> Callable[..., Any]:
    ...

@overload(np.convolve)
def np_convolve(a, v, mode=...): # -> Callable[..., None]:
    ...

@overload(np.asarray)
def np_asarray(a, dtype=...): # -> Callable[..., Any] | Callable[..., NDArray[Any]] | None:
    ...

@overload(np.asfarray)
def np_asfarray(a, dtype=...): # -> Callable[..., Any]:
    ...

@overload(np.extract)
def np_extract(condition, arr): # -> Callable[..., NDArray[Any]]:
    ...

@overload(np.select)
def np_select(condlist, choicelist, default=...): # -> Callable[..., NDArray[floating[Any]] | NDArray[Any]]:
    ...

@overload(np.union1d)
def np_union1d(ar1, ar2): # -> Callable[..., NDArray[Any]]:
    ...

@overload(np.asarray_chkfinite)
def np_asarray_chkfinite(a, dtype=...): # -> Callable[..., Any]:
    ...

@overload(np.unwrap)
def numpy_unwrap(p, discont=..., axis=..., period=...): # -> Callable[..., ndarray[Any, dtype[Any]]]:
    ...

@register_jitable
def np_bartlett_impl(M): # -> NDArray[Any]:
    ...

@register_jitable
def np_blackman_impl(M): # -> Any:
    ...

@register_jitable
def np_hamming_impl(M): # -> Any:
    ...

@register_jitable
def np_hanning_impl(M): # -> Any:
    ...

def window_generator(func): # -> Callable[..., Callable[..., NDArray[Any] | Any]]:
    ...

_i0A = np.array([-4.4153416464793395e-18, 3.3307945188222384e-17, -2.431279846547955e-16, 1.715391285555133e-15, -1.1685332877993451e-14, 7.676185498604936e-14, -4.856446783111929e-13, 2.95505266312964e-12, -1.726826291441556e-11, 9.675809035373237e-11, -5.189795601635263e-10, 2.6598237246823866e-9, -1.300025009986248e-8, 6.046995022541919e-8, -2.670793853940612e-7, 0.0000011173875391201037, -0.0000044167383584587505, 0.000016448448070728896, -0.00005754195010082104, 0.00018850288509584165, -0.0005763755745385824, 0.0016394756169413357, -0.004324309995050576, 0.010546460394594998, -0.02373741480589947, 0.04930528423967071, -0.09490109704804764, 0.17162090152220877, -0.3046826723431984, 0.6767952744094761])
_i0B = np.array([-7.233180487874754e-18, -4.830504485944182e-18, 4.46562142029676e-17, 3.461222867697461e-17, -2.8276239805165836e-16, -3.425485619677219e-16, 1.7725601330565263e-15, 3.8116806693526224e-15, -9.554846698828307e-15, -4.150569347287222e-14, 1.54008621752141e-14, 3.8527783827421426e-13, 7.180124451383666e-13, -1.7941785315068062e-12, -1.3215811840447713e-11, -3.1499165279632416e-11, 1.1889147107846439e-11, 4.94060238822497e-10, 3.3962320257083865e-9, 2.266668990498178e-8, 2.0489185894690638e-7, 0.0000028913705208347567, 0.00006889758346916825, 0.0033691164782556943, 0.8044904110141088])
@overload(np.kaiser)
def np_kaiser(M, beta): # -> Callable[..., NDArray[Any]]:
    ...

@overload(np.cross)
def np_cross(a, b): # -> Callable[..., None]:
    ...

def cross2d(a, b): # -> None:
    ...

@overload(cross2d)
def cross2d_impl(a, b): # -> Callable[..., NDArray[Any]]:
    ...

@overload(np.trim_zeros)
def np_trim_zeros(filt, trim=...): # -> Callable[..., ndarray[Any, dtype[Any]]]:
    ...

