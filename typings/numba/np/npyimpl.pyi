"""
This type stub file was generated by pyright.
"""

import numpy as np
import operator
from collections import namedtuple
from numba.core import types
from numba.core.extending import overload

"""
Implementation of functions in the Numpy package.
"""
registry = ...
class _ScalarIndexingHelper:
    def update_indices(self, loop_indices, name): # -> None:
        ...
    
    def as_values(self): # -> None:
        ...
    


class _ScalarHelper:
    """Helper class to handle scalar arguments (and result).
    Note that store_data is only used when generating code for
    a scalar ufunc and to write the output value.

    For loading, the value is directly used without having any
    kind of indexing nor memory backing it up. This is the use
    for input arguments.

    For storing, a variable is created in the stack where the
    value will be written.

    Note that it is not supported (as it is unneeded for our
    current use-cases) reading back a stored value. This class
    will always "load" the original value it got at its creation.
    """
    def __init__(self, ctxt, bld, val, ty) -> None:
        ...
    
    def create_iter_indices(self): # -> _ScalarIndexingHelper:
        ...
    
    def load_data(self, indices): # -> Any:
        ...
    
    def store_data(self, indices, val): # -> None:
        ...
    
    @property
    def return_val(self):
        ...
    


class _ArrayIndexingHelper(namedtuple('_ArrayIndexingHelper', ('array', 'indices'))):
    def update_indices(self, loop_indices, name): # -> None:
        ...
    
    def as_values(self): # -> list[Any]:
        """
        The indexing helper is built using alloca for each value, so it
        actually contains pointers to the actual indices to load. Note
        that update_indices assumes the same. This method returns the
        indices as values
        """
        ...
    


class _ArrayHelper(namedtuple('_ArrayHelper', ('context', 'builder', 'shape', 'strides', 'data', 'layout', 'base_type', 'ndim', 'return_val'))):
    """Helper class to handle array arguments/result.
    It provides methods to generate code loading/storing specific
    items as well as support code for handling indices.
    """
    def create_iter_indices(self): # -> _ArrayIndexingHelper:
        ...
    
    def load_data(self, indices):
        ...
    
    def store_data(self, indices, value): # -> None:
        ...
    


_broadcast_onto_sig = ...
def numpy_ufunc_kernel(context, builder, sig, args, ufunc, kernel_class):
    ...

class _Kernel:
    def __init__(self, context, builder, outer_sig) -> None:
        ...
    
    def cast(self, val, fromty, toty):
        """Numpy uses cast semantics that are different from standard Python
        (for example, it does allow casting from complex to float).

        This method acts as a patch to context.cast so that it allows
        complex to real/int casts.

        """
        ...
    


def register_ufunc_kernel(ufunc, kernel, lower):
    ...

def register_unary_operator_kernel(operator, ufunc, kernel, lower, inplace=...): # -> None:
    ...

def register_binary_operator_kernel(op, ufunc, kernel, lower, inplace=...): # -> None:
    ...

@registry.lower(operator.pos, types.Array)
def array_positive_impl(context, builder, sig, args):
    '''Lowering function for +(array) expressions.  Defined here
    (numba.targets.npyimpl) since the remaining array-operator
    lowering functions are also registered in this module.
    '''
    class _UnaryPositiveKernel(_Kernel):
        ...
    
    

def register_ufuncs(ufuncs, lower): # -> None:
    ...

@overload(np.dtype)
def numpy_dtype(desc): # -> Callable[..., Any]:
    """Provide an implementation so that numpy.dtype function can be lowered.
    """
    ...

