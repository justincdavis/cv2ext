"""
This type stub file was generated by pyright.
"""

from numba.core.extending import intrinsic

UNKNOWN_CLASS = ...
CONST_CLASS = ...
MAP_TYPES = ...
array_analysis_extensions = ...
array_creation = ...
random_int_args = ...
random_1arg_size = ...
random_2arg_sizelast = ...
random_3arg_sizelast = ...
random_calls = ...
@intrinsic
def wrap_index(typingctx, idx, size): # -> tuple[Signature, Callable[..., Any]]:
    """
    Calculate index value "idx" relative to a size "size" value as
    (idx % size), where "size" is known to be positive.
    Note that we use the mod(%) operation here instead of
    (idx < 0 ? idx + size : idx) because we may have situations
    where idx > size due to the way indices are calculated
    during slice/range analysis.

    Both idx and size have to be Integer types.
    size should be from the array size vars that array_analysis
    adds and the bitwidth should match the platform maximum.
    """
    ...

def wrap_index_literal(idx, size): # -> Literal[0]:
    ...

@intrinsic
def assert_equiv(typingctx, *val): # -> tuple[Signature, Callable[..., Any]]:
    """
    A function that asserts the inputs are of equivalent size,
    and throws runtime error when they are not. The input is
    a vararg that contains an error message, followed by a set
    of objects of either array, tuple or integer.
    """
    ...

class EquivSet:
    """EquivSet keeps track of equivalence relations between
    a set of objects.
    """
    def __init__(self, obj_to_ind=..., ind_to_obj=..., next_ind=...) -> None:
        """Create a new EquivSet object. Optional keyword arguments are for
        internal use only.
        """
        ...
    
    def empty(self): # -> EquivSet:
        """Return an empty EquivSet object.
        """
        ...
    
    def clone(self): # -> EquivSet:
        """Return a new copy.
        """
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def is_empty(self): # -> bool:
        """Return true if the set is empty, or false otherwise.
        """
        ...
    
    def is_equiv(self, *objs): # -> bool:
        """Try to derive if given objects are equivalent, return true
        if so, or false otherwise.
        """
        ...
    
    def get_equiv_const(self, obj): # -> int | None:
        """Check if obj is equivalent to some int constant, and return
        the constant if found, or None otherwise.
        """
        ...
    
    def get_equiv_set(self, obj): # -> set[Any]:
        """Return the set of equivalent objects.
        """
        ...
    
    def insert_equiv(self, *objs): # -> None:
        """Insert a set of equivalent objects by modifying self. This
        method can be overloaded to transform object type before insertion.
        """
        ...
    
    def intersect(self, equiv_set): # -> EquivSet:
        """ Return the intersection of self and the given equiv_set,
        without modifying either of them. The result will also keep
        old equivalence indices unchanged.
        """
        ...
    


class ShapeEquivSet(EquivSet):
    """Just like EquivSet, except that it accepts only numba IR variables
    and constants as objects, guided by their types. Arrays are considered
    equivalent as long as their shapes are equivalent. Scalars are
    equivalent only when they are equal in value. Tuples are equivalent
    when they are of the same size, and their elements are equivalent.
    """
    def __init__(self, typemap, defs=..., ind_to_var=..., obj_to_ind=..., ind_to_obj=..., next_id=..., ind_to_const=...) -> None:
        """Create a new ShapeEquivSet object, where typemap is a dictionary
        that maps variable names to their types, and it will not be modified.
        Optional keyword arguments are for internal use only.
        """
        ...
    
    def empty(self): # -> ShapeEquivSet:
        """Return an empty ShapeEquivSet.
        """
        ...
    
    def clone(self): # -> ShapeEquivSet:
        """Return a new copy.
        """
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def is_equiv(self, *objs): # -> bool:
        """Overload EquivSet.is_equiv to handle Numba IR variables and
        constants.
        """
        ...
    
    def get_equiv_const(self, obj): # -> int | None:
        """If the given object is equivalent to a constant scalar,
        return the scalar value, or None otherwise.
        """
        ...
    
    def get_equiv_var(self, obj): # -> None:
        """If the given object is equivalent to some defined variable,
        return the variable, or None otherwise.
        """
        ...
    
    def get_equiv_set(self, obj): # -> set[Any] | None:
        """Return the set of equivalent objects.
        """
        ...
    
    def insert_equiv(self, *objs): # -> Literal[False] | None:
        """Overload EquivSet.insert_equiv to handle Numba IR variables and
        constants. Input objs are either variable or constant, and at least
        one of them must be variable.
        """
        ...
    
    def has_shape(self, name): # -> bool:
        """Return true if the shape of the given variable is available.
        """
        ...
    
    def get_shape(self, name): # -> tuple[Any, ...] | None:
        """Return a tuple of variables that corresponds to the shape
        of the given array, or None if not found.
        """
        ...
    
    def get_shape_classes(self, name): # -> list[Any] | tuple[Any, ...]:
        """Instead of the shape tuple, return tuple of int, where
        each int is the corresponding class index of the size object.
        Unknown shapes are given class index -1. Return empty tuple
        if the input name is a scalar variable.
        """
        ...
    
    def intersect(self, equiv_set): # -> EquivSet:
        """Overload the intersect method to handle ind_to_var.
        """
        ...
    
    def define(self, name, redefined): # -> None:
        """Increment the internal count of how many times a variable is being
        defined. Most variables in Numba IR are SSA, i.e., defined only once,
        but not all of them. When a variable is being re-defined, it must
        be removed from the equivalence relation and added to the redefined
        set but only if that redefinition is not known to have the same
        equivalence classes. Those variables redefined are removed from all
        the blocks' equivalence sets later.

        Arrays passed to define() use their whole name but these do not
        appear in the equivalence sets since they are stored there per
        dimension. Calling _get_names() here converts array names to
        dimensional names.

        This function would previously invalidate if there were any multiple
        definitions of a variable.  However, we realized that this behavior
        is overly restrictive.  You need only invalidate on multiple
        definitions if they are not known to be equivalent. So, the
        equivalence insertion functions now return True if some change was
        made (meaning the definition was not equivalent) and False
        otherwise. If no change was made, then define() need not be
        called. For no change to have been made, the variable must
        already be present. If the new definition of the var has the
        case where lhs and rhs are in the same equivalence class then
        again, no change will be made and define() need not be called
        or the variable invalidated.
        """
        ...
    
    def union_defs(self, defs, redefined): # -> None:
        """Union with the given defs dictionary. This is meant to handle
        branch join-point, where a variable may have been defined in more
        than one branches.
        """
        ...
    


class SymbolicEquivSet(ShapeEquivSet):
    """Just like ShapeEquivSet, except that it also reasons about variable
    equivalence symbolically by using their arithmetic definitions.
    The goal is to automatically derive the equivalence of array ranges
    (slicing). For instance, a[1:m] and a[0:m-1] shall be considered
    size-equivalence.
    """
    def __init__(self, typemap, def_by=..., ref_by=..., ext_shapes=..., defs=..., ind_to_var=..., obj_to_ind=..., ind_to_obj=..., next_id=...) -> None:
        """Create a new SymbolicEquivSet object, where typemap is a dictionary
        that maps variable names to their types, and it will not be modified.
        Optional keyword arguments are for internal use only.
        """
        ...
    
    def empty(self): # -> SymbolicEquivSet:
        """Return an empty SymbolicEquivSet.
        """
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def clone(self): # -> SymbolicEquivSet:
        """Return a new copy.
        """
        ...
    
    def get_rel(self, name): # -> None:
        """Retrieve a definition pair for the given variable,
        or return None if it is not available.
        """
        ...
    
    def define(self, var, redefined, func_ir=..., typ=...): # -> Literal[True] | None:
        """Besides incrementing the definition count of the given variable
        name, it will also retrieve and simplify its definition from func_ir,
        and remember the result for later equivalence comparison. Supported
        operations are:
          1. arithmetic plus and minus with constants
          2. wrap_index (relative to some given size)
        """
        ...
    
    def set_shape_setitem(self, obj, shape): # -> None:
        """remember shapes of SetItem IR nodes.
        """
        ...
    


class WrapIndexMeta:
    """
      Array analysis should be able to analyze all the function
      calls that it adds to the IR.  That way, array analysis can
      be run as often as needed and you should get the same
      equivalencies.  One modification to the IR that array analysis
      makes is the insertion of wrap_index calls.  Thus, repeated
      array analysis passes should be able to analyze these wrap_index
      calls.  The difficulty of these calls is that the equivalence
      class of the left-hand side of the assignment is not present in
      the arguments to wrap_index in the right-hand side.  Instead,
      the equivalence class of the wrap_index output is a combination
      of the wrap_index args.  The important thing to
      note is that if the equivalence classes of the slice size
      and the dimension's size are the same for two wrap index
      calls then we can be assured of the answer being the same.
      So, we maintain the wrap_map dict that maps from a tuple
      of equivalence class ids for the slice and dimension size
      to some new equivalence class id for the output size.
      However, when we are analyzing the first such wrap_index
      call we don't have a variable there to associate to the
      size since we're in the process of analyzing the instruction
      that creates that mapping.  So, instead we return an object
      of this special class and analyze_inst will establish the
      connection between a tuple of the parts of this object
      below and the left-hand side variable.
    """
    def __init__(self, slice_size, dim_size) -> None:
        ...
    


class ArrayAnalysis:
    aa_count = ...
    def __init__(self, context, func_ir, typemap, calltypes) -> None:
        ...
    
    def get_equiv_set(self, block_label):
        """Return the equiv_set object of an block given its label.
        """
        ...
    
    def remove_redefineds(self, redefineds): # -> None:
        """Take a set of variables in redefineds and go through all
        the currently existing equivalence sets (created in topo order)
        and remove that variable from all of them since it is multiply
        defined within the function.
        """
        ...
    
    def run(self, blocks=..., equiv_set=...): # -> None:
        """run array shape analysis on the given IR blocks, resulting in
        modified IR and finalized EquivSet for each block.
        """
        ...
    
    def dump(self): # -> None:
        """dump per-block equivalence sets for debugging purposes.
        """
        ...
    
    class AnalyzeResult:
        def __init__(self, **kwargs) -> None:
            ...
        
    
    
    def gen_literal_slice_part(self, arg_val, loc, scope, stmts, equiv_set, name=...): # -> tuple[Var, IntegerLiteral]:
        ...
    
    def gen_static_slice_size(self, lhs_rel, rhs_rel, loc, scope, stmts, equiv_set): # -> Var:
        ...
    
    def gen_explicit_neg(self, arg, arg_rel, arg_typ, size_typ, loc, scope, dsize, stmts, equiv_set): # -> tuple[Var, Integer]:
        ...
    
    def update_replacement_slice(self, lhs, lhs_typ, lhs_rel, dsize_rel, replacement_slice, slice_index, need_replacement, loc, scope, stmts, equiv_set, size_typ, dsize): # -> tuple[Any | Var, Any | IntegerLiteral | Integer, Any | int, Any, Any | Literal[True], bool]:
        ...
    
    def slice_size(self, index, dsize, equiv_set, scope, stmts):
        """Reason about the size of a slice represented by the "index"
        variable, and return a variable that has this size data, or
        raise GuardException if it cannot reason about it.

        The computation takes care of negative values used in the slice
        with respect to the given dimensional size ("dsize").

        Extra statements required to produce the result are appended
        to parent function's stmts list.
        """
        ...
    


UNARY_MAP_OP = ...
BINARY_MAP_OP = ...
INPLACE_BINARY_MAP_OP = ...
UFUNC_MAP_OP = ...
