"""
This type stub file was generated by pyright.
"""

import operator
from enum import IntEnum
from numba.core.extending import lower_builtin, lower_cast, models, overload, overload_attribute, overload_method, register_model
from numba.core.imputils import RefType, iternext_impl
from numba.core import types
from numba.core.types import DictItemsIterableType, DictIteratorType, DictKeysIterableType, DictType, DictValuesIterableType

"""
Compiler-side implementation of the dictionary.
"""
ll_dict_type = ...
ll_dictiter_type = ...
ll_voidptr_type = ...
ll_status = ...
ll_ssize_t = ...
ll_hash = ...
ll_bytes = ...
_meminfo_dictptr = ...
class DKIX(IntEnum):
    """Special return value of dict lookup.
    """
    EMPTY = ...


class Status(IntEnum):
    """Status code for other dict operations.
    """
    OK = ...
    OK_REPLACED = ...
    ERR_NO_MEMORY = ...
    ERR_DICT_MUTATED = ...
    ERR_ITER_EXHAUSTED = ...
    ERR_DICT_EMPTY = ...
    ERR_CMP_FAILED = ...


def new_dict(key, value, n_keys=...): # -> dict[Any, Any]:
    """Construct a new dict with enough space for *n_keys* without a resize.

    Parameters
    ----------
    key, value : TypeRef
        Key type and value type of the new dict.
    n_keys : int, default 0
        The number of keys to insert without needing a resize.
        A value of 0 creates a dict with minimum size.
    """
    ...

@register_model(DictType)
class DictModel(models.StructModel):
    def __init__(self, dmm, fe_type) -> None:
        ...
    


@register_model(DictItemsIterableType)
@register_model(DictKeysIterableType)
@register_model(DictValuesIterableType)
@register_model(DictIteratorType)
class DictIterModel(models.StructModel):
    def __init__(self, dmm, fe_type) -> None:
        ...
    


@overload(new_dict)
def impl_new_dict(key, value, n_keys=...): # -> Callable[..., Any]:
    """Creates a new dictionary with *key* and *value* as the type
    of the dictionary key and value, respectively. *n_keys* is the
    number of keys to insert without requiring a resize, where a
    value of 0 creates a dictionary with minimum size.
    """
    ...

@overload(len)
def impl_len(d): # -> Callable[..., Any] | None:
    """len(dict)
    """
    ...

@overload(len)
def impl_len_iters(d): # -> Callable[..., Any] | None:
    """len(dict.keys()), len(dict.values()), len(dict.items())
    """
    ...

@overload_method(types.DictType, '__setitem__')
@overload(operator.setitem)
def impl_setitem(d, key, value): # -> Callable[..., None] | tuple[Signature, Callable[..., None]] | None:
    ...

@overload_method(types.DictType, 'get')
def impl_get(dct, key, default=...): # -> Callable[..., Any | None] | None:
    ...

@overload_attribute(types.DictType, '__hash__')
def impl_hash(dct): # -> Callable[..., None] | None:
    ...

@overload(operator.getitem)
def impl_getitem(d, key): # -> Callable[..., Any] | None:
    ...

@overload_method(types.DictType, 'popitem')
def impl_popitem(d): # -> Callable[..., Any] | None:
    ...

@overload_method(types.DictType, 'pop')
def impl_pop(dct, key, default=...): # -> Callable[..., Any | None] | None:
    ...

@overload(operator.delitem)
def impl_delitem(d, k): # -> Callable[..., None] | None:
    ...

@overload(operator.contains)
def impl_contains(d, k): # -> Callable[..., Any] | None:
    ...

@overload_method(types.DictType, 'clear')
def impl_clear(d): # -> Callable[..., None] | None:
    ...

@overload_method(types.DictType, 'copy')
def impl_copy(d): # -> Callable[..., dict[Any, Any]] | None:
    ...

@overload_method(types.DictType, 'setdefault')
def impl_setdefault(dct, key, default=...): # -> Callable[..., Any] | None:
    ...

@overload_method(types.DictType, 'items')
def impl_items(d): # -> Callable[..., Any] | None:
    ...

@overload_method(types.DictType, 'keys')
def impl_keys(d): # -> Callable[..., Any] | None:
    ...

@overload_method(types.DictType, 'values')
def impl_values(d): # -> Callable[..., Any] | None:
    ...

@overload_method(types.DictType, 'update')
def ol_dict_update(d, other): # -> Callable[..., None] | None:
    ...

@overload(operator.eq)
def impl_equal(da, db): # -> Callable[..., Literal[False]] | None:
    ...

@overload(operator.ne)
def impl_not_equal(da, db): # -> Callable[..., bool] | None:
    ...

@lower_builtin('getiter', types.DictItemsIterableType)
@lower_builtin('getiter', types.DictKeysIterableType)
@lower_builtin('getiter', types.DictValuesIterableType)
def impl_iterable_getiter(context, builder, sig, args):
    """Implement iter() for .keys(), .values(), .items()
    """
    ...

@lower_builtin('getiter', types.DictType)
def impl_dict_getiter(context, builder, sig, args):
    """Implement iter(Dict).  Semantically equivalent to dict.keys()
    """
    ...

@lower_builtin('iternext', types.DictIteratorType)
@iternext_impl(RefType.BORROWED)
def impl_iterator_iternext(context, builder, sig, args, result): # -> None:
    ...

def build_map(context, builder, dict_type, item_types, items):
    ...

@overload_method(types.LiteralStrKeyDict, 'values')
def literalstrkeydict_impl_values(d): # -> Callable[..., Any] | None:
    ...

@overload_method(types.LiteralStrKeyDict, 'keys')
def literalstrkeydict_impl_keys(d): # -> Callable[..., dict_keys[Any, Any]] | None:
    ...

@lower_builtin(operator.eq, types.LiteralStrKeyDict, types.LiteralStrKeyDict)
def literalstrkeydict_impl_equals(context, builder, sig, args):
    ...

@overload(operator.getitem)
@overload_method(types.LiteralStrKeyDict, 'get')
def literalstrkeydict_impl_get(dct, *args): # -> None:
    ...

@overload_method(types.LiteralStrKeyDict, 'copy')
def literalstrkeydict_impl_copy(d): # -> Callable[..., Any] | None:
    ...

@overload_method(types.LiteralStrKeyDict, 'items')
def literalstrkeydict_impl_items(d): # -> Callable[..., Any] | None:
    ...

@overload(operator.contains)
def literalstrkeydict_impl_contains(d, k): # -> Callable[..., bool] | None:
    ...

@overload(len)
def literalstrkeydict_impl_len(d): # -> Callable[..., int] | None:
    ...

@overload(operator.setitem)
def literalstrkeydict_banned_impl_setitem(d, key, value): # -> None:
    ...

@overload(operator.delitem)
def literalstrkeydict_banned_impl_delitem(d, k): # -> None:
    ...

@overload_method(types.LiteralStrKeyDict, 'popitem')
@overload_method(types.LiteralStrKeyDict, 'pop')
@overload_method(types.LiteralStrKeyDict, 'clear')
@overload_method(types.LiteralStrKeyDict, 'setdefault')
@overload_method(types.LiteralStrKeyDict, 'update')
def literalstrkeydict_banned_impl_mutators(d, *args): # -> None:
    ...

@lower_cast(types.LiteralStrKeyDict, types.LiteralStrKeyDict)
def cast_LiteralStrKeyDict_LiteralStrKeyDict(context, builder, fromty, toty, val):
    ...

@lower_cast(types.DictType, types.DictType)
def cast_DictType_DictType(context, builder, fromty, toty, val):
    ...

