"""
This type stub file was generated by pyright.
"""

import operator
from enum import IntEnum
from numba.core.extending import intrinsic, lower_builtin, models, overload, overload_attribute, overload_method, register_jitable, register_model
from numba.core.imputils import RefType, iternext_impl
from numba.core import types
from numba.core.types import ListType, ListTypeIterableType, ListTypeIteratorType

"""
Compiler-side implementation of the Numba  typed-list.
"""
ll_list_type = ...
ll_listiter_type = ...
ll_voidptr_type = ...
ll_status = ...
ll_ssize_t = ...
ll_bytes = ...
_meminfo_listptr = ...
INDEXTY = ...
index_types = ...
DEFAULT_ALLOCATED = ...
@register_model(ListType)
class ListModel(models.StructModel):
    def __init__(self, dmm, fe_type) -> None:
        ...
    


@register_model(ListTypeIterableType)
@register_model(ListTypeIteratorType)
class ListIterModel(models.StructModel):
    def __init__(self, dmm, fe_type) -> None:
        ...
    


class ListStatus(IntEnum):
    """Status code for other list operations.
    """
    LIST_OK = ...
    LIST_ERR_INDEX = ...
    LIST_ERR_NO_MEMORY = ...
    LIST_ERR_MUTATED = ...
    LIST_ERR_ITER_EXHAUSTED = ...
    LIST_ERR_IMMUTABLE = ...


class ErrorHandler:
    """ErrorHandler for calling codegen functions from this file.

    Stores the state needed to raise an exception from nopython mode.
    """
    def __init__(self, context) -> None:
        ...
    
    def __call__(self, builder, status, msg): # -> None:
        ...
    


@lower_builtin(operator.is_, types.ListType, types.ListType)
def list_is(context, builder, sig, args):
    ...

def new_list(item, allocated=...): # -> list[Any]:
    """Construct a new list. (Not implemented in the interpreter yet)

    Parameters
    ----------
    item: TypeRef
        Item type of the new list.
    allocated: int
        number of items to pre-allocate

    """
    ...

@overload(new_list)
def impl_new_list(item, allocated=...): # -> Callable[..., Any]:
    """Creates a new list.

    Parameters
    ----------
    item: Numba type
        type of the list item.
    allocated: int
        number of items to pre-allocate

    """
    ...

@overload(len)
def impl_len(l): # -> Callable[..., Any] | None:
    """len(list)
    """
    ...

@overload_method(types.ListType, "_allocated")
def impl_allocated(l): # -> Callable[..., Any] | None:
    """list._allocated()
    """
    ...

@overload_method(types.ListType, "_is_mutable")
def impl_is_mutable(l): # -> Callable[..., bool] | None:
    """list._is_mutable()"""
    ...

@overload_method(types.ListType, "_make_mutable")
def impl_make_mutable(l): # -> Callable[..., None] | None:
    """list._make_mutable()"""
    ...

@overload_method(types.ListType, "_make_immutable")
def impl_make_immutable(l): # -> Callable[..., None] | None:
    """list._make_immutable()"""
    ...

@overload_method(types.ListType, 'append')
def impl_append(l, item): # -> Callable[..., None] | tuple[Signature, Callable[..., None]] | None:
    ...

@intrinsic
def fix_index(tyctx, list_ty, index_ty): # -> tuple[Any | Signature, Callable[..., Any]]:
    ...

@register_jitable
def handle_index(l, index):
    """Handle index.

    If the index is negative, convert it. If the index is out of range, raise
    an IndexError.
    """
    ...

@register_jitable
def handle_slice(l, s): # -> range:
    """Handle slice.

    Convert a slice object for a given list into a range object that can be
    used to index the list. Many subtle caveats here, especially if the step is
    negative.
    """
    ...

_list_getitem = ...
_list_getitem_borrowed = ...
@overload(operator.getitem)
def impl_getitem(l, index): # -> Callable[..., Any] | None:
    ...

@overload(operator.setitem)
def impl_setitem(l, index, item): # -> Callable[..., None] | None:
    ...

@overload_method(types.ListType, 'pop')
def impl_pop(l, index=...): # -> Callable[..., Any] | None:
    ...

@overload(operator.delitem)
def impl_delitem(l, index): # -> Callable[..., None] | None:
    ...

@overload(operator.contains)
def impl_contains(l, item): # -> Callable[..., bool] | None:
    ...

@overload_method(types.ListType, 'count')
def impl_count(l, item): # -> Callable[..., int] | None:
    ...

@overload_method(types.ListType, 'extend')
def impl_extend(l, iterable): # -> Callable[..., None] | tuple[Signature, Callable[..., None]] | None:
    ...

@overload_method(types.ListType, 'insert')
def impl_insert(l, index, item): # -> Callable[..., None] | tuple[Signature, Callable[..., None]] | None:
    ...

@overload_method(types.ListType, 'remove')
def impl_remove(l, item): # -> Callable[..., None] | None:
    ...

@overload_method(types.ListType, 'clear')
def impl_clear(l): # -> Callable[..., None] | None:
    ...

@overload_method(types.ListType, 'reverse')
def impl_reverse(l): # -> Callable[..., None] | None:
    ...

@overload_method(types.ListType, 'copy')
def impl_copy(l): # -> Callable[..., list[Any]] | None:
    ...

@overload_method(types.ListType, 'index')
def impl_index(l, item, start=..., end=...): # -> Callable[..., int] | None:
    ...

@overload_method(types.ListType, "sort")
def ol_list_sort(lst, key=..., reverse=...): # -> Callable[..., None]:
    ...

@overload_method(types.ListType, "getitem_unchecked")
def ol_getitem_unchecked(lst, index): # -> Callable[..., Any] | None:
    ...

@overload_attribute(types.ListType, '__hash__')
def ol_list_hash(lst): # -> Callable[..., None] | None:
    ...

@overload_attribute(types.ListType, '_dtype')
def impl_dtype(l): # -> Callable[..., Any] | None:
    ...

@overload(operator.eq)
def impl_equals(this, other): # -> Callable[..., Literal[False]] | Callable[..., Any] | None:
    ...

@overload(operator.ne)
def impl_not_equals(this, other): # -> Callable[..., Literal[False]] | Callable[..., Any] | None:
    ...

@register_jitable
def compare_not_none(this, other): # -> Literal[-1, 1, 0]:
    """Oldschool (python 2.x) cmp.

       if this < other return -1
       if this = other return 0
       if this > other return 1
    """
    ...

@register_jitable
def compare_some_none(this, other, this_is_none, other_is_none): # -> Literal[-1, 1, 0]:
    """Oldschool (python 2.x) cmp for None typed lists.

       if this < other return -1
       if this = other return 0
       if this > other return 1
    """
    ...

def compare_helper(this, other, accepted): # -> Callable[..., Literal[False]] | Callable[..., bool] | None:
    ...

@overload(operator.lt)
def impl_less_than(this, other): # -> Callable[..., Literal[False]] | Callable[..., bool] | None:
    ...

@overload(operator.le)
def impl_less_than_or_equal(this, other): # -> Callable[..., Literal[False]] | Callable[..., bool] | None:
    ...

@overload(operator.gt)
def impl_greater_than(this, other): # -> Callable[..., Literal[False]] | Callable[..., bool] | None:
    ...

@overload(operator.ge)
def impl_greater_than_or_equal(this, other): # -> Callable[..., Literal[False]] | Callable[..., bool] | None:
    ...

class ListIterInstance:
    def __init__(self, context, builder, iter_type, iter_val) -> None:
        ...
    
    @classmethod
    def from_list(cls, context, builder, iter_type, list_val): # -> Self:
        ...
    
    @property
    def size(self):
        ...
    
    @property
    def value(self):
        ...
    
    def getitem(self, index):
        ...
    
    @property
    def index(self):
        ...
    
    @index.setter
    def index(self, value): # -> None:
        ...
    


@lower_builtin('getiter', types.ListType)
def getiter_list(context, builder, sig, args):
    ...

@lower_builtin('iternext', types.ListTypeIteratorType)
@iternext_impl(RefType.BORROWED)
def iternext_listiter(context, builder, sig, args, result): # -> None:
    ...

