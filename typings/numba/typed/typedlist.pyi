"""
This type stub file was generated by pyright.
"""

import typing as pt
from collections.abc import MutableSequence
from numba.core.types import ListType
from numba.core.imputils import numba_typeref_ctor
from numba.core import types
from numba.core.extending import box, overload, overload_classmethod, type_callable, unbox

"""
Python wrapper that connects CPython interpreter to the Numba typed-list.

This is the code that is used when creating typed lists outside of a `@jit`
context and when returning a typed-list from a `@jit` decorated function. It
basically a Python class that has a Numba allocated typed-list under the hood
and uses `@jit` functions to access it. Since it inherits from MutableSequence
it should really quack like the CPython `list`.

"""
Int_or_Slice = pt.Union["pt.SupportsIndex", slice]
T_co = pt.TypeVar('T_co', covariant=True)
class _Sequence(pt.Protocol[T_co]):
    def __getitem__(self, i: int) -> T_co:
        ...
    
    def __len__(self) -> int:
        ...
    


DEFAULT_ALLOCATED = ...
T = pt.TypeVar('T')
T_or_ListT = pt.Union[T, 'List[T]']
class List(MutableSequence, pt.Generic[T]):
    """A typed-list usable in Numba compiled functions.

    Implements the MutableSequence interface.
    """
    _legal_kwargs = ...
    def __new__(cls, *args, lsttype=..., meminfo=..., allocated=..., **kwargs): # -> list[Any] | Self:
        ...
    
    @classmethod
    def empty_list(cls, item_type, allocated=...): # -> list[Any] | Self:
        """Create a new empty List.

        Parameters
        ----------
        item_type: Numba type
            type of the list item.
        allocated: int
            number of items to pre-allocate
        """
        ...
    
    def __init__(self, *args, **kwargs) -> None:
        """
        For users, the constructor does not take any parameters.
        The keyword arguments are for internal use only.

        Parameters
        ----------
        args: iterable
            The iterable to initialize the list from
        lsttype : numba.core.types.ListType; keyword-only
            Used internally for the list type.
        meminfo : MemInfo; keyword-only
            Used internally to pass the MemInfo object when boxing.
        allocated: int; keyword-only
            Used internally to pre-allocate space for items
        """
        ...
    
    def __len__(self) -> int:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    def __lt__(self, other) -> bool:
        ...
    
    def __le__(self, other) -> bool:
        ...
    
    def __gt__(self, other) -> bool:
        ...
    
    def __ge__(self, other) -> bool:
        ...
    
    def append(self, item: T) -> None:
        ...
    
    @pt.overload
    def __setitem__(self, i: int, o: T) -> None:
        ...
    
    @pt.overload
    def __setitem__(self, s: slice, o: List[T]) -> None:
        ...
    
    def __setitem__(self, i: Int_or_Slice, item: T_or_ListT) -> None:
        ...
    
    @pt.overload
    def __getitem__(self, i: int) -> T:
        ...
    
    @pt.overload
    def __getitem__(self, i: slice) -> List[T]:
        ...
    
    def __getitem__(self, i: Int_or_Slice) -> T_or_ListT:
        ...
    
    def __iter__(self) -> pt.Iterator[T]:
        ...
    
    def __contains__(self, item: T) -> bool:
        ...
    
    def __delitem__(self, i: Int_or_Slice) -> None:
        ...
    
    def insert(self, i: int, item: T) -> None:
        ...
    
    def count(self, item: T) -> int:
        ...
    
    def pop(self, i: pt.SupportsIndex = ...) -> T:
        ...
    
    def extend(self, iterable: _Sequence[T]) -> None:
        ...
    
    def remove(self, item: T) -> None:
        ...
    
    def clear(self): # -> None:
        ...
    
    def reverse(self): # -> None:
        ...
    
    def copy(self):
        ...
    
    def index(self, item: T, start: pt.Optional[int] = ..., stop: pt.Optional[int] = ...) -> int:
        ...
    
    def sort(self, key=..., reverse=...):
        """Sort the list inplace.

        See also ``list.sort()``
        """
        ...
    
    def __str__(self) -> str:
        ...
    
    def __repr__(self): # -> str:
        ...
    


@overload_classmethod(ListType, 'empty_list')
def typedlist_empty(cls, item_type, allocated=...): # -> Callable[..., list[Any]] | None:
    ...

@box(types.ListType)
def box_lsttype(typ, val, c):
    ...

@unbox(types.ListType)
def unbox_listtype(typ, val, c): # -> NativeValue:
    ...

@type_callable(ListType)
def typedlist_call(context): # -> Typer:
    """Defines typing logic for ``List()`` and ``List(iterable)``.

    If no argument is given, the returned typer types a new typed-list with an
    undefined item type. If a single argument is given it must be iterable with
    a guessable 'dtype'. In this case, the typer types a new typed-list with
    the type set to the 'dtype' of the iterable arg.

    Parameters
    ----------
    arg : single iterable (optional)
        The single optional argument.

    Returns
    -------
    typer : function
        A typer suitable to type constructor calls.

    Raises
    ------
    The returned typer raises a TypingError in case of unsuitable arguments.

    """
    class Typer:
        ...
    
    

@overload(numba_typeref_ctor)
def impl_numba_typeref_ctor(cls, *args): # -> Callable[..., list[Any] | List[Any]] | None:
    """Defines lowering for ``List()`` and ``List(iterable)``.

    This defines the lowering logic to instantiate either an empty typed-list
    or a typed-list initialised with values from a single iterable argument.

    Parameters
    ----------
    cls : TypeRef
        Expecting a TypeRef of a precise ListType.
    args: tuple
        A tuple that contains a single iterable (optional)

    Returns
    -------
    impl : function
        An implementation suitable for lowering the constructor call.

    See also: `redirect_type_ctor` in numba/cpython/bulitins.py
    """
    ...

