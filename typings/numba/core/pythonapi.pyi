"""
This type stub file was generated by pyright.
"""

import contextlib
from collections import namedtuple
from numba.core.utils import PYVERSION

PY_UNICODE_1BYTE_KIND = ...
PY_UNICODE_2BYTE_KIND = ...
PY_UNICODE_4BYTE_KIND = ...
if PYVERSION in ((3, 9), (3, 10), (3, 11)):
    PY_UNICODE_WCHAR_KIND = ...
class _Registry:
    def __init__(self) -> None:
        ...
    
    def register(self, typeclass): # -> Callable[..., Any]:
        ...
    
    def lookup(self, typeclass, default=...): # -> None:
        ...
    


_boxers = ...
_unboxers = ...
_reflectors = ...
box = ...
unbox = ...
reflect = ...
class _BoxContext(namedtuple("_BoxContext", ("context", "builder", "pyapi", "env_manager"))):
    """
    The facilities required by boxing implementations.
    """
    __slots__ = ...
    def box(self, typ, val):
        ...
    


class _UnboxContext(namedtuple("_UnboxContext", ("context", "builder", "pyapi"))):
    """
    The facilities required by unboxing implementations.
    """
    __slots__ = ...
    def unbox(self, typ, obj):
        ...
    


class _ReflectContext(namedtuple("_ReflectContext", ("context", "builder", "pyapi", "env_manager", "is_error"))):
    """
    The facilities required by reflection implementations.
    """
    __slots__ = ...
    def set_error(self): # -> None:
        ...
    
    def box(self, typ, val):
        ...
    
    def reflect(self, typ, val):
        ...
    


class NativeValue:
    """
    Encapsulate the result of converting a Python object to a native value,
    recording whether the conversion was successful and how to cleanup.
    """
    def __init__(self, value, is_error=..., cleanup=...) -> None:
        ...
    


class EnvironmentManager:
    def __init__(self, pyapi, env, env_body, env_ptr) -> None:
        ...
    
    def add_const(self, const): # -> int:
        """
        Add a constant to the environment, return its index.
        """
        ...
    
    def read_const(self, index):
        """
        Look up constant number *index* inside the environment body.
        A borrowed reference is returned.

        The returned LLVM value may have NULL value at runtime which indicates
        an error at runtime.
        """
        ...
    


_IteratorLoop = ...
class PythonAPI:
    """
    Code generation facilities to call into the CPython C API (and related
    helpers).
    """
    def __init__(self, context, builder) -> None:
        """
        Note: Maybe called multiple times when lowering a function
        """
        ...
    
    def get_env_manager(self, env, env_body, env_ptr): # -> EnvironmentManager:
        ...
    
    def emit_environment_sentry(self, envptr, return_pyobject=..., debug_msg=...): # -> None:
        """Emits LLVM code to ensure the `envptr` is not NULL
        """
        ...
    
    def incref(self, obj): # -> None:
        ...
    
    def decref(self, obj): # -> None:
        ...
    
    def get_type(self, obj):
        ...
    
    def parse_tuple_and_keywords(self, args, kws, fmt, keywords, *objs):
        ...
    
    def parse_tuple(self, args, fmt, *objs):
        ...
    
    def unpack_tuple(self, args, name, n_min, n_max, *objs):
        ...
    
    def err_occurred(self):
        ...
    
    def err_clear(self):
        ...
    
    def err_set_string(self, exctype, msg):
        ...
    
    def err_format(self, exctype, msg, *format_args):
        ...
    
    def raise_object(self, exc=...):
        """
        Raise an arbitrary exception (type or value or (type, args)
        or None - if reraising).  A reference to the argument is consumed.
        """
        ...
    
    def err_set_object(self, exctype, excval):
        ...
    
    def err_set_none(self, exctype):
        ...
    
    def err_write_unraisable(self, obj):
        ...
    
    def err_fetch(self, pty, pval, ptb):
        ...
    
    def err_restore(self, ty, val, tb):
        ...
    
    @contextlib.contextmanager
    def err_push(self, keep_new=...): # -> Generator[None, Any, None]:
        """
        Temporarily push the current error indicator while the code
        block is executed.  If *keep_new* is True and the code block
        raises a new error, the new error is kept, otherwise the old
        error indicator is restored at the end of the block.
        """
        ...
    
    def get_c_object(self, name):
        """
        Get a Python object through its C-accessible *name*
        (e.g. "PyExc_ValueError").  The underlying variable must be
        a `PyObject *`, and the value of that pointer is returned.
        """
        ...
    
    def raise_missing_global_error(self, name): # -> None:
        ...
    
    def raise_missing_name_error(self, name): # -> None:
        ...
    
    def fatal_error(self, msg): # -> None:
        ...
    
    def dict_getitem_string(self, dic, name):
        """Lookup name inside dict

        Returns a borrowed reference
        """
        ...
    
    def dict_getitem(self, dic, name):
        """Lookup name inside dict

        Returns a borrowed reference
        """
        ...
    
    def dict_new(self, presize=...):
        ...
    
    def dict_setitem(self, dictobj, nameobj, valobj):
        ...
    
    def dict_setitem_string(self, dictobj, name, valobj):
        ...
    
    def dict_pack(self, keyvalues):
        """
        Args
        -----
        keyvalues: iterable of (str, llvm.Value of PyObject*)
        """
        ...
    
    def float_from_double(self, fval):
        ...
    
    def number_as_ssize_t(self, numobj):
        ...
    
    def number_long(self, numobj):
        ...
    
    def long_as_ulonglong(self, numobj):
        ...
    
    def long_as_longlong(self, numobj):
        ...
    
    def long_as_voidptr(self, numobj):
        """
        Convert the given Python integer to a void*.  This is recommended
        over number_as_ssize_t as it isn't affected by signedness.
        """
        ...
    
    def long_from_long(self, ival):
        ...
    
    def long_from_ulong(self, ival):
        ...
    
    def long_from_ssize_t(self, ival):
        ...
    
    def long_from_longlong(self, ival):
        ...
    
    def long_from_ulonglong(self, ival):
        ...
    
    def long_from_signed_int(self, ival):
        """
        Return a Python integer from any native integer value.
        """
        ...
    
    def long_from_unsigned_int(self, ival):
        """
        Same as long_from_signed_int, but for unsigned values.
        """
        ...
    
    def number_add(self, lhs, rhs, inplace=...):
        ...
    
    def number_subtract(self, lhs, rhs, inplace=...):
        ...
    
    def number_multiply(self, lhs, rhs, inplace=...):
        ...
    
    def number_truedivide(self, lhs, rhs, inplace=...):
        ...
    
    def number_floordivide(self, lhs, rhs, inplace=...):
        ...
    
    def number_remainder(self, lhs, rhs, inplace=...):
        ...
    
    def number_matrix_multiply(self, lhs, rhs, inplace=...):
        ...
    
    def number_lshift(self, lhs, rhs, inplace=...):
        ...
    
    def number_rshift(self, lhs, rhs, inplace=...):
        ...
    
    def number_and(self, lhs, rhs, inplace=...):
        ...
    
    def number_or(self, lhs, rhs, inplace=...):
        ...
    
    def number_xor(self, lhs, rhs, inplace=...):
        ...
    
    def number_power(self, lhs, rhs, inplace=...):
        ...
    
    def number_negative(self, obj):
        ...
    
    def number_positive(self, obj):
        ...
    
    def number_float(self, val):
        ...
    
    def number_invert(self, obj):
        ...
    
    def float_as_double(self, fobj):
        ...
    
    def bool_from_bool(self, bval):
        """
        Get a Python bool from a LLVM boolean.
        """
        ...
    
    def bool_from_long(self, ival):
        ...
    
    def complex_from_doubles(self, realval, imagval):
        ...
    
    def complex_real_as_double(self, cobj):
        ...
    
    def complex_imag_as_double(self, cobj):
        ...
    
    def slice_as_ints(self, obj): # -> tuple[Any, Any, Any, Any]:
        """
        Read the members of a slice of integers.

        Returns a (ok, start, stop, step) tuple where ok is a boolean and
        the following members are pointer-sized ints.
        """
        ...
    
    def sequence_getslice(self, obj, start, stop):
        ...
    
    def sequence_tuple(self, obj):
        ...
    
    def sequence_concat(self, obj1, obj2):
        ...
    
    def list_new(self, szval):
        ...
    
    def list_size(self, lst):
        ...
    
    def list_append(self, lst, val):
        ...
    
    def list_setitem(self, lst, idx, val):
        """
        Warning: Steals reference to ``val``
        """
        ...
    
    def list_getitem(self, lst, idx):
        """
        Returns a borrowed reference.
        """
        ...
    
    def list_setslice(self, lst, start, stop, obj):
        ...
    
    def tuple_getitem(self, tup, idx):
        """
        Borrow reference
        """
        ...
    
    def tuple_pack(self, items):
        ...
    
    def tuple_size(self, tup):
        ...
    
    def tuple_new(self, count):
        ...
    
    def tuple_setitem(self, tuple_val, index, item): # -> None:
        """
        Steals a reference to `item`.
        """
        ...
    
    def set_new(self, iterable=...):
        ...
    
    def set_add(self, set, value):
        ...
    
    def set_clear(self, set):
        ...
    
    def set_size(self, set):
        ...
    
    def set_update(self, set, iterable):
        ...
    
    def set_next_entry(self, set, posptr, keyptr, hashptr):
        ...
    
    @contextlib.contextmanager
    def set_iterate(self, set): # -> Generator[_IteratorLoop, Any, None]:
        ...
    
    def gil_ensure(self):
        """
        Ensure the GIL is acquired.
        The returned value must be consumed by gil_release().
        """
        ...
    
    def gil_release(self, gil):
        """
        Release the acquired GIL by gil_ensure().
        Must be paired with a gil_ensure().
        """
        ...
    
    def save_thread(self):
        """
        Release the GIL and return the former thread state
        (an opaque non-NULL pointer).
        """
        ...
    
    def restore_thread(self, thread_state): # -> None:
        """
        Restore the given thread state by reacquiring the GIL.
        """
        ...
    
    def object_get_private_data(self, obj):
        ...
    
    def object_set_private_data(self, obj, ptr):
        ...
    
    def object_reset_private_data(self, obj):
        ...
    
    def import_module_noblock(self, modname):
        ...
    
    def call_function_objargs(self, callee, objargs):
        ...
    
    def call_method(self, callee, method, objargs=...):
        ...
    
    def call(self, callee, args=..., kws=...):
        ...
    
    def object_type(self, obj):
        """Emit a call to ``PyObject_Type(obj)`` to get the type of ``obj``.
        """
        ...
    
    def object_istrue(self, obj):
        ...
    
    def object_not(self, obj):
        ...
    
    def object_richcompare(self, lhs, rhs, opstr):
        """
        Refer to Python source Include/object.h for macros definition
        of the opid.
        """
        ...
    
    def iter_next(self, iterobj):
        ...
    
    def object_getiter(self, obj):
        ...
    
    def object_getattr_string(self, obj, attr):
        ...
    
    def object_getattr(self, obj, attr):
        ...
    
    def object_setattr_string(self, obj, attr, val):
        ...
    
    def object_setattr(self, obj, attr, val):
        ...
    
    def object_delattr_string(self, obj, attr):
        ...
    
    def object_delattr(self, obj, attr):
        ...
    
    def object_getitem(self, obj, key):
        """
        Return obj[key]
        """
        ...
    
    def object_setitem(self, obj, key, val):
        """
        obj[key] = val
        """
        ...
    
    def object_delitem(self, obj, key):
        """
        del obj[key]
        """
        ...
    
    def string_as_string(self, strobj):
        ...
    
    def string_as_string_and_size(self, strobj): # -> tuple[Any, Any, Any]:
        """
        Returns a tuple of ``(ok, buffer, length)``.
        The ``ok`` is i1 value that is set if ok.
        The ``buffer`` is a i8* of the output buffer.
        The ``length`` is a i32/i64 (py_ssize_t) of the length of the buffer.
        """
        ...
    
    def string_as_string_size_and_kind(self, strobj): # -> tuple[Any, Any, Any, Any, Any, Any]:
        """
        Returns a tuple of ``(ok, buffer, length, kind)``.
        The ``ok`` is i1 value that is set if ok.
        The ``buffer`` is a i8* of the output buffer.
        The ``length`` is a i32/i64 (py_ssize_t) of the length of the buffer.
        The ``kind`` is a i32 (int32) of the Unicode kind constant
        The ``hash`` is a long/uint64_t (py_hash_t) of the Unicode constant hash
        """
        ...
    
    def string_from_string_and_size(self, string, size):
        ...
    
    def string_from_string(self, string):
        ...
    
    def string_from_kind_and_data(self, kind, string, size):
        ...
    
    def bytes_as_string(self, obj):
        ...
    
    def bytes_as_string_and_size(self, obj, p_buffer, p_length):
        ...
    
    def bytes_from_string_and_size(self, string, size):
        ...
    
    def object_hash(self, obj):
        ...
    
    def object_str(self, obj):
        ...
    
    def make_none(self):
        ...
    
    def borrow_none(self):
        ...
    
    def sys_write_stdout(self, fmt, *args):
        ...
    
    def object_dump(self, obj):
        """
        Dump a Python object on C stderr.  For debugging purposes.
        """
        ...
    
    def nrt_adapt_ndarray_to_python(self, aryty, ary, dtypeptr):
        ...
    
    def nrt_meminfo_new_from_pyobject(self, data, pyobj):
        """
        Allocate a new MemInfo with data payload borrowed from a python
        object.
        """
        ...
    
    def nrt_meminfo_as_pyobject(self, miptr):
        ...
    
    def nrt_meminfo_from_pyobject(self, miobj):
        ...
    
    def nrt_adapt_ndarray_from_python(self, ary, ptr):
        ...
    
    def nrt_adapt_buffer_from_python(self, buf, ptr):
        ...
    
    def alloca_obj(self):
        ...
    
    def alloca_buffer(self):
        """
        Return a pointer to a stack-allocated, zero-initialized Py_buffer.
        """
        ...
    
    @contextlib.contextmanager
    def if_object_ok(self, obj): # -> Generator[None, Any, None]:
        ...
    
    def print_object(self, obj): # -> None:
        ...
    
    def print_string(self, text): # -> None:
        ...
    
    def get_null_object(self): # -> Constant:
        ...
    
    def return_none(self): # -> None:
        ...
    
    def list_pack(self, items):
        ...
    
    def unserialize(self, structptr):
        """
        Unserialize some data.  *structptr* should be a pointer to
        a {i8* data, i32 length, i8* hashbuf, i8* func_ptr, i32 alloc_flag}
        structure.
        """
        ...
    
    def build_dynamic_excinfo_struct(self, struct_gv, exc_args):
        """
        Serialize some data at runtime. Returns a pointer to a python tuple
        (bytes_data, hash) where the first element is the serialized data as
        bytes and the second its hash.
        """
        ...
    
    def serialize_uncached(self, obj): # -> Constant:
        """
        Same as serialize_object(), but don't create a global variable,
        simply return a literal for structure:
        {i8* data, i32 length, i8* hashbuf, i8* func_ptr, i32 alloc_flag}
        """
        ...
    
    def serialize_object(self, obj):
        """
        Serialize the given object in the bitcode, and return it
        as a pointer to a
        {i8* data, i32 length, i8* hashbuf, i8* fn_ptr, i32 alloc_flag},
        structure constant (suitable for passing to unserialize()).
        """
        ...
    
    def c_api_error(self):
        ...
    
    def to_native_value(self, typ, obj):
        """
        Unbox the Python object as the given Numba type.
        A NativeValue instance is returned.
        """
        ...
    
    def from_native_return(self, typ, val, env_manager):
        ...
    
    def from_native_value(self, typ, val, env_manager=...):
        """
        Box the native value of the given Numba type.  A Python object
        pointer is returned (NULL if an error occurred).
        This method steals any native (NRT) reference embedded in *val*.
        """
        ...
    
    def reflect_native_value(self, typ, val, env_manager=...): # -> Constant:
        """
        Reflect the native value onto its Python original, if any.
        An error bit (as an LLVM value) is returned.
        """
        ...
    
    def to_native_generator(self, obj, typ): # -> NativeValue:
        """
        Extract the generator structure pointer from a generator *obj*
        (a _dynfunc.Generator instance).
        """
        ...
    
    def from_native_generator(self, val, typ, env=...):
        """
        Make a Numba generator (a _dynfunc.Generator instance) from a
        generator structure pointer *val*.
        *env* is an optional _dynfunc.Environment instance to be wrapped
        in the generator.
        """
        ...
    
    def numba_array_adaptor(self, ary, ptr):
        ...
    
    def numba_buffer_adaptor(self, buf, ptr):
        ...
    
    def complex_adaptor(self, cobj, cmplx):
        ...
    
    def extract_record_data(self, obj, pbuf):
        ...
    
    def get_buffer(self, obj, pbuf):
        ...
    
    def release_buffer(self, pbuf):
        ...
    
    def extract_np_datetime(self, obj):
        ...
    
    def extract_np_timedelta(self, obj):
        ...
    
    def create_np_datetime(self, val, unit_code):
        ...
    
    def create_np_timedelta(self, val, unit_code):
        ...
    
    def recreate_record(self, pdata, size, dtype, env_manager):
        ...
    
    def string_from_constant_string(self, string):
        ...
    
    def call_jit_code(self, func, sig, args): # -> tuple[Any, Any]:
        """Calls into Numba jitted code and propagate error using the Python
        calling convention.

        Parameters
        ----------
        func : function
            The Python function to be compiled. This function is compiled
            in nopython-mode.
        sig : numba.typing.Signature
            The function signature for *func*.
        args : Sequence[llvmlite.binding.Value]
            LLVM values to use as arguments.

        Returns
        -------
        (is_error, res) :  2-tuple of llvmlite.binding.Value.
            is_error : true iff *func* raised an exception.
            res : Returned value from *func* iff *is_error* is false.

        If *is_error* is true, this method will adapt the nopython exception
        into a Python exception. Caller should return NULL to Python to
        indicate an error.
        """
        ...
    


class ObjModeUtils:
    """Internal utils for calling objmode dispatcher from within NPM code.
    """
    def __init__(self, pyapi) -> None:
        ...
    
    def load_dispatcher(self, fnty, argtypes):
        ...
    


