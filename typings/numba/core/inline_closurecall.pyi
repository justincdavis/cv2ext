"""
This type stub file was generated by pyright.
"""

from numba.core import rewrites

enable_inline_arraycall = ...
def callee_ir_validator(func_ir): # -> None:
    """Checks the IR of a callee is supported for inlining
    """
    ...

class InlineClosureCallPass:
    """InlineClosureCallPass class looks for direct calls to locally defined
    closures, and inlines the body of the closure function to the call site.
    """
    def __init__(self, func_ir, parallel_options, swapped=..., typed=...) -> None:
        ...
    
    def run(self): # -> None:
        """Run inline closure call pass.
        """
        ...
    


def check_reduce_func(func_ir, func_var):
    """Checks the function at func_var in func_ir to make sure it's amenable
    for inlining. Returns the function itself"""
    ...

class InlineWorker:
    """ A worker class for inlining, this is a more advanced version of
    `inline_closure_call` in that it permits inlining from function type, Numba
    IR and code object. It also, runs the entire untyped compiler pipeline on
    the inlinee to ensure that it is transformed as though it were compiled
    directly.
    """
    def __init__(self, typingctx=..., targetctx=..., locals=..., pipeline=..., flags=..., validator=..., typemap=..., calltypes=...) -> None:
        """
        Instantiate a new InlineWorker, all arguments are optional though some
        must be supplied together for certain use cases. The methods will refuse
        to run if the object isn't configured in the manner needed. Args are the
        same as those in a numba.core.Compiler.state, except the validator which
        is a function taking Numba IR and validating it for use when inlining
        (this is optional and really to just provide better error messages about
        things which the inliner cannot handle like yield in closure).
        """
        ...
    
    def inline_ir(self, caller_ir, block, i, callee_ir, callee_freevars, arg_typs=...): # -> tuple[Any, dict[Any, Any], dict[Any, Any], list[Any]]:
        """ Inlines the callee_ir in the caller_ir at statement index i of block
        `block`, callee_freevars are the free variables for the callee_ir. If
        the callee_ir is derived from a function `func` then this is
        `func.__code__.co_freevars`. If `arg_typs` is given and the InlineWorker
        instance was initialized with a typemap and calltypes then they will be
        appropriately updated based on the arg_typs.
        """
        ...
    
    def inline_function(self, caller_ir, block, i, function, arg_typs=...): # -> tuple[Any, dict[Any, Any], dict[Any, Any], list[Any]]:
        """ Inlines the function in the caller_ir at statement index i of block
        `block`. If `arg_typs` is given and the InlineWorker instance was
        initialized with a typemap and calltypes then they will be appropriately
        updated based on the arg_typs.
        """
        ...
    
    def run_untyped_passes(self, func, enable_ssa=...): # -> None:
        """
        Run the compiler frontend's untyped passes over the given Python
        function, and return the function's canonical Numba IR.

        Disable SSA transformation by default, since the call site won't be in
        SSA form and self.inline_ir depends on this being the case.
        """
        ...
    
    def update_type_and_call_maps(self, callee_ir, arg_typs): # -> None:
        """ Updates the type and call maps based on calling callee_ir with
        arguments from arg_typs"""
        ...
    


def inline_closure_call(func_ir, glbls, block, i, callee, typingctx=..., targetctx=..., arg_typs=..., typemap=..., calltypes=..., work_list=..., callee_validator=..., replace_freevars=...): # -> tuple[dict[Any, Any], dict[Any, Any]]:
    """Inline the body of `callee` at its callsite (`i`-th instruction of
    `block`)

    `func_ir` is the func_ir object of the caller function and `glbls` is its
    global variable environment (func_ir.func_id.func.__globals__).
    `block` is the IR block of the callsite and `i` is the index of the
    callsite's node. `callee` is either the called function or a
    make_function node. `typingctx`, `typemap` and `calltypes` are typing
    data structures of the caller, available if we are in a typed pass.
    `arg_typs` includes the types of the arguments at the callsite.
    `callee_validator` is an optional callable which can be used to validate the
    IR of the callee to ensure that it contains IR supported for inlining, it
    takes one argument, the func_ir of the callee

    Returns IR blocks of the callee and the variable renaming dictionary used
    for them to facilitate further processing of new blocks.
    """
    ...

@rewrites.register_rewrite('after-inference')
class RewriteArrayOfConsts(rewrites.Rewrite):
    '''The RewriteArrayOfConsts class is responsible for finding
    1D array creations from a constant list, and rewriting it into
    direct initialization of array elements without creating the list.
    '''
    def __init__(self, state, *args, **kws) -> None:
        ...
    
    def match(self, func_ir, block, typemap, calltypes): # -> bool:
        ...
    
    def apply(self):
        ...
    


