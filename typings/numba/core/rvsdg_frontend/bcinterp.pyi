"""
This type stub file was generated by pyright.
"""

import dis
from contextlib import contextmanager
from typing import Iterator
from numba.core import bytecode, ir
from .rvsdg.bc2rvsdg import BasicBlock, Op, RegionBlock, SCFG, ValueState
from .rvsdg.regionpasses import RegionVisitor

"""
This file contains logic to convert RVSDG into Numba IR.

Key APIs:
- function `run_frontend()`
- function `rvsdg_to_ir()`
"""
def run_frontend(func): # -> FunctionIR:
    ...

_noop = ...
_Data = dict[str, ir.Var]
class RVSDG2IR(RegionVisitor[_Data]):
    blocks: dict[int, ir.Block]
    func_id: bytecode.FunctionIdentity
    local_scope: ir.Scope
    global_scope: ir.Scope
    vsmap: dict[ValueState, ir.Var]
    _current_block: ir.Block | None
    last_block_label: int | None
    branch_predicate: ir.Var | None
    _label_map: dict[str, int]
    _emit_debug_print = ...
    def __init__(self, func_id) -> None:
        ...
    
    @property
    def current_block(self) -> ir.Block:
        ...
    
    @property
    def last_block(self) -> ir.Block:
        ...
    
    def initialize(self) -> _Data:
        ...
    
    def finalize(self): # -> None:
        ...
    
    def visit_block(self, block: BasicBlock, data: _Data) -> _Data:
        ...
    
    def visit_loop(self, region: RegionBlock, data: _Data) -> _Data:
        ...
    
    def visit_switch(self, region: RegionBlock, data: _Data) -> _Data:
        ...
    
    def visit_linear(self, region: RegionBlock, data: _Data) -> _Data:
        ...
    
    @contextmanager
    def set_block(self, label: int, block: ir.Block) -> Iterator[ir.Block]:
        """A context manager that set the current block for other IR building
        methods.

        In addition,

        - It closes any existing block in ``last_block_label`` by jumping to the
          new block.
        - If there is a existing block, it will be restored as the current block
          after the context manager.
        """
        ...
    
    def store(self, value, name, *, redefine=..., block=...) -> ir.Var:
        ...
    
    def store_vsmap(self, val, vs): # -> None:
        ...
    
    def append(self, stmt: ir.Stmt, block=...): # -> None:
        ...
    
    def get_global_value(self, name): # -> Any | UndefinedType:
        """THIS IS COPIED from interpreter.py

        Get a global value from the func_global (first) or
        as a builtins (second).  If both failed, return a ir.UNDEFINED.
        """
        ...
    
    def get_closure_value(self, index): # -> UndefinedType:
        """
        Get a value from the cell contained in this function's closure.
        If not set, return a ir.UNDEFINED.
        """
        ...
    
    def debug_print(self, msg: str, *args): # -> None:
        ...
    
    def interpret_bytecode(self, op: Op): # -> None:
        """Interpret a single Op containing bytecode instructions.

        Internally, it dispatches to methods with names following the pattern
        `op_<opname>`.
        """
        ...
    
    def op_PUSH_NULL(self, op: Op, bc: dis.Instruction): # -> None:
        ...
    
    def op_LOAD_CONST(self, op: Op, bc: dis.Instruction): # -> None:
        ...
    
    def op_LOAD_GLOBAL(self, op: Op, bc: dis.Instruction): # -> None:
        ...
    
    def op_LOAD_ATTR(self, op: Op, bc: dis.Instruction): # -> None:
        ...
    
    def op_LOAD_METHOD(self, op: Op, bc: dis.Instruction): # -> None:
        ...
    
    def op_LOAD_DEREF(self, op: Op, bc: dis.Instruction): # -> None:
        ...
    
    def op_STORE_FAST(self, op: Op, bc: dis.Instruction): # -> None:
        ...
    
    def op_KW_NAMES(self, op: Op, bc: dis.Instruction): # -> None:
        ...
    
    def op_CALL(self, op: Op, bc: dis.Instruction): # -> None:
        ...
    
    def op_COMPARE_OP(self, op: Op, bc: dis.Instruction): # -> None:
        ...
    
    def op_BINARY_OP(self, op: Op, bc: dis.Instruction): # -> None:
        ...
    
    def op_IS_OP(self, op: Op, bc: dis.Instruction): # -> None:
        ...
    
    def op_UNARY_NOT(self, op: Op, bc: dis.Instruction): # -> None:
        ...
    
    def op_BINARY_SUBSCR(self, op: Op, bc: dis.Instruction): # -> None:
        ...
    
    def op_STORE_SUBSCR(self, op: Op, bc: dis.Instruction): # -> None:
        ...
    
    def op_BUILD_TUPLE(self, op: Op, bc: dis.Instruction): # -> None:
        ...
    
    def op_BUILD_SLICE(self, op: Op, bc: dis.Instruction): # -> None:
        ...
    
    def op_GET_ITER(self, op: Op, bc: dis.Instruction): # -> None:
        ...
    
    def op_FOR_ITER(self, op: Op, bc: dis.Instruction): # -> None:
        ...
    
    def op_JUMP_IF_FALSE_OR_POP(self, op: Op, bc: dis.Instruction): # -> None:
        ...
    
    def op_JUMP_IF_TRUE_OR_POP(self, op: Op, bc: dis.Instruction): # -> None:
        ...
    
    def op_POP_JUMP_FORWARD_IF_FALSE(self, op: Op, bc: dis.Instruction): # -> None:
        ...
    
    def op_POP_JUMP_FORWARD_IF_TRUE(self, op: Op, bc: dis.Instruction): # -> None:
        ...
    
    def op_POP_JUMP_FORWARD_IF_NONE(self, op: Op, bc: dis.Instruction): # -> None:
        ...
    
    def op_POP_JUMP_FORWARD_IF_NOT_NONE(self, op: Op, bc: dis.Instruction): # -> None:
        ...
    
    op_POP_JUMP_BACKWARD_IF_TRUE = ...
    def op_RETURN_VALUE(self, op: Op, bc: dis.Instruction): # -> None:
        ...
    
    def op_RAISE_VARARGS(self, op: Op, bc: dis.Instruction): # -> None:
        ...
    


def rvsdg_to_ir(func_id: bytecode.FunctionIdentity, rvsdg: SCFG) -> ir.FunctionIR:
    ...

