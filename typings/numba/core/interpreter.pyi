"""
This type stub file was generated by pyright.
"""

from numba.core.utils import PYVERSION

if PYVERSION in ((3, 12), ):
    ...
else:
    ...
class _UNKNOWN_VALUE:
    """Represents an unknown value, this is for ease of debugging purposes only.
    """
    def __init__(self, varname) -> None:
        ...
    
    def __repr__(self): # -> LiteralString:
        ...
    


_logger = ...
class Assigner:
    """
    This object keeps track of potential assignment simplifications
    inside a code block.
    For example `$O.1 = x` followed by `y = $0.1` can be simplified
    into `y = x`, but it's not possible anymore if we have `x = z`
    in-between those two instructions.

    NOTE: this is not only an optimization, but is actually necessary
    due to certain limitations of Numba - such as only accepting the
    returning of an array passed as function argument.
    """
    def __init__(self) -> None:
        ...
    
    def assign(self, srcvar, destvar):
        """
        Assign *srcvar* to *destvar*. Return either *srcvar* or a possible
        simplified assignment source (earlier assigned to *srcvar*).
        """
        ...
    
    def get_assignment_source(self, destname): # -> None:
        """
        Get a possible assignment source (a ir.Var instance) to replace
        *destname*, otherwise None.
        """
        ...
    


def peep_hole_call_function_ex_to_call_function_kw(func_ir):
    """
    This peephole rewrites a bytecode sequence unique to Python 3.10
    where CALL_FUNCTION_EX is used instead of CALL_FUNCTION_KW because of
    stack limitations set by CPython. This limitation is imposed whenever
    a function call has too many arguments or keyword arguments.

    https://github.com/python/cpython/blob/a58ebcc701dd6c43630df941481475ff0f615a81/Python/compile.c#L55
    https://github.com/python/cpython/blob/a58ebcc701dd6c43630df941481475ff0f615a81/Python/compile.c#L4442

    In particular, this change is imposed whenever (n_args / 2) + n_kws > 15.

    Different bytecode is generated for args depending on if n_args > 30
    or n_args <= 30 and similarly if n_kws > 15 or n_kws <= 15.

    This function unwraps the *args and **kwargs in the function call
    and places these values directly into the args and kwargs of the call.
    """
    ...

def peep_hole_list_to_tuple(func_ir):
    """
    This peephole rewrites a bytecode sequence new to Python 3.9 that looks
    like e.g.:

    def foo(a):
        return (*a,)

    41          0 BUILD_LIST               0
                2 LOAD_FAST                0 (a)
                4 LIST_EXTEND              1
                6 LIST_TO_TUPLE
                8 RETURN_VAL

    essentially, the unpacking of tuples is written as a list which is appended
    to/extended and then "magicked" into a tuple by the new LIST_TO_TUPLE
    opcode.

    This peephole repeatedly analyses the bytecode in a block looking for a
    window between a `LIST_TO_TUPLE` and `BUILD_LIST` and...

    1. Turns the BUILD_LIST into a BUILD_TUPLE
    2. Sets an accumulator's initial value as the target of the BUILD_TUPLE
    3. Searches for 'extend' on the original list and turns these into binary
       additions on the accumulator.
    4. Searches for 'append' on the original list and turns these into a
       `BUILD_TUPLE` which is then appended via binary addition to the
       accumulator.
    5. Assigns the accumulator to the variable that exits the peephole and the
       rest of the block/code refers to as the result of the unpack operation.
    6. Patches up
    """
    ...

def peep_hole_delete_with_exit(func_ir):
    """
    This rewrite removes variables used to store the `__exit__` function
    loaded by SETUP_WITH.
    """
    ...

def peep_hole_fuse_dict_add_updates(func_ir):
    """
    This rewrite removes d1._update_from_bytecode(d2)
    calls that are between two dictionaries, d1 and d2,
    in the same basic block. This pattern can appear as a
    result of Python 3.10 bytecode emission changes, which
    prevent large constant literal dictionaries
    (> 15 elements) from being constant. If both dictionaries
    are constant dictionaries defined in the same block and
    neither is used between the update call, then we replace d1
    with a new definition that combines the two dictionaries. At
    the bytecode translation stage we convert DICT_UPDATE into
    _update_from_bytecode, so we know that _update_from_bytecode
    always comes from the bytecode change and not user code.

    Python 3.10 may also rewrite the individual dictionaries
    as an empty build_map + many map_add. Here we again look
    for an _update_from_bytecode, and if so we replace these
    with a single constant dictionary.

    When running this algorithm we can always safely remove d2.

    This is the relevant section of the CPython 3.10 that causes
    this bytecode change:
    https://github.com/python/cpython/blob/3.10/Python/compile.c#L4048
    """
    ...

def peep_hole_split_at_pop_block(func_ir):
    """
    Split blocks that contain ir.PopBlock.

    This rewrite restores the IR structure to pre 3.11 so that withlifting
    can work correctly.
    """
    ...

class Interpreter:
    """A bytecode interpreter that builds up the IR.
    """
    _DEBUG_PRINT = ...
    def __init__(self, func_id) -> None:
        ...
    
    def interpret(self, bytecode):
        """
        Generate IR for this bytecode.
        """
        ...
    
    def post_process(self, peepholes, func_ir):
        ...
    
    def init_first_block(self): # -> None:
        ...
    
    def get_global_value(self, name): # -> Any | UndefinedType:
        """
        Get a global value from the func_global (first) or
        as a builtins (second).  If both failed, return a ir.UNDEFINED.
        """
        ...
    
    def get_closure_value(self, index): # -> UndefinedType:
        """
        Get a value from the cell contained in this function's closure.
        If not set, return a ir.UNDEFINED.
        """
        ...
    
    @property
    def current_scope(self):
        ...
    
    @property
    def code_consts(self):
        ...
    
    @property
    def code_locals(self):
        ...
    
    @property
    def code_names(self):
        ...
    
    @property
    def code_cellvars(self):
        ...
    
    @property
    def code_freevars(self):
        ...
    
    def store(self, value, name, redefine=...):
        """
        Store *value* (a Expr or Var instance) into the variable named *name*
        (a str object). Returns the target variable.
        """
        ...
    
    def get(self, name):
        """
        Get the variable (a Var instance) with the given *name*.
        """
        ...
    
    def insert_block(self, offset, scope=..., loc=...): # -> Block:
        ...
    
    def op_NOP(self, inst): # -> None:
        ...
    
    def op_RESUME(self, inst): # -> None:
        ...
    
    def op_CACHE(self, inst): # -> None:
        ...
    
    def op_PRECALL(self, inst): # -> None:
        ...
    
    def op_PUSH_NULL(self, inst): # -> None:
        ...
    
    def op_RETURN_GENERATOR(self, inst): # -> None:
        ...
    
    def op_PRINT_ITEM(self, inst, item, printvar, res): # -> None:
        ...
    
    def op_PRINT_NEWLINE(self, inst, printvar, res): # -> None:
        ...
    
    def op_UNPACK_SEQUENCE(self, inst, iterable, stores, tupleobj): # -> None:
        ...
    
    def op_FORMAT_VALUE(self, inst, value, res, strvar): # -> None:
        """
        FORMAT_VALUE(flags): flags argument specifies format spec which is not
        supported yet. Currently, str() is simply called on the value.
        https://docs.python.org/3/library/dis.html#opcode-FORMAT_VALUE
        """
        ...
    
    def op_BUILD_STRING(self, inst, strings, tmps): # -> None:
        """
        BUILD_STRING(count): Concatenates count strings.
        Required for supporting f-strings.
        https://docs.python.org/3/library/dis.html#opcode-BUILD_STRING
        """
        ...
    
    def op_BUILD_SLICE(self, inst, start, stop, step, res, slicevar): # -> None:
        ...
    
    if PYVERSION in ((3, 12), ):
        def op_BINARY_SLICE(self, inst, start, end, container, res, slicevar, temp_res): # -> None:
            ...
        
    else:
        ...
    if PYVERSION in ((3, 12), ):
        def op_STORE_SLICE(self, inst, start, end, container, value, res, slicevar): # -> None:
            ...
        
    else:
        ...
    def op_SLICE_0(self, inst, base, res, slicevar, indexvar, nonevar): # -> None:
        ...
    
    def op_SLICE_1(self, inst, base, start, nonevar, res, slicevar, indexvar): # -> None:
        ...
    
    def op_SLICE_2(self, inst, base, nonevar, stop, res, slicevar, indexvar): # -> None:
        ...
    
    def op_SLICE_3(self, inst, base, start, stop, res, slicevar, indexvar): # -> None:
        ...
    
    def op_STORE_SLICE_0(self, inst, base, value, slicevar, indexvar, nonevar): # -> None:
        ...
    
    def op_STORE_SLICE_1(self, inst, base, start, nonevar, value, slicevar, indexvar): # -> None:
        ...
    
    def op_STORE_SLICE_2(self, inst, base, nonevar, stop, value, slicevar, indexvar): # -> None:
        ...
    
    def op_STORE_SLICE_3(self, inst, base, start, stop, value, slicevar, indexvar): # -> None:
        ...
    
    def op_DELETE_SLICE_0(self, inst, base, slicevar, indexvar, nonevar): # -> None:
        ...
    
    def op_DELETE_SLICE_1(self, inst, base, start, nonevar, slicevar, indexvar): # -> None:
        ...
    
    def op_DELETE_SLICE_2(self, inst, base, nonevar, stop, slicevar, indexvar): # -> None:
        ...
    
    def op_DELETE_SLICE_3(self, inst, base, start, stop, slicevar, indexvar): # -> None:
        ...
    
    def op_LOAD_FAST(self, inst, res): # -> None:
        ...
    
    if PYVERSION in ((3, 12), ):
        op_LOAD_FAST_CHECK = ...
        def op_LOAD_FAST_AND_CLEAR(self, inst, res): # -> None:
            ...
        
    else:
        ...
    def op_STORE_FAST(self, inst, value): # -> None:
        ...
    
    def op_DELETE_FAST(self, inst): # -> None:
        ...
    
    def op_DUP_TOPX(self, inst, orig, duped): # -> None:
        ...
    
    op_DUP_TOP = ...
    op_DUP_TOP_TWO = ...
    def op_STORE_ATTR(self, inst, target, value): # -> None:
        ...
    
    def op_DELETE_ATTR(self, inst, target): # -> None:
        ...
    
    def op_LOAD_ATTR(self, inst, item, res): # -> None:
        ...
    
    def op_LOAD_CONST(self, inst, res): # -> None:
        ...
    
    if PYVERSION in ((3, 11), (3, 12)):
        def op_LOAD_GLOBAL(self, inst, idx, res): # -> None:
            ...
        
    else:
        def op_LOAD_GLOBAL(self, inst, res): # -> None:
            ...
        
    def op_COPY_FREE_VARS(self, inst): # -> None:
        ...
    
    if PYVERSION in ((3, 11), (3, 12)):
        def op_LOAD_DEREF(self, inst, res): # -> None:
            ...
        
    else:
        def op_LOAD_DEREF(self, inst, res): # -> None:
            ...
        
    if PYVERSION in ((3, 11), (3, 12)):
        def op_MAKE_CELL(self, inst): # -> None:
            ...
        
    if PYVERSION in ((3, 11), (3, 12)):
        def op_STORE_DEREF(self, inst, value): # -> None:
            ...
        
    else:
        def op_STORE_DEREF(self, inst, value): # -> None:
            ...
        
    def op_SETUP_LOOP(self, inst): # -> None:
        ...
    
    def op_SETUP_WITH(self, inst, contextmanager, exitfn=...): # -> None:
        ...
    
    def op_BEFORE_WITH(self, inst, contextmanager, exitfn, end): # -> None:
        ...
    
    def op_SETUP_FINALLY(self, inst): # -> None:
        ...
    
    def op_WITH_CLEANUP(self, inst): # -> None:
        "no-op"
        ...
    
    def op_WITH_CLEANUP_START(self, inst): # -> None:
        "no-op"
        ...
    
    def op_WITH_CLEANUP_FINISH(self, inst): # -> None:
        "no-op"
        ...
    
    def op_END_FINALLY(self, inst): # -> None:
        "no-op"
        ...
    
    def op_BEGIN_FINALLY(self, inst, temps): # -> None:
        ...
    
    def op_CALL(self, inst, func, args, kw_names, res): # -> None:
        ...
    
    def op_CALL_FUNCTION(self, inst, func, args, res): # -> None:
        ...
    
    def op_CALL_FUNCTION_KW(self, inst, func, args, names, res): # -> None:
        ...
    
    def op_CALL_FUNCTION_EX(self, inst, func, vararg, varkwarg, res): # -> None:
        ...
    
    def op_BUILD_TUPLE_UNPACK_WITH_CALL(self, inst, tuples, temps, is_assign): # -> None:
        ...
    
    def op_BUILD_TUPLE_UNPACK(self, inst, tuples, temps, is_assign): # -> None:
        ...
    
    def op_LIST_TO_TUPLE(self, inst, const_list, res): # -> None:
        ...
    
    def op_BUILD_CONST_KEY_MAP(self, inst, keys, keytmps, values, res): # -> None:
        ...
    
    def op_GET_ITER(self, inst, value, res): # -> None:
        ...
    
    def op_FOR_ITER(self, inst, iterator, pair, indval, pred): # -> None:
        """
        Assign new block other this instruction.
        """
        ...
    
    def op_BINARY_SUBSCR(self, inst, target, index, res): # -> None:
        ...
    
    def op_STORE_SUBSCR(self, inst, target, index, value): # -> None:
        ...
    
    def op_DELETE_SUBSCR(self, inst, target, index): # -> None:
        ...
    
    def op_BUILD_TUPLE(self, inst, items, res): # -> None:
        ...
    
    def op_BUILD_LIST(self, inst, items, res): # -> None:
        ...
    
    def op_BUILD_SET(self, inst, items, res): # -> None:
        ...
    
    def op_SET_UPDATE(self, inst, target, value, updatevar, res): # -> None:
        ...
    
    def op_DICT_UPDATE(self, inst, target, value, updatevar, res): # -> None:
        ...
    
    def op_BUILD_MAP(self, inst, items, size, res): # -> None:
        ...
    
    def op_STORE_MAP(self, inst, dct, key, value): # -> None:
        ...
    
    def op_UNARY_NEGATIVE(self, inst, value, res):
        ...
    
    def op_UNARY_POSITIVE(self, inst, value, res):
        ...
    
    def op_UNARY_INVERT(self, inst, value, res):
        ...
    
    def op_UNARY_NOT(self, inst, value, res):
        ...
    
    def op_BINARY_OP(self, inst, op, lhs, rhs, res): # -> None:
        ...
    
    def op_BINARY_ADD(self, inst, lhs, rhs, res): # -> None:
        ...
    
    def op_BINARY_SUBTRACT(self, inst, lhs, rhs, res): # -> None:
        ...
    
    def op_BINARY_MULTIPLY(self, inst, lhs, rhs, res): # -> None:
        ...
    
    def op_BINARY_DIVIDE(self, inst, lhs, rhs, res): # -> None:
        ...
    
    def op_BINARY_TRUE_DIVIDE(self, inst, lhs, rhs, res): # -> None:
        ...
    
    def op_BINARY_FLOOR_DIVIDE(self, inst, lhs, rhs, res): # -> None:
        ...
    
    def op_BINARY_MODULO(self, inst, lhs, rhs, res): # -> None:
        ...
    
    def op_BINARY_POWER(self, inst, lhs, rhs, res): # -> None:
        ...
    
    def op_BINARY_MATRIX_MULTIPLY(self, inst, lhs, rhs, res): # -> None:
        ...
    
    def op_BINARY_LSHIFT(self, inst, lhs, rhs, res): # -> None:
        ...
    
    def op_BINARY_RSHIFT(self, inst, lhs, rhs, res): # -> None:
        ...
    
    def op_BINARY_AND(self, inst, lhs, rhs, res): # -> None:
        ...
    
    def op_BINARY_OR(self, inst, lhs, rhs, res): # -> None:
        ...
    
    def op_BINARY_XOR(self, inst, lhs, rhs, res): # -> None:
        ...
    
    def op_INPLACE_ADD(self, inst, lhs, rhs, res): # -> None:
        ...
    
    def op_INPLACE_SUBTRACT(self, inst, lhs, rhs, res): # -> None:
        ...
    
    def op_INPLACE_MULTIPLY(self, inst, lhs, rhs, res): # -> None:
        ...
    
    def op_INPLACE_DIVIDE(self, inst, lhs, rhs, res): # -> None:
        ...
    
    def op_INPLACE_TRUE_DIVIDE(self, inst, lhs, rhs, res): # -> None:
        ...
    
    def op_INPLACE_FLOOR_DIVIDE(self, inst, lhs, rhs, res): # -> None:
        ...
    
    def op_INPLACE_MODULO(self, inst, lhs, rhs, res): # -> None:
        ...
    
    def op_INPLACE_POWER(self, inst, lhs, rhs, res): # -> None:
        ...
    
    def op_INPLACE_MATRIX_MULTIPLY(self, inst, lhs, rhs, res): # -> None:
        ...
    
    def op_INPLACE_LSHIFT(self, inst, lhs, rhs, res): # -> None:
        ...
    
    def op_INPLACE_RSHIFT(self, inst, lhs, rhs, res): # -> None:
        ...
    
    def op_INPLACE_AND(self, inst, lhs, rhs, res): # -> None:
        ...
    
    def op_INPLACE_OR(self, inst, lhs, rhs, res): # -> None:
        ...
    
    def op_INPLACE_XOR(self, inst, lhs, rhs, res): # -> None:
        ...
    
    def op_JUMP_ABSOLUTE(self, inst): # -> None:
        ...
    
    def op_JUMP_FORWARD(self, inst): # -> None:
        ...
    
    def op_JUMP_BACKWARD(self, inst): # -> None:
        ...
    
    def op_POP_BLOCK(self, inst, kind=...): # -> None:
        ...
    
    def op_RETURN_VALUE(self, inst, retval, castval): # -> None:
        ...
    
    if PYVERSION in ((3, 12), ):
        def op_RETURN_CONST(self, inst, retval, castval): # -> None:
            ...
        
    else:
        ...
    def op_COMPARE_OP(self, inst, lhs, rhs, res): # -> None:
        ...
    
    def op_IS_OP(self, inst, lhs, rhs, res): # -> None:
        ...
    
    def op_CONTAINS_OP(self, inst, lhs, rhs, res): # -> None:
        ...
    
    def op_BREAK_LOOP(self, inst, end=...): # -> None:
        ...
    
    def op_JUMP_IF_FALSE(self, inst, pred): # -> None:
        ...
    
    def op_JUMP_IF_TRUE(self, inst, pred): # -> None:
        ...
    
    def op_POP_JUMP_FORWARD_IF_NONE(self, inst, pred): # -> None:
        ...
    
    def op_POP_JUMP_FORWARD_IF_NOT_NONE(self, inst, pred): # -> None:
        ...
    
    if PYVERSION in ((3, 12), ):
        def op_POP_JUMP_IF_NONE(self, inst, pred): # -> None:
            ...
        
        def op_POP_JUMP_IF_NOT_NONE(self, inst, pred): # -> None:
            ...
        
    else:
        ...
    def op_POP_JUMP_BACKWARD_IF_NONE(self, inst, pred): # -> None:
        ...
    
    def op_POP_JUMP_BACKWARD_IF_NOT_NONE(self, inst, pred): # -> None:
        ...
    
    def op_POP_JUMP_FORWARD_IF_FALSE(self, inst, pred): # -> None:
        ...
    
    def op_POP_JUMP_FORWARD_IF_TRUE(self, inst, pred): # -> None:
        ...
    
    def op_POP_JUMP_BACKWARD_IF_FALSE(self, inst, pred): # -> None:
        ...
    
    def op_POP_JUMP_BACKWARD_IF_TRUE(self, inst, pred): # -> None:
        ...
    
    def op_POP_JUMP_IF_FALSE(self, inst, pred): # -> None:
        ...
    
    def op_POP_JUMP_IF_TRUE(self, inst, pred): # -> None:
        ...
    
    def op_JUMP_IF_FALSE_OR_POP(self, inst, pred): # -> None:
        ...
    
    def op_JUMP_IF_TRUE_OR_POP(self, inst, pred): # -> None:
        ...
    
    def op_CHECK_EXC_MATCH(self, inst, pred, tos, tos1): # -> None:
        ...
    
    def op_JUMP_IF_NOT_EXC_MATCH(self, inst, pred, tos, tos1): # -> None:
        ...
    
    def op_RERAISE(self, inst, exc): # -> None:
        ...
    
    def op_RAISE_VARARGS(self, inst, exc): # -> None:
        ...
    
    def op_YIELD_VALUE(self, inst, value, res):
        ...
    
    def op_MAKE_FUNCTION(self, inst, name, code, closure, annotations, kwdefaults, defaults, res): # -> None:
        ...
    
    def op_MAKE_CLOSURE(self, inst, name, code, closure, annotations, kwdefaults, defaults, res): # -> None:
        ...
    
    if PYVERSION in ((3, 11), (3, 12)):
        def op_LOAD_CLOSURE(self, inst, res): # -> None:
            ...
        
    else:
        def op_LOAD_CLOSURE(self, inst, res): # -> None:
            ...
        
    def op_LIST_APPEND(self, inst, target, value, appendvar, res): # -> None:
        ...
    
    def op_LIST_EXTEND(self, inst, target, value, extendvar, res): # -> None:
        ...
    
    def op_MAP_ADD(self, inst, target, key, value, setitemvar, res): # -> None:
        ...
    
    def op_LOAD_ASSERTION_ERROR(self, inst, res): # -> None:
        ...
    
    def op_LOAD_METHOD(self, *args, **kws): # -> None:
        ...
    
    def op_CALL_METHOD(self, *args, **kws): # -> None:
        ...
    
    if PYVERSION in ((3, 12), ):
        def op_CALL_INTRINSIC_1(self, inst, operand, **kwargs): # -> None:
            ...
        
    else:
        ...


if PYVERSION in ((3, 12), ):
    class INTRINSIC_STOPITERATION_ERROR(AssertionError):
        ...
    
    
else:
    ...
