"""
This type stub file was generated by pyright.
"""

from abc import abstractmethod
from numba import _dispatcher
from numba.core import serialize, utils
from numba.core.compiler_lock import global_compiler_lock
from numba.core.retarget import BaseRetarget

class _RetargetStack(utils.ThreadLocalStack, stack_name="retarget"):
    def push(self, state): # -> None:
        ...
    
    def pop(self): # -> None:
        ...
    


class TargetConfigurationStack:
    """The target configuration stack.

    Uses the BORG pattern and stores states in threadlocal storage.

    WARNING: features associated with this class are experimental. The API
    may change without notice.
    """
    def __init__(self) -> None:
        ...
    
    def get(self): # -> Any:
        """Get the current target from the top of the stack.

        May raise IndexError if the stack is empty. Users should check the size
        of the stack beforehand.
        """
        ...
    
    def __len__(self): # -> int:
        """Size of the stack
        """
        ...
    
    @classmethod
    def switch_target(cls, retarget: BaseRetarget): # -> _GeneratorContextManager[None]:
        """Returns a contextmanager that pushes a new retarget handler,
        an instance of `numba.core.retarget.BaseRetarget`, onto the
        target-config stack for the duration of the context-manager.
        """
        ...
    


class OmittedArg:
    """
    A placeholder for omitted arguments with a default value.
    """
    def __init__(self, value) -> None:
        ...
    
    def __repr__(self): # -> LiteralString:
        ...
    


class _FunctionCompiler:
    def __init__(self, py_func, targetdescr, targetoptions, locals, pipeline_class) -> None:
        ...
    
    def fold_argument_types(self, args, kws): # -> tuple[Signature, tuple[Any, ...]]:
        """
        Given positional and named argument types, fold keyword arguments
        and resolve defaults by inserting types.Omitted() instances.

        A (pysig, argument types) tuple is returned.
        """
        ...
    
    def compile(self, args, return_type): # -> TypingError:
        ...
    
    def get_globals_for_reduction(self):
        ...
    


class _GeneratedFunctionCompiler(_FunctionCompiler):
    def __init__(self, py_func, targetdescr, targetoptions, locals, pipeline_class) -> None:
        ...
    
    def get_globals_for_reduction(self):
        ...
    


_CompileStats = ...
class CompilingCounter:
    """
    A simple counter that increment in __enter__ and decrement in __exit__.
    """
    def __init__(self) -> None:
        ...
    
    def __enter__(self): # -> None:
        ...
    
    def __exit__(self, *args, **kwargs): # -> None:
        ...
    
    def __bool__(self): # -> bool:
        ...
    
    __nonzero__ = ...


class _DispatcherBase(_dispatcher.Dispatcher):
    """
    Common base class for dispatcher Implementations.
    """
    __numba__ = ...
    def __init__(self, arg_count, py_func, pysig, can_fallback, exact_match_required) -> None:
        ...
    
    @property
    def signatures(self): # -> list[Any]:
        """
        Returns a list of compiled function signatures.
        """
        ...
    
    @property
    def nopython_signatures(self): # -> list[Any]:
        ...
    
    def disable_compile(self, val=...): # -> None:
        """Disable the compilation of new signatures at call time.
        """
        ...
    
    def add_overload(self, cres): # -> None:
        ...
    
    def fold_argument_types(self, args, kws):
        ...
    
    def get_call_template(self, args, kws): # -> tuple[Any, Any, Any, dict[Any, Any]]:
        """
        Get a typing.ConcreteTemplate for this dispatcher and the given
        *args* and *kws* types.  This allows to resolve the return type.

        A (template, pysig, args, kws) tuple is returned.
        """
        ...
    
    def get_overload(self, sig):
        """
        Return the compiled function for the given signature.
        """
        ...
    
    @property
    def is_compiling(self): # -> CompilingCounter:
        """
        Whether a specialization is currently being compiled.
        """
        ...
    
    def inspect_llvm(self, signature=...): # -> dict[Any, Any]:
        """Get the LLVM intermediate representation generated by compilation.

        Parameters
        ----------
        signature : tuple of numba types, optional
            Specify a signature for which to obtain the LLVM IR. If None, the
            IR is returned for all available signatures.

        Returns
        -------
        llvm : dict[signature, str] or str
            Either the LLVM IR string for the specified signature, or, if no
            signature was given, a dictionary mapping signatures to LLVM IR
            strings.
        """
        ...
    
    def inspect_asm(self, signature=...): # -> dict[Any, Any]:
        """Get the generated assembly code.

        Parameters
        ----------
        signature : tuple of numba types, optional
            Specify a signature for which to obtain the assembly code. If
            None, the assembly code is returned for all available signatures.

        Returns
        -------
        asm : dict[signature, str] or str
            Either the assembly code for the specified signature, or, if no
            signature was given, a dictionary mapping signatures to assembly
            code.
        """
        ...
    
    def inspect_types(self, file=..., signature=..., pretty=..., style=..., **kwargs): # -> Annotate | None:
        """Print/return Numba intermediate representation (IR)-annotated code.

        Parameters
        ----------
        file : file-like object, optional
            File to which to print. Defaults to sys.stdout if None. Must be
            None if ``pretty=True``.
        signature : tuple of numba types, optional
            Print/return the intermediate representation for only the given
            signature. If None, the IR is printed for all available signatures.
        pretty : bool, optional
            If True, an Annotate object will be returned that can render the
            IR with color highlighting in Jupyter and IPython. ``file`` must
            be None if ``pretty`` is True. Additionally, the ``pygments``
            library must be installed for ``pretty=True``.
        style : str, optional
            Choose a style for rendering. Ignored if ``pretty`` is ``False``.
            This is directly consumed by ``pygments`` formatters. To see a
            list of available styles, import ``pygments`` and run
            ``list(pygments.styles.get_all_styles())``.

        Returns
        -------
        annotated : Annotate object, optional
            Only returned if ``pretty=True``, otherwise this function is only
            used for its printing side effect. If ``pretty=True``, an Annotate
            object is returned that can render itself in Jupyter and IPython.
        """
        ...
    
    def inspect_cfg(self, signature=..., show_wrapper=..., **kwargs): # -> dict[Any, Any]:
        """
        For inspecting the CFG of the function.

        By default the CFG of the user function is shown.  The *show_wrapper*
        option can be set to "python" or "cfunc" to show the python wrapper
        function or the *cfunc* wrapper function, respectively.

        Parameters accepted in kwargs
        -----------------------------
        filename : string, optional
            the name of the output file, if given this will write the output to
            filename
        view : bool, optional
            whether to immediately view the optional output file
        highlight : bool, set, dict, optional
            what, if anything, to highlight, options are:
            { incref : bool, # highlight NRT_incref calls
              decref : bool, # highlight NRT_decref calls
              returns : bool, # highlight exits which are normal returns
              raises : bool, # highlight exits which are from raise
              meminfo : bool, # highlight calls to NRT*meminfo
              branches : bool, # highlight true/false branches
             }
            Default is True which sets all of the above to True. Supplying a set
            of strings is also accepted, these are interpreted as key:True with
            respect to the above dictionary. e.g. {'incref', 'decref'} would
            switch on highlighting on increfs and decrefs.
        interleave: bool, set, dict, optional
            what, if anything, to interleave in the LLVM IR, options are:
            { python: bool # interleave python source code with the LLVM IR
              lineinfo: bool # interleave line information markers with the LLVM
                             # IR
            }
            Default is True which sets all of the above to True. Supplying a set
            of strings is also accepted, these are interpreted as key:True with
            respect to the above dictionary. e.g. {'python',} would
            switch on interleaving of python source code in the LLVM IR.
        strip_ir : bool, optional
            Default is False. If set to True all LLVM IR that is superfluous to
            that requested in kwarg `highlight` will be removed.
        show_key : bool, optional
            Default is True. Create a "key" for the highlighting in the rendered
            CFG.
        fontsize : int, optional
            Default is 8. Set the fontsize in the output to this value.
        """
        ...
    
    def inspect_disasm_cfg(self, signature=...): # -> dict[Any, Any]:
        """
        For inspecting the CFG of the disassembly of the function.

        Requires python package: r2pipe
        Requires radare2 binary on $PATH.
        Notebook rendering requires python package: graphviz

        signature : tuple of Numba types, optional
            Print/return the disassembly CFG for only the given signatures.
            If None, the IR is printed for all available signatures.
        """
        ...
    
    def get_annotation_info(self, signature=...): # -> OrderedDict[Any, Any]:
        """
        Gets the annotation information for the function specified by
        signature. If no signature is supplied a dictionary of signature to
        annotation information is returned.
        """
        ...
    
    def __repr__(self): # -> LiteralString:
        ...
    
    def typeof_pyval(self, val): # -> PyObject | Buffer | Any | ExternalFunctionPointer | Opaque:
        """
        Resolve the Numba type of Python value *val*.
        This is called from numba._dispatcher as a fallback if the native code
        cannot decide the type.
        """
        ...
    


class _MemoMixin:
    __uuid = ...
    _memo = ...
    _recent = ...


class Dispatcher(serialize.ReduceMixin, _MemoMixin, _DispatcherBase):
    """
    Implementation of user-facing dispatcher objects (i.e. created using
    the @jit decorator).
    This is an abstract base class. Subclasses should define the targetdescr
    class attribute.
    """
    _fold_args = ...
    __numba__ = ...
    def __init__(self, py_func, locals=..., targetoptions=..., pipeline_class=...) -> None:
        """
        Parameters
        ----------
        py_func: function object to be compiled
        locals: dict, optional
            Mapping of local variable names to Numba types.  Used to override
            the types deduced by the type inference engine.
        targetoptions: dict, optional
            Target-specific config options.
        pipeline_class: type numba.compiler.CompilerBase
            The compiler pipeline type.
        """
        ...
    
    def dump(self, tab=...): # -> None:
        ...
    
    def enable_caching(self): # -> None:
        ...
    
    def __get__(self, obj, objtype=...): # -> Self | MethodType:
        '''Allow a JIT function to be bound as a method to an object'''
        ...
    
    def compile(self, sig): # -> Any | None:
        ...
    
    def get_compile_result(self, sig):
        """Compile (if needed) and return the compilation result with the
        given signature.

        Returns ``CompileResult``.
        Raises ``NumbaError`` if the signature is incompatible.
        """
        ...
    
    def recompile(self): # -> None:
        """
        Recompile all signatures afresh.
        """
        ...
    
    @property
    def stats(self): # -> _CompileStats:
        ...
    
    def parallel_diagnostics(self, signature=..., level=...): # -> None:
        """
        Print parallel diagnostic information for the given signature. If no
        signature is present it is printed for all known signatures. level is
        used to adjust the verbosity, level=1 (default) is minimal verbosity,
        and 2, 3, and 4 provide increasing levels of verbosity.
        """
        ...
    
    def get_metadata(self, signature=...): # -> dict[Any, Any]:
        """
        Obtain the compilation metadata for a given signature.
        """
        ...
    
    def get_function_type(self): # -> FunctionType | None:
        """Return unique function type of dispatcher when possible, otherwise
        return None.

        A Dispatcher instance has unique function type when it
        contains exactly one compilation result and its compilation
        has been disabled (via its disable_compile method).
        """
        ...
    


class LiftedCode(serialize.ReduceMixin, _MemoMixin, _DispatcherBase):
    """
    Implementation of the hidden dispatcher objects used for lifted code
    (a lifted loop is really compiled as a separate function).
    """
    _fold_args = ...
    can_cache = ...
    def __init__(self, func_ir, typingctx, targetctx, flags, locals) -> None:
        ...
    
    def get_source_location(self):
        """Return the starting line number of the loop.
        """
        ...
    
    @abstractmethod
    def compile(self, sig): # -> None:
        """Lifted code should implement a compilation method that will return
        a CompileResult.entry_point for the given signature."""
        ...
    


class LiftedLoop(LiftedCode):
    def compile(self, sig): # -> None:
        ...
    


class LiftedWith(LiftedCode):
    can_cache = ...
    def get_call_template(self, args, kws): # -> tuple[Any, None, Any, Any]:
        """
        Get a typing.ConcreteTemplate for this dispatcher and the given
        *args* and *kws* types.  This enables the resolving of the return type.

        A (template, pysig, args, kws) tuple is returned.
        """
        ...
    
    def compile(self, sig): # -> None:
        ...
    


class ObjModeLiftedWith(LiftedWith):
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def get_call_template(self, args, kws): # -> tuple[Any, None, list[Opaque], Any]:
        """
        Get a typing.ConcreteTemplate for this dispatcher and the given
        *args* and *kws* types.  This enables the resolving of the return type.

        A (template, pysig, args, kws) tuple is returned.
        """
        ...
    
    @global_compiler_lock
    def compile(self, sig): # -> None:
        ...
    


