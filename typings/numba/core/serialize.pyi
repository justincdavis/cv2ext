"""
This type stub file was generated by pyright.
"""

import abc
from numba import cloudpickle

"""
Serialization support for compiled functions.
"""
_unpickled_memo = ...
def dumps(obj): # -> bytes:
    """Similar to `pickle.dumps()`. Returns the serialized object in bytes.
    """
    ...

def runtime_build_excinfo_struct(static_exc, exc_args): # -> tuple[Any, tuple[Any, ...], Any]:
    ...

loads = ...
class _CustomPickled:
    """A wrapper for objects that must be pickled with `NumbaPickler`.

    Standard `pickle` will pick up the implementation registered via `copyreg`.
    This will spawn a `NumbaPickler` instance to serialize the data.

    `NumbaPickler` overrides the handling of this type so as not to spawn a
    new pickler for the object when it is already being pickled by a
    `NumbaPickler`.
    """
    __slots__ = ...
    def __init__(self, ctor, states) -> None:
        ...
    


def custom_reduce(cls, states): # -> tuple[Callable[..., Any], tuple[_CustomPickled]]:
    """For customizing object serialization in `__reduce__`.

    Object states provided here are used as keyword arguments to the
    `._rebuild()` class method.

    Parameters
    ----------
    states : dict
        Dictionary of object states to be serialized.

    Returns
    -------
    result : tuple
        This tuple conforms to the return type requirement for `__reduce__`.
    """
    ...

def custom_rebuild(custom_pickled):
    """Customized object deserialization.

    This function is referenced internally by `custom_reduce()`.
    """
    ...

def is_serialiable(obj): # -> bool:
    """Check if *obj* can be serialized.

    Parameters
    ----------
    obj : object

    Returns
    --------
    can_serialize : bool
    """
    ...

def disable_pickling(typ):
    """This is called on a type to disable pickling
    """
    ...

class NumbaPickler(cloudpickle.CloudPickler):
    disabled_types = ...
    def reducer_override(self, obj): # -> tuple[type[type], tuple[None]] | tuple[type[type], tuple[ellipsis]] | tuple[type[type], tuple[_NotImplementedType]] | tuple[Callable[..., type[type] | Any], tuple[Any]] | tuple[Callable[..., Any], tuple[tuple[type, ...], str, str, dict[str, Any], str, str | Any, None], tuple[dict[Any, Any], dict[Any, Any]], None, None, Callable[..., Any]] | tuple[Callable[..., Any | type], tuple[Any, Any, Any, dict[Any, Any], str | Any, None], tuple[dict[Any, Any], dict[Any, Any]], None, None, Callable[..., Any]] | _NotImplementedType | tuple[Callable[..., FunctionType], tuple[Any, Any, None, None, tuple[_Cell | Any, ...] | None], tuple[Any, dict[str, Any]], None, None, Callable[..., None]]:
        ...
    


class ReduceMixin(abc.ABC):
    """A mixin class for objects that should be reduced by the NumbaPickler
    instead of the standard pickler.
    """
    def __reduce__(self): # -> tuple[Callable[..., Any], tuple[_CustomPickled]]:
        ...
    


class PickleCallableByPath:
    """Wrap a callable object to be pickled by path to workaround limitation
    in pickling due to non-pickleable objects in function non-locals.

    Note:
    - Do not use this as a decorator.
    - Wrapped object must be a global that exist in its parent module and it
      can be imported by `from the_module import the_object`.

    Usage:

    >>> def my_fn(x):
    >>>     ...
    >>> wrapped_fn = PickleCallableByPath(my_fn)
    >>> # refer to `wrapped_fn` instead of `my_fn`
    """
    def __init__(self, fn) -> None:
        ...
    
    def __call__(self, *args, **kwargs):
        ...
    
    def __reduce__(self): # -> tuple[Callable[..., Self], tuple[Any, Any]]:
        ...
    


