"""
This type stub file was generated by pyright.
"""

from functools import total_ordering
from numba.core.utils import PYVERSION
from enum import Enum

"""
Implement python 3.8+ bytecode analysis
"""
_logger = ...
_EXCEPT_STACK_OFFSET = ...
_FINALLY_POP = ...
_NO_RAISE_OPS = ...
if PYVERSION in ((3, 12), ):
    class CALL_INTRINSIC_1_Operand(Enum):
        INTRINSIC_STOPITERATION_ERROR = ...
        UNARY_POSITIVE = ...
        INTRINSIC_LIST_TO_TUPLE = ...
    
    
    ci1op = CALL_INTRINSIC_1_Operand
else:
    ...
@total_ordering
class BlockKind:
    """Kinds of block to make related code safer than just `str`.
    """
    _members = ...
    def __init__(self, value) -> None:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __lt__(self, other) -> bool:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __repr__(self): # -> LiteralString:
        ...
    


class _lazy_pformat:
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    


class Flow:
    """Data+Control Flow analysis.

    Simulate execution to recover dataflow and controlflow information.
    """
    def __init__(self, bytecode) -> None:
        ...
    
    def run(self): # -> None:
        """Run a trace over the bytecode over all reachable path.

        The trace starts at bytecode offset 0 and gathers stack and control-
        flow information by partially interpreting each bytecode.
        Each ``State`` instance in the trace corresponds to a basic-block.
        The State instances forks when a jump instruction is encountered.
        A newly forked state is then added to the list of pending states.
        The trace ends when there are no more pending states.
        """
        ...
    
    if PYVERSION in ((3, 11), (3, 12)):
        ...
    else:
        ...


class TraceRunner:
    """Trace runner contains the states for the trace and the opcode dispatch.
    """
    def __init__(self, debug_filename) -> None:
        ...
    
    def get_debug_loc(self, lineno): # -> Loc:
        ...
    
    def dispatch(self, state): # -> None:
        ...
    
    def op_NOP(self, state, inst): # -> None:
        ...
    
    def op_RESUME(self, state, inst): # -> None:
        ...
    
    def op_CACHE(self, state, inst): # -> None:
        ...
    
    def op_PRECALL(self, state, inst): # -> None:
        ...
    
    def op_PUSH_NULL(self, state, inst): # -> None:
        ...
    
    def op_RETURN_GENERATOR(self, state, inst): # -> None:
        ...
    
    def op_FORMAT_VALUE(self, state, inst): # -> None:
        """
        FORMAT_VALUE(flags): flags argument specifies format spec which is
        not supported yet. Currently, we just call str() on the value.
        Pops a value from stack and pushes results back.
        Required for supporting f-strings.
        https://docs.python.org/3/library/dis.html#opcode-FORMAT_VALUE
        """
        ...
    
    def op_BUILD_STRING(self, state, inst): # -> None:
        """
        BUILD_STRING(count): Concatenates count strings from the stack and
        pushes the resulting string onto the stack.
        Required for supporting f-strings.
        https://docs.python.org/3/library/dis.html#opcode-BUILD_STRING
        """
        ...
    
    def op_POP_TOP(self, state, inst): # -> None:
        ...
    
    if PYVERSION in ((3, 11), (3, 12)):
        def op_LOAD_GLOBAL(self, state, inst): # -> None:
            ...
        
    else:
        def op_LOAD_GLOBAL(self, state, inst): # -> None:
            ...
        
    def op_COPY_FREE_VARS(self, state, inst): # -> None:
        ...
    
    def op_MAKE_CELL(self, state, inst): # -> None:
        ...
    
    def op_LOAD_DEREF(self, state, inst): # -> None:
        ...
    
    def op_LOAD_CONST(self, state, inst): # -> None:
        ...
    
    def op_LOAD_ATTR(self, state, inst): # -> None:
        ...
    
    def op_LOAD_FAST(self, state, inst): # -> None:
        ...
    
    if PYVERSION in ((3, 12), ):
        op_LOAD_FAST_CHECK = ...
        op_LOAD_FAST_AND_CLEAR = ...
    else:
        ...
    def op_DELETE_FAST(self, state, inst): # -> None:
        ...
    
    def op_DELETE_ATTR(self, state, inst): # -> None:
        ...
    
    def op_STORE_ATTR(self, state, inst): # -> None:
        ...
    
    def op_STORE_DEREF(self, state, inst): # -> None:
        ...
    
    def op_STORE_FAST(self, state, inst): # -> None:
        ...
    
    def op_SLICE_1(self, state, inst): # -> None:
        """
        TOS = TOS1[TOS:]
        """
        ...
    
    def op_SLICE_2(self, state, inst): # -> None:
        """
        TOS = TOS1[:TOS]
        """
        ...
    
    def op_SLICE_3(self, state, inst): # -> None:
        """
        TOS = TOS2[TOS1:TOS]
        """
        ...
    
    def op_STORE_SLICE_0(self, state, inst): # -> None:
        """
        TOS[:] = TOS1
        """
        ...
    
    def op_STORE_SLICE_1(self, state, inst): # -> None:
        """
        TOS1[TOS:] = TOS2
        """
        ...
    
    def op_STORE_SLICE_2(self, state, inst): # -> None:
        """
        TOS1[:TOS] = TOS2
        """
        ...
    
    def op_STORE_SLICE_3(self, state, inst): # -> None:
        """
        TOS2[TOS1:TOS] = TOS3
        """
        ...
    
    def op_DELETE_SLICE_0(self, state, inst): # -> None:
        """
        del TOS[:]
        """
        ...
    
    def op_DELETE_SLICE_1(self, state, inst): # -> None:
        """
        del TOS1[TOS:]
        """
        ...
    
    def op_DELETE_SLICE_2(self, state, inst): # -> None:
        """
        del TOS1[:TOS]
        """
        ...
    
    def op_DELETE_SLICE_3(self, state, inst): # -> None:
        """
        del TOS2[TOS1:TOS]
        """
        ...
    
    def op_BUILD_SLICE(self, state, inst): # -> None:
        """
        slice(TOS1, TOS) or slice(TOS2, TOS1, TOS)
        """
        ...
    
    if PYVERSION in ((3, 12), ):
        def op_BINARY_SLICE(self, state, inst): # -> None:
            ...
        
    else:
        ...
    if PYVERSION in ((3, 12), ):
        def op_STORE_SLICE(self, state, inst): # -> None:
            ...
        
    else:
        ...
    op_POP_JUMP_IF_TRUE = ...
    op_POP_JUMP_IF_FALSE = ...
    if PYVERSION in ((3, 12), ):
        op_POP_JUMP_IF_NONE = ...
        op_POP_JUMP_IF_NOT_NONE = ...
    else:
        ...
    op_JUMP_IF_FALSE_OR_POP = ...
    op_JUMP_IF_TRUE_OR_POP = ...
    def op_POP_JUMP_FORWARD_IF_NONE(self, state, inst): # -> None:
        ...
    
    def op_POP_JUMP_FORWARD_IF_NOT_NONE(self, state, inst): # -> None:
        ...
    
    def op_POP_JUMP_BACKWARD_IF_NONE(self, state, inst): # -> None:
        ...
    
    def op_POP_JUMP_BACKWARD_IF_NOT_NONE(self, state, inst): # -> None:
        ...
    
    def op_POP_JUMP_FORWARD_IF_FALSE(self, state, inst): # -> None:
        ...
    
    def op_POP_JUMP_FORWARD_IF_TRUE(self, state, inst): # -> None:
        ...
    
    def op_POP_JUMP_BACKWARD_IF_FALSE(self, state, inst): # -> None:
        ...
    
    def op_POP_JUMP_BACKWARD_IF_TRUE(self, state, inst): # -> None:
        ...
    
    def op_JUMP_FORWARD(self, state, inst): # -> None:
        ...
    
    def op_JUMP_BACKWARD(self, state, inst): # -> None:
        ...
    
    def op_JUMP_ABSOLUTE(self, state, inst): # -> None:
        ...
    
    def op_BREAK_LOOP(self, state, inst): # -> None:
        ...
    
    def op_RETURN_VALUE(self, state, inst): # -> None:
        ...
    
    if PYVERSION in ((3, 12), ):
        def op_RETURN_CONST(self, state, inst): # -> None:
            ...
        
    else:
        ...
    def op_YIELD_VALUE(self, state, inst): # -> None:
        ...
    
    if PYVERSION in ((3, 11), (3, 12)):
        def op_RAISE_VARARGS(self, state, inst): # -> None:
            ...
        
    else:
        def op_RAISE_VARARGS(self, state, inst): # -> None:
            ...
        
    def op_BEGIN_FINALLY(self, state, inst): # -> None:
        ...
    
    def op_END_FINALLY(self, state, inst): # -> None:
        ...
    
    if PYVERSION in ((3, 12), ):
        def op_END_FOR(self, state, inst): # -> None:
            ...
        
    else:
        ...
    def op_POP_FINALLY(self, state, inst): # -> None:
        ...
    
    def op_CALL_FINALLY(self, state, inst): # -> None:
        ...
    
    def op_WITH_EXCEPT_START(self, state, inst): # -> None:
        ...
    
    def op_WITH_CLEANUP_START(self, state, inst): # -> None:
        ...
    
    def op_WITH_CLEANUP_FINISH(self, state, inst): # -> None:
        ...
    
    def op_SETUP_LOOP(self, state, inst): # -> None:
        ...
    
    def op_BEFORE_WITH(self, state, inst): # -> None:
        ...
    
    def op_SETUP_WITH(self, state, inst): # -> None:
        ...
    
    def op_PUSH_EXC_INFO(self, state, inst): # -> None:
        ...
    
    def op_SETUP_FINALLY(self, state, inst): # -> None:
        ...
    
    if PYVERSION in ((3, 11), (3, 12)):
        def op_POP_EXCEPT(self, state, inst): # -> None:
            ...
        
    else:
        def op_POP_EXCEPT(self, state, inst): # -> None:
            ...
        
    def op_POP_BLOCK(self, state, inst): # -> None:
        ...
    
    def op_BINARY_SUBSCR(self, state, inst): # -> None:
        ...
    
    def op_STORE_SUBSCR(self, state, inst): # -> None:
        ...
    
    def op_DELETE_SUBSCR(self, state, inst): # -> None:
        ...
    
    def op_CALL(self, state, inst): # -> None:
        ...
    
    def op_KW_NAMES(self, state, inst): # -> None:
        ...
    
    def op_CALL_FUNCTION(self, state, inst): # -> None:
        ...
    
    def op_CALL_FUNCTION_KW(self, state, inst): # -> None:
        ...
    
    def op_CALL_FUNCTION_EX(self, state, inst): # -> None:
        ...
    
    if PYVERSION in ((3, 12), ):
        def op_CALL_INTRINSIC_1(self, state, inst): # -> None:
            ...
        
    else:
        ...
    def op_DUP_TOPX(self, state, inst): # -> None:
        ...
    
    def op_DUP_TOP(self, state, inst): # -> None:
        ...
    
    def op_DUP_TOP_TWO(self, state, inst): # -> None:
        ...
    
    def op_COPY(self, state, inst): # -> None:
        ...
    
    def op_SWAP(self, state, inst): # -> None:
        ...
    
    def op_ROT_TWO(self, state, inst): # -> None:
        ...
    
    def op_ROT_THREE(self, state, inst): # -> None:
        ...
    
    def op_ROT_FOUR(self, state, inst): # -> None:
        ...
    
    def op_UNPACK_SEQUENCE(self, state, inst): # -> None:
        ...
    
    def op_BUILD_TUPLE(self, state, inst): # -> None:
        ...
    
    def op_BUILD_TUPLE_UNPACK_WITH_CALL(self, state, inst): # -> None:
        ...
    
    def op_BUILD_TUPLE_UNPACK(self, state, inst): # -> None:
        ...
    
    def op_LIST_TO_TUPLE(self, state, inst): # -> None:
        ...
    
    def op_BUILD_CONST_KEY_MAP(self, state, inst): # -> None:
        ...
    
    def op_BUILD_LIST(self, state, inst): # -> None:
        ...
    
    def op_LIST_APPEND(self, state, inst): # -> None:
        ...
    
    def op_LIST_EXTEND(self, state, inst): # -> None:
        ...
    
    def op_BUILD_MAP(self, state, inst): # -> None:
        ...
    
    def op_MAP_ADD(self, state, inst): # -> None:
        ...
    
    def op_BUILD_SET(self, state, inst): # -> None:
        ...
    
    def op_SET_UPDATE(self, state, inst): # -> None:
        ...
    
    def op_DICT_UPDATE(self, state, inst): # -> None:
        ...
    
    def op_GET_ITER(self, state, inst): # -> None:
        ...
    
    def op_FOR_ITER(self, state, inst): # -> None:
        ...
    
    def op_GEN_START(self, state, inst): # -> None:
        """Pops TOS. If TOS was not None, raises an exception. The kind
        operand corresponds to the type of generator or coroutine and
        determines the error message. The legal kinds are 0 for generator,
        1 for coroutine, and 2 for async generator.

        New in version 3.10.
        """
        ...
    
    def op_BINARY_OP(self, state, inst): # -> None:
        ...
    
    op_UNARY_NEGATIVE = ...
    op_UNARY_POSITIVE = ...
    op_UNARY_NOT = ...
    op_UNARY_INVERT = ...
    op_COMPARE_OP = ...
    op_IS_OP = ...
    op_CONTAINS_OP = ...
    op_INPLACE_ADD = ...
    op_INPLACE_SUBTRACT = ...
    op_INPLACE_MULTIPLY = ...
    op_INPLACE_DIVIDE = ...
    op_INPLACE_TRUE_DIVIDE = ...
    op_INPLACE_FLOOR_DIVIDE = ...
    op_INPLACE_MODULO = ...
    op_INPLACE_POWER = ...
    op_INPLACE_MATRIX_MULTIPLY = ...
    op_INPLACE_LSHIFT = ...
    op_INPLACE_RSHIFT = ...
    op_INPLACE_AND = ...
    op_INPLACE_OR = ...
    op_INPLACE_XOR = ...
    op_BINARY_ADD = ...
    op_BINARY_SUBTRACT = ...
    op_BINARY_MULTIPLY = ...
    op_BINARY_DIVIDE = ...
    op_BINARY_TRUE_DIVIDE = ...
    op_BINARY_FLOOR_DIVIDE = ...
    op_BINARY_MODULO = ...
    op_BINARY_POWER = ...
    op_BINARY_MATRIX_MULTIPLY = ...
    op_BINARY_LSHIFT = ...
    op_BINARY_RSHIFT = ...
    op_BINARY_AND = ...
    op_BINARY_OR = ...
    op_BINARY_XOR = ...
    def op_MAKE_FUNCTION(self, state, inst, MAKE_CLOSURE=...): # -> None:
        ...
    
    def op_MAKE_CLOSURE(self, state, inst): # -> None:
        ...
    
    def op_LOAD_CLOSURE(self, state, inst): # -> None:
        ...
    
    def op_LOAD_ASSERTION_ERROR(self, state, inst): # -> None:
        ...
    
    def op_CHECK_EXC_MATCH(self, state, inst): # -> None:
        ...
    
    def op_JUMP_IF_NOT_EXC_MATCH(self, state, inst): # -> None:
        ...
    
    if PYVERSION in ((3, 11), (3, 12)):
        def op_RERAISE(self, state, inst): # -> None:
            ...
        
    else:
        def op_RERAISE(self, state, inst): # -> None:
            ...
        
    if PYVERSION in ((3, 12), ):
        ...
    else:
        def op_LOAD_METHOD(self, state, inst): # -> None:
            ...
        
    def op_CALL_METHOD(self, state, inst): # -> None:
        ...
    


@total_ordering
class _State:
    """State of the trace
    """
    def __init__(self, bytecode, pc, nstack, blockstack, nullvals=...) -> None:
        """
        Parameters
        ----------
        bytecode : numba.bytecode.ByteCode
            function bytecode
        pc : int
            program counter
        nstack : int
            stackdepth at entry
        blockstack : Sequence[Dict]
            A sequence of dictionary denoting entries on the blockstack.
        """
        ...
    
    def __repr__(self): # -> LiteralString:
        ...
    
    def get_identity(self): # -> tuple[Any, Any]:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __lt__(self, other) -> bool:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    @property
    def pc_initial(self): # -> Any:
        """The starting bytecode offset of this State.
        The PC given to the constructor.
        """
        ...
    
    @property
    def instructions(self): # -> list[Any]:
        """The list of instructions information as a 2-tuple of
        ``(pc : int, register_map : Dict)``
        """
        ...
    
    @property
    def outgoing_edges(self): # -> list[Any]:
        """The list of outgoing edges.

        Returns
        -------
        edges : List[State]
        """
        ...
    
    @property
    def outgoing_phis(self): # -> UniqueDict:
        """The dictionary of outgoing phi nodes.

        The keys are the name of the PHI nodes.
        The values are the outgoing states.
        """
        ...
    
    @property
    def blockstack_initial(self): # -> tuple[Any, ...]:
        """A copy of the initial state of the blockstack
        """
        ...
    
    @property
    def stack_depth(self): # -> int:
        """The current size of the stack

        Returns
        -------
        res : int
        """
        ...
    
    def find_initial_try_block(self): # -> None:
        """Find the initial *try* block.
        """
        ...
    
    def has_terminated(self): # -> bool:
        ...
    
    def get_inst(self):
        ...
    
    def advance_pc(self): # -> None:
        ...
    
    def make_temp(self, prefix=...): # -> str:
        ...
    
    def append(self, inst, **kwargs): # -> None:
        """Append new inst"""
        ...
    
    def get_tos(self):
        ...
    
    def peek(self, k):
        """Return the k'th element on the stack
        """
        ...
    
    def push(self, item): # -> None:
        """Push to stack"""
        ...
    
    def pop(self):
        """Pop the stack"""
        ...
    
    def swap(self, idx): # -> None:
        """Swap stack[idx] with the tos"""
        ...
    
    def push_block(self, synblk): # -> None:
        """Push a block to blockstack
        """
        ...
    
    def reset_stack(self, depth): # -> list[Any]:
        """Reset the stack to the given stack depth.
        Returning the popped items.
        """
        ...
    
    def make_block(self, kind, end, reset_stack=..., handler=...): # -> dict[str, Any]:
        """Make a new block
        """
        ...
    
    def pop_block(self):
        """Pop a block and unwind the stack
        """
        ...
    
    def pop_block_and_above(self, blk): # -> None:
        """Find *blk* in the blockstack and remove it and all blocks above it
        from the stack.
        """
        ...
    
    def get_top_block(self, kind): # -> None:
        """Find the first block that matches *kind*
        """
        ...
    
    def get_top_block_either(self, *kinds): # -> None:
        """Find the first block that matches *kind*
        """
        ...
    
    def has_active_try(self): # -> bool:
        """Returns a boolean indicating if the top-block is a *try* block
        """
        ...
    
    def get_varname(self, inst):
        """Get referenced variable name from the oparg
        """
        ...
    
    def terminate(self): # -> None:
        """Mark block as terminated
        """
        ...
    
    def fork(self, pc, npop=..., npush=..., extra_block=...): # -> None:
        """Fork the state
        """
        ...
    
    def split_new_block(self): # -> None:
        """Split the state
        """
        ...
    
    def get_outgoing_states(self): # -> list[Any]:
        """Get states for each outgoing edges
        """
        ...
    
    def get_outgoing_edgepushed(self): # -> dict[Any, tuple[Any, ...]]:
        """
        Returns
        -------
        Dict[int, int]
            where keys are the PC
            values are the edge-pushed stack values
        """
        ...
    


class StatePy311(_State):
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def pop_kw_names(self): # -> None:
        ...
    
    def set_kw_names(self, val): # -> None:
        ...
    
    def is_in_exception(self): # -> bool:
        ...
    
    def get_exception(self):
        ...
    
    def in_with(self): # -> Literal[True] | None:
        ...
    
    def make_null(self): # -> str:
        ...
    


if PYVERSION >= (3, 11):
    State = ...
else:
    State = ...
Edge = ...
class AdaptDFA:
    """Adapt Flow to the old DFA class expected by Interpreter
    """
    def __init__(self, flow) -> None:
        ...
    
    @property
    def infos(self):
        ...
    


AdaptBlockInfo = ...
def adapt_state_infos(state): # -> AdaptBlockInfo:
    ...

class AdaptCFA:
    """Adapt Flow to the old CFA class expected by Interpreter
    """
    def __init__(self, flow) -> None:
        ...
    
    @property
    def graph(self):
        ...
    
    @property
    def backbone(self):
        ...
    
    @property
    def blocks(self): # -> dict[Any, Any]:
        ...
    
    def iterliveblocks(self): # -> Generator[Any, Any, None]:
        ...
    
    def dump(self): # -> None:
        ...
    


class AdaptCFBlock:
    def __init__(self, blockinfo, offset) -> None:
        ...
    


