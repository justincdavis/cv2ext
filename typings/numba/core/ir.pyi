"""
This type stub file was generated by pyright.
"""

from functools import total_ordering

_termcolor = ...
class Loc:
    """Source location

    """
    _defmatcher = ...
    def __init__(self, filename, line, col=..., maybe_decorator=...) -> None:
        """ Arguments:
        filename - name of the file
        line - line in file
        col - column
        maybe_decorator - Set to True if location is likely a jit decorator
        """
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    @classmethod
    def from_function_id(cls, func_id): # -> Self:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __str__(self) -> str:
        ...
    
    def get_lines(self): # -> list[str]:
        ...
    
    def strformat(self, nlines_up=...):
        ...
    
    def with_lineno(self, line, col=...): # -> Self:
        """
        Return a new Loc with this line number.
        """
        ...
    
    def short(self): # -> LiteralString:
        """
        Returns a short string
        """
        ...
    


unknown_loc = ...
@total_ordering
class SlotEqualityCheckMixin:
    __slots__ = ...
    def __eq__(self, other) -> bool:
        ...
    
    def __le__(self, other) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    


@total_ordering
class EqualityCheckMixin:
    """ Mixin for basic equality checking """
    def __eq__(self, other) -> bool:
        ...
    
    def __le__(self, other) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    


class VarMap:
    def __init__(self) -> None:
        ...
    
    def define(self, name, var): # -> None:
        ...
    
    def get(self, name):
        ...
    
    def __contains__(self, name): # -> bool:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __iter__(self):
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    


class AbstractRHS:
    """Abstract base class for anything that can be the RHS of an assignment.
    This class **does not** define any methods.
    """
    ...


class Inst(EqualityCheckMixin, AbstractRHS):
    """
    Base class for all IR instructions.
    """
    def list_vars(self):
        """
        List the variables used (read or written) by the instruction.
        """
        ...
    


class Stmt(Inst):
    """
    Base class for IR statements (instructions which can appear on their
    own in a Block).
    """
    is_terminator = ...
    is_exit = ...
    def list_vars(self): # -> list[Var] | list[Any]:
        ...
    


class Terminator(Stmt):
    """
    IR statements that are terminators: the last statement in a block.
    A terminator must either:
    - exit the function
    - jump to a block

    All subclass of Terminator must override `.get_targets()` to return a list
    of jump targets.
    """
    is_terminator = ...
    def get_targets(self):
        ...
    


class Expr(Inst):
    """
    An IR expression (an instruction which can only be part of a larger
    statement).
    """
    def __init__(self, op, loc, **kws) -> None:
        ...
    
    def __getattr__(self, name):
        ...
    
    def __setattr__(self, name, value): # -> None:
        ...
    
    @classmethod
    def binop(cls, fn, lhs, rhs, loc): # -> Self:
        ...
    
    @classmethod
    def inplace_binop(cls, fn, immutable_fn, lhs, rhs, loc): # -> Self:
        ...
    
    @classmethod
    def unary(cls, fn, value, loc): # -> Self:
        ...
    
    @classmethod
    def call(cls, func, args, kws, loc, vararg=..., varkwarg=..., target=...): # -> Self:
        ...
    
    @classmethod
    def build_tuple(cls, items, loc): # -> Self:
        ...
    
    @classmethod
    def build_list(cls, items, loc): # -> Self:
        ...
    
    @classmethod
    def build_set(cls, items, loc): # -> Self:
        ...
    
    @classmethod
    def build_map(cls, items, size, literal_value, value_indexes, loc): # -> Self:
        ...
    
    @classmethod
    def pair_first(cls, value, loc): # -> Self:
        ...
    
    @classmethod
    def pair_second(cls, value, loc): # -> Self:
        ...
    
    @classmethod
    def getiter(cls, value, loc): # -> Self:
        ...
    
    @classmethod
    def iternext(cls, value, loc): # -> Self:
        ...
    
    @classmethod
    def exhaust_iter(cls, value, count, loc): # -> Self:
        ...
    
    @classmethod
    def getattr(cls, value, attr, loc): # -> Self:
        ...
    
    @classmethod
    def getitem(cls, value, index, loc): # -> Self:
        ...
    
    @classmethod
    def typed_getitem(cls, value, dtype, index, loc): # -> Self:
        ...
    
    @classmethod
    def static_getitem(cls, value, index, index_var, loc): # -> Self:
        ...
    
    @classmethod
    def cast(cls, value, loc): # -> Self:
        """
        A node for implicit casting at the return statement
        """
        ...
    
    @classmethod
    def phi(cls, loc): # -> Self:
        """Phi node
        """
        ...
    
    @classmethod
    def make_function(cls, name, code, closure, defaults, loc): # -> Self:
        """
        A node for making a function object.
        """
        ...
    
    @classmethod
    def null(cls, loc): # -> Self:
        """
        A node for null value.

        This node is not handled by type inference. It is only added by
        post-typing passes.
        """
        ...
    
    @classmethod
    def undef(cls, loc): # -> Self:
        """
        A node for undefined value specifically from LOAD_FAST_AND_CLEAR opcode.
        """
        ...
    
    @classmethod
    def dummy(cls, op, info, loc): # -> Self:
        """
        A node for a dummy value.

        This node is a place holder for carrying information through to a point
        where it is rewritten into something valid. This node is not handled
        by type inference or lowering. It's presence outside of the interpreter
        renders IR as illegal.
        """
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def list_vars(self): # -> list[Var] | list[Any]:
        ...
    
    def infer_constant(self):
        ...
    


class SetItem(Stmt):
    """
    target[index] = value
    """
    def __init__(self, target, index, value, loc) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class StaticSetItem(Stmt):
    """
    target[constant index] = value
    """
    def __init__(self, target, index, index_var, value, loc) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class DelItem(Stmt):
    """
    del target[index]
    """
    def __init__(self, target, index, loc) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class SetAttr(Stmt):
    def __init__(self, target, attr, value, loc) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class DelAttr(Stmt):
    def __init__(self, target, attr, loc) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class StoreMap(Stmt):
    def __init__(self, dct, key, value, loc) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class Del(Stmt):
    def __init__(self, value, loc) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    


class Raise(Terminator):
    is_exit = ...
    def __init__(self, exception, loc) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    
    def get_targets(self): # -> list[Any]:
        ...
    


class StaticRaise(Terminator):
    """
    Raise an exception class and arguments known at compile-time.
    Note that if *exc_class* is None, a bare "raise" statement is implied
    (i.e. re-raise the current exception).
    """
    is_exit = ...
    def __init__(self, exc_class, exc_args, loc) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    
    def get_targets(self): # -> list[Any]:
        ...
    


class DynamicRaise(Terminator):
    """
    Raise an exception class and some argument *values* unknown at compile-time.
    Note that if *exc_class* is None, a bare "raise" statement is implied
    (i.e. re-raise the current exception).
    """
    is_exit = ...
    def __init__(self, exc_class, exc_args, loc) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    
    def get_targets(self): # -> list[Any]:
        ...
    


class TryRaise(Stmt):
    """A raise statement inside a try-block
    Similar to ``Raise`` but does not terminate.
    """
    def __init__(self, exception, loc) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    


class StaticTryRaise(Stmt):
    """A raise statement inside a try-block.
    Similar to ``StaticRaise`` but does not terminate.
    """
    def __init__(self, exc_class, exc_args, loc) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    


class DynamicTryRaise(Stmt):
    """A raise statement inside a try-block.
    Similar to ``DynamicRaise`` but does not terminate.
    """
    def __init__(self, exc_class, exc_args, loc) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    


class Return(Terminator):
    """
    Return to caller.
    """
    is_exit = ...
    def __init__(self, value, loc) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    
    def get_targets(self): # -> list[Any]:
        ...
    


class Jump(Terminator):
    """
    Unconditional branch.
    """
    def __init__(self, target, loc) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    
    def get_targets(self): # -> list[Any]:
        ...
    


class Branch(Terminator):
    """
    Conditional branch.
    """
    def __init__(self, cond, truebr, falsebr, loc) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    
    def get_targets(self): # -> list[Any]:
        ...
    


class Assign(Stmt):
    """
    Assign to a variable.
    """
    def __init__(self, value, target, loc) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    


class Print(Stmt):
    """
    Print some values.
    """
    def __init__(self, args, vararg, loc) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    


class Yield(Inst):
    def __init__(self, value, loc, index) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    
    def list_vars(self): # -> list[Var]:
        ...
    


class EnterWith(Stmt):
    """Enter a "with" context
    """
    def __init__(self, contextmanager, begin, end, loc) -> None:
        """
        Parameters
        ----------
        contextmanager : IR value
        begin, end : int
            The beginning and the ending offset of the with-body.
        loc : ir.Loc instance
            Source location
        """
        ...
    
    def __str__(self) -> str:
        ...
    
    def list_vars(self): # -> list[Var]:
        ...
    


class PopBlock(Stmt):
    """Marker statement for a pop block op code"""
    def __init__(self, loc) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    


class Arg(EqualityCheckMixin, AbstractRHS):
    def __init__(self, name, index, loc) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def infer_constant(self):
        ...
    


class Const(EqualityCheckMixin, AbstractRHS):
    def __init__(self, value, loc, use_literal_type=...) -> None:
        ...
    
    def __repr__(self): # -> LiteralString:
        ...
    
    def infer_constant(self): # -> Any:
        ...
    
    def __deepcopy__(self, memo): # -> Const:
        ...
    


class Global(EqualityCheckMixin, AbstractRHS):
    def __init__(self, name, value, loc) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    
    def infer_constant(self): # -> Any:
        ...
    
    def __deepcopy__(self, memo): # -> Global:
        ...
    


class FreeVar(EqualityCheckMixin, AbstractRHS):
    """
    A freevar, as loaded by LOAD_DECREF.
    (i.e. a variable defined in an enclosing non-global scope)
    """
    def __init__(self, index, name, value, loc) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    
    def infer_constant(self): # -> Any:
        ...
    
    def __deepcopy__(self, memo): # -> FreeVar:
        ...
    


class Var(EqualityCheckMixin, AbstractRHS):
    """
    Attributes
    -----------
    - scope: Scope

    - name: str

    - loc: Loc
        Definition location
    """
    def __init__(self, scope, name, loc) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __str__(self) -> str:
        ...
    
    @property
    def is_temp(self): # -> bool:
        ...
    
    @property
    def unversioned_name(self): # -> str:
        """The unversioned name of this variable, i.e. SSA renaming removed
        """
        ...
    
    @property
    def versioned_names(self): # -> set[Any]:
        """Known versioned names for this variable, i.e. known variable names in
        the scope that have been formed from applying SSA to this variable
        """
        ...
    
    @property
    def all_names(self): # -> set[Any | str]:
        """All known versioned and unversioned names for this variable
        """
        ...
    
    def __deepcopy__(self, memo): # -> Var:
        ...
    


class Scope(EqualityCheckMixin):
    """
    Attributes
    -----------
    - parent: Scope
        Parent scope

    - localvars: VarMap
        Scope-local variable map

    - loc: Loc
        Start of scope location

    """
    def __init__(self, parent, loc) -> None:
        ...
    
    def define(self, name, loc): # -> Var:
        """
        Define a variable
        """
        ...
    
    def get(self, name):
        """
        Refer to a variable.  Returns the latest version.
        """
        ...
    
    def get_exact(self, name):
        """
        Refer to a variable.  The returned variable has the exact
        name (exact variable version).
        """
        ...
    
    def get_or_define(self, name, loc): # -> Var:
        ...
    
    def redefine(self, name, loc, rename=...): # -> Var:
        """
        Redefine if the name is already defined
        """
        ...
    
    def get_versions_of(self, name): # -> set[Any]:
        """
        Gets all known versions of a given name
        """
        ...
    
    def make_temp(self, loc): # -> Var:
        ...
    
    @property
    def has_parent(self): # -> bool:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class Block(EqualityCheckMixin):
    """A code block

    """
    def __init__(self, scope, loc) -> None:
        ...
    
    def copy(self): # -> Block:
        ...
    
    def find_exprs(self, op=...): # -> Generator[Expr, Any, None]:
        """
        Iterate over exprs of the given *op* in this block.
        """
        ...
    
    def find_insts(self, cls=...): # -> Generator[Any, Any, None]:
        """
        Iterate over insts of the given class in this block.
        """
        ...
    
    def find_variable_assignment(self, name): # -> None:
        """
        Returns the assignment inst associated with variable "name", None if
        it cannot be found.
        """
        ...
    
    def prepend(self, inst): # -> None:
        ...
    
    def append(self, inst): # -> None:
        ...
    
    def remove(self, inst): # -> None:
        ...
    
    def clear(self): # -> None:
        ...
    
    def dump(self, file=...): # -> None:
        ...
    
    @property
    def terminator(self):
        ...
    
    @property
    def is_terminated(self): # -> list[Any]:
        ...
    
    def verify(self): # -> None:
        ...
    
    def insert_after(self, stmt, other): # -> None:
        """
        Insert *stmt* after *other*.
        """
        ...
    
    def insert_before_terminator(self, stmt): # -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class Loop(SlotEqualityCheckMixin):
    """Describes a loop-block
    """
    __slots__ = ...
    def __init__(self, entry, exit) -> None:
        ...
    
    def __repr__(self): # -> LiteralString:
        ...
    


class With(SlotEqualityCheckMixin):
    """Describes a with-block
    """
    __slots__ = ...
    def __init__(self, entry, exit) -> None:
        ...
    
    def __repr__(self): # -> LiteralString:
        ...
    


class FunctionIR:
    def __init__(self, blocks, is_generator, func_id, loc, definitions, arg_count, arg_names) -> None:
        ...
    
    def equal_ir(self, other): # -> Literal[False]:
        """ Checks that the IR contained within is equal to the IR in other.
        Equality is defined by being equal in fundamental structure (blocks,
        labels, IR node type and the order in which they are defined) and the
        IR nodes being equal. IR node equality essentially comes down to
        ensuring a node's `.__dict__` or `.__slots__` is equal, with the
        exception of ignoring 'loc' and 'scope' entries. The upshot is that the
        comparison is essentially location and scope invariant, but otherwise
        behaves as unsurprisingly as possible.
        """
        ...
    
    def diff_str(self, other): # -> LiteralString:
        """
        Compute a human readable difference in the IR, returns a formatted
        string ready for printing.
        """
        ...
    
    def derive(self, blocks, arg_count=..., arg_names=..., force_non_generator=...): # -> Self:
        """
        Derive a new function IR from this one, using the given blocks,
        and possibly modifying the argument count and generator flag.

        Post-processing will have to be run again on the new IR.
        """
        ...
    
    def copy(self): # -> Self:
        ...
    
    def get_block_entry_vars(self, block):
        """
        Return a set of variable names possibly alive at the beginning of
        the block.
        """
        ...
    
    def infer_constant(self, name):
        """
        Try to infer the constant value of a given variable.
        """
        ...
    
    def get_definition(self, value, lhs_only=...): # -> Var | str:
        """
        Get the definition site for the given variable name or instance.
        A Expr instance is returned by default, but if lhs_only is set
        to True, the left-hand-side variable is returned instead.
        """
        ...
    
    def get_assignee(self, rhs_value, in_blocks=...):
        """
        Finds the assignee for a given RHS value. If in_blocks is given the
        search will be limited to the specified blocks.
        """
        ...
    
    def dump(self, file=...): # -> None:
        ...
    
    def dump_to_string(self): # -> str:
        ...
    
    def dump_generator_info(self, file=...): # -> None:
        ...
    
    def render_dot(self, filename_prefix=..., include_ir=...):
        """Render the CFG of the IR with GraphViz DOT via the
        ``graphviz`` python binding.

        Returns
        -------
        g : graphviz.Digraph
            Use `g.view()` to open the graph in the default PDF application.
        """
        ...
    


class UndefinedType(EqualityCheckMixin):
    _singleton = ...
    def __new__(cls): # -> Self:
        ...
    
    def __repr__(self): # -> Literal['Undefined']:
        ...
    


UNDEFINED = ...
