"""
This type stub file was generated by pyright.
"""

import operator
from numba.core import types
from numba import prange
from numba.parfors.parfor import internal_prange
from numba.core.typing.templates import AbstractTemplate, AttributeTemplate, ConcreteTemplate, bound_function, infer, infer_getattr, infer_global
from numba.cpython.builtins import get_type_max_value, get_type_min_value
from numba.core.extending import models, register_model, type_callable, typeof_impl

@infer_global(print)
class Print(AbstractTemplate):
    def generic(self, args, kws): # -> Signature:
        ...
    


@infer
class PrintItem(AbstractTemplate):
    key = ...
    def generic(self, args, kws): # -> Signature:
        ...
    


@infer_global(abs)
class Abs(ConcreteTemplate):
    int_cases = ...
    uint_cases = ...
    real_cases = ...
    complex_cases = ...
    cases = ...


@infer_global(slice)
class Slice(ConcreteTemplate):
    cases = ...


@infer_global(range, typing_key=range)
@infer_global(prange, typing_key=prange)
@infer_global(internal_prange, typing_key=internal_prange)
class Range(ConcreteTemplate):
    cases = ...


@infer
class GetIter(AbstractTemplate):
    key = ...
    def generic(self, args, kws): # -> Signature | None:
        ...
    


@infer
class IterNext(AbstractTemplate):
    key = ...
    def generic(self, args, kws): # -> Signature | None:
        ...
    


@infer
class PairFirst(AbstractTemplate):
    """
    Given a heterogeneous pair, return the first element.
    """
    key = ...
    def generic(self, args, kws): # -> Signature | None:
        ...
    


@infer
class PairSecond(AbstractTemplate):
    """
    Given a heterogeneous pair, return the second element.
    """
    key = ...
    def generic(self, args, kws): # -> Signature | None:
        ...
    


def choose_result_bitwidth(*inputs): # -> int:
    ...

def choose_result_int(*inputs): # -> Integer:
    """
    Choose the integer result type for an operation on integer inputs,
    according to the integer typing NBEP.
    """
    ...

machine_ints = ...
integer_binop_cases = ...
class BinOp(ConcreteTemplate):
    cases = ...


@infer_global(operator.add)
class BinOpAdd(BinOp):
    ...


@infer_global(operator.iadd)
class BinOpAdd(BinOp):
    ...


@infer_global(operator.sub)
class BinOpSub(BinOp):
    ...


@infer_global(operator.isub)
class BinOpSub(BinOp):
    ...


@infer_global(operator.mul)
class BinOpMul(BinOp):
    ...


@infer_global(operator.imul)
class BinOpMul(BinOp):
    ...


@infer_global(operator.mod)
class BinOpMod(ConcreteTemplate):
    cases = ...


@infer_global(operator.imod)
class BinOpMod(ConcreteTemplate):
    cases = ...


@infer_global(operator.truediv)
class BinOpTrueDiv(ConcreteTemplate):
    cases = ...


@infer_global(operator.itruediv)
class BinOpTrueDiv(ConcreteTemplate):
    cases = ...


@infer_global(operator.floordiv)
class BinOpFloorDiv(ConcreteTemplate):
    cases = ...


@infer_global(operator.ifloordiv)
class BinOpFloorDiv(ConcreteTemplate):
    cases = ...


@infer_global(divmod)
class DivMod(ConcreteTemplate):
    _tys = ...
    cases = ...


@infer_global(operator.pow)
class BinOpPower(ConcreteTemplate):
    cases = ...


@infer_global(operator.ipow)
class BinOpPower(ConcreteTemplate):
    cases = ...


@infer_global(pow)
class PowerBuiltin(BinOpPower):
    ...


class BitwiseShiftOperation(ConcreteTemplate):
    cases = ...
    unsafe_casting = ...


@infer_global(operator.lshift)
class BitwiseLeftShift(BitwiseShiftOperation):
    ...


@infer_global(operator.ilshift)
class BitwiseLeftShift(BitwiseShiftOperation):
    ...


@infer_global(operator.rshift)
class BitwiseRightShift(BitwiseShiftOperation):
    ...


@infer_global(operator.irshift)
class BitwiseRightShift(BitwiseShiftOperation):
    ...


class BitwiseLogicOperation(BinOp):
    cases = ...
    unsafe_casting = ...


@infer_global(operator.and_)
class BitwiseAnd(BitwiseLogicOperation):
    ...


@infer_global(operator.iand)
class BitwiseAnd(BitwiseLogicOperation):
    ...


@infer_global(operator.or_)
class BitwiseOr(BitwiseLogicOperation):
    ...


@infer_global(operator.ior)
class BitwiseOr(BitwiseLogicOperation):
    ...


@infer_global(operator.xor)
class BitwiseXor(BitwiseLogicOperation):
    ...


@infer_global(operator.ixor)
class BitwiseXor(BitwiseLogicOperation):
    ...


@infer_global(operator.invert)
class BitwiseInvert(ConcreteTemplate):
    cases = ...
    unsafe_casting = ...


class UnaryOp(ConcreteTemplate):
    cases = ...


@infer_global(operator.neg)
class UnaryNegate(UnaryOp):
    ...


@infer_global(operator.pos)
class UnaryPositive(UnaryOp):
    ...


@infer_global(operator.not_)
class UnaryNot(ConcreteTemplate):
    cases = ...


class OrderedCmpOp(ConcreteTemplate):
    cases = ...


class UnorderedCmpOp(ConcreteTemplate):
    cases = ...


@infer_global(operator.lt)
class CmpOpLt(OrderedCmpOp):
    ...


@infer_global(operator.le)
class CmpOpLe(OrderedCmpOp):
    ...


@infer_global(operator.gt)
class CmpOpGt(OrderedCmpOp):
    ...


@infer_global(operator.ge)
class CmpOpGe(OrderedCmpOp):
    ...


@infer_global(operator.eq)
class ConstOpEq(AbstractTemplate):
    def generic(self, args, kws): # -> Signature | None:
        ...
    


@infer_global(operator.ne)
class ConstOpNotEq(ConstOpEq):
    ...


@infer_global(operator.eq)
class CmpOpEq(UnorderedCmpOp):
    ...


@infer_global(operator.ne)
class CmpOpNe(UnorderedCmpOp):
    ...


class TupleCompare(AbstractTemplate):
    def generic(self, args, kws): # -> Signature | None:
        ...
    


@infer_global(operator.eq)
class TupleEq(TupleCompare):
    ...


@infer_global(operator.ne)
class TupleNe(TupleCompare):
    ...


@infer_global(operator.ge)
class TupleGe(TupleCompare):
    ...


@infer_global(operator.gt)
class TupleGt(TupleCompare):
    ...


@infer_global(operator.le)
class TupleLe(TupleCompare):
    ...


@infer_global(operator.lt)
class TupleLt(TupleCompare):
    ...


@infer_global(operator.add)
class TupleAdd(AbstractTemplate):
    def generic(self, args, kws): # -> Signature | None:
        ...
    


class CmpOpIdentity(AbstractTemplate):
    def generic(self, args, kws): # -> Signature:
        ...
    


@infer_global(operator.is_)
class CmpOpIs(CmpOpIdentity):
    ...


@infer_global(operator.is_not)
class CmpOpIsNot(CmpOpIdentity):
    ...


def normalize_1d_index(index): # -> SliceType | Integer | None:
    """
    Normalize the *index* type (an integer or slice) for indexing a 1D
    sequence.
    """
    ...

@infer_global(operator.getitem)
class GetItemCPointer(AbstractTemplate):
    def generic(self, args, kws): # -> Signature | None:
        ...
    


@infer_global(operator.setitem)
class SetItemCPointer(AbstractTemplate):
    def generic(self, args, kws): # -> Signature | None:
        ...
    


@infer_global(len)
class Len(AbstractTemplate):
    def generic(self, args, kws): # -> Signature | None:
        ...
    


@infer_global(tuple)
class TupleConstructor(AbstractTemplate):
    def generic(self, args, kws): # -> Signature | None:
        ...
    


@infer_global(operator.contains)
class Contains(AbstractTemplate):
    def generic(self, args, kws): # -> Signature | None:
        ...
    


@infer_global(operator.truth)
class TupleBool(AbstractTemplate):
    def generic(self, args, kws): # -> Signature | None:
        ...
    


@infer
class StaticGetItemTuple(AbstractTemplate):
    key = ...
    def generic(self, args, kws): # -> Signature | None:
        ...
    


@infer
class StaticGetItemLiteralList(AbstractTemplate):
    key = ...
    def generic(self, args, kws): # -> Signature | None:
        ...
    


@infer
class StaticGetItemLiteralStrKeyDict(AbstractTemplate):
    key = ...
    def generic(self, args, kws): # -> Signature | None:
        ...
    


@infer
class StaticGetItemClass(AbstractTemplate):
    """This handles the "static_getitem" when a Numba type is subscripted e.g:
    var = typed.List.empty_list(float64[::1, :])
    It only allows this on simple numerical types. Compound types, like
    records, are not supported.
    """
    key = ...
    def generic(self, args, kws): # -> Signature | None:
        ...
    


@infer
class GenericNotIn(AbstractTemplate):
    key = ...
    def generic(self, args, kws): # -> Signature:
        ...
    


@infer_getattr
class MemoryViewAttribute(AttributeTemplate):
    key = types.MemoryView
    def resolve_contiguous(self, buf): # -> Boolean:
        ...
    
    def resolve_c_contiguous(self, buf): # -> Boolean:
        ...
    
    def resolve_f_contiguous(self, buf): # -> Boolean:
        ...
    
    def resolve_itemsize(self, buf): # -> Integer:
        ...
    
    def resolve_nbytes(self, buf): # -> Integer:
        ...
    
    def resolve_readonly(self, buf): # -> Boolean:
        ...
    
    def resolve_shape(self, buf): # -> UniTuple:
        ...
    
    def resolve_strides(self, buf): # -> UniTuple:
        ...
    
    def resolve_ndim(self, buf): # -> Integer:
        ...
    


@infer_getattr
class BooleanAttribute(AttributeTemplate):
    key = types.Boolean
    def resolve___class__(self, ty): # -> NumberClass:
        ...
    
    @bound_function("number.item")
    def resolve_item(self, ty, args, kws): # -> Signature | None:
        ...
    


@infer_getattr
class NumberAttribute(AttributeTemplate):
    key = types.Number
    def resolve___class__(self, ty): # -> NumberClass:
        ...
    
    def resolve_real(self, ty): # -> Any:
        ...
    
    def resolve_imag(self, ty): # -> Any:
        ...
    
    @bound_function("complex.conjugate")
    def resolve_conjugate(self, ty, args, kws): # -> Signature:
        ...
    
    @bound_function("number.item")
    def resolve_item(self, ty, args, kws): # -> Signature | None:
        ...
    


@infer_getattr
class NPTimedeltaAttribute(AttributeTemplate):
    key = types.NPTimedelta
    def resolve___class__(self, ty): # -> NumberClass:
        ...
    


@infer_getattr
class NPDatetimeAttribute(AttributeTemplate):
    key = types.NPDatetime
    def resolve___class__(self, ty): # -> NumberClass:
        ...
    


@infer_getattr
class SliceAttribute(AttributeTemplate):
    key = types.SliceType
    def resolve_start(self, ty): # -> Integer:
        ...
    
    def resolve_stop(self, ty): # -> Integer:
        ...
    
    def resolve_step(self, ty): # -> Integer:
        ...
    
    @bound_function("slice.indices")
    def resolve_indices(self, ty, args, kws): # -> Signature:
        ...
    


@infer_getattr
class NumberClassAttribute(AttributeTemplate):
    key = types.NumberClass
    def resolve___call__(self, classty): # -> Function:
        """
        Resolve a NumPy number class's constructor (e.g. calling numpy.int32(...))
        """
        ...
    


@infer_getattr
class TypeRefAttribute(AttributeTemplate):
    key = types.TypeRef
    def resolve___call__(self, classty): # -> Function | None:
        """
        Resolve a core number's constructor (e.g. calling int(...))

        Note:

        This is needed because of the limitation of the current type-system
        implementation.  Specifically, the lack of a higher-order type
        (i.e. passing the ``DictType`` vs ``DictType(key_type, value_type)``)
        """
        ...
    


class MinMaxBase(AbstractTemplate):
    def generic(self, args, kws): # -> Signature | None:
        """
        Resolve a min() or max() call.
        """
        ...
    


@infer_global(max)
class Max(MinMaxBase):
    ...


@infer_global(min)
class Min(MinMaxBase):
    ...


@infer_global(round)
class Round(ConcreteTemplate):
    cases = ...


@infer_global(bool)
class Bool(AbstractTemplate):
    def generic(self, args, kws): # -> Signature:
        ...
    


@infer_global(int)
class Int(AbstractTemplate):
    def generic(self, args, kws): # -> Signature | None:
        ...
    


@infer_global(float)
class Float(AbstractTemplate):
    def generic(self, args, kws): # -> Signature | None:
        ...
    


@infer_global(complex)
class Complex(AbstractTemplate):
    def generic(self, args, kws): # -> Signature | None:
        ...
    


@infer_global(enumerate)
class Enumerate(AbstractTemplate):
    def generic(self, args, kws): # -> Signature | None:
        ...
    


@infer_global(zip)
class Zip(AbstractTemplate):
    def generic(self, args, kws): # -> Signature | None:
        ...
    


@infer_global(iter)
class Iter(AbstractTemplate):
    def generic(self, args, kws): # -> Signature | None:
        ...
    


@infer_global(next)
class Next(AbstractTemplate):
    def generic(self, args, kws): # -> Signature | None:
        ...
    


@infer_global(type)
class TypeBuiltin(AbstractTemplate):
    def generic(self, args, kws): # -> Signature | None:
        ...
    


@infer_getattr
class OptionalAttribute(AttributeTemplate):
    key = types.Optional
    def generic_resolve(self, optional, attr):
        ...
    


@infer_getattr
class DeferredAttribute(AttributeTemplate):
    key = types.DeferredType
    def generic_resolve(self, deferred, attr):
        ...
    


@infer_global(get_type_min_value)
@infer_global(get_type_max_value)
class MinValInfer(AbstractTemplate):
    def generic(self, args, kws): # -> Signature | None:
        ...
    


class IndexValue:
    """
    Index and value
    """
    def __init__(self, ind, val) -> None:
        ...
    
    def __repr__(self): # -> LiteralString:
        ...
    


class IndexValueType(types.Type):
    def __init__(self, val_typ) -> None:
        ...
    


@typeof_impl.register(IndexValue)
def typeof_index(val, c): # -> IndexValueType:
    ...

@type_callable(IndexValue)
def type_index_value(context): # -> Callable[..., IndexValueType | None]:
    ...

@register_model(IndexValueType)
class IndexValueModel(models.StructModel):
    def __init__(self, dmm, fe_type) -> None:
        ...
    


