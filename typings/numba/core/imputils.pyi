"""
This type stub file was generated by pyright.
"""

import contextlib
from enum import Enum
from numba.core.typing.templates import BaseRegistryLoader

"""
Utilities to simplify the boilerplate for native lowering.
"""
class Registry:
    """
    A registry of function and attribute implementations.
    """
    def __init__(self, name=...) -> None:
        ...
    
    def lower(self, func, *argtys): # -> Callable[..., Any]:
        """
        Decorate an implementation of *func* for the given argument types.
        *func* may be an actual global function object, or any
        pseudo-function supported by Numba, such as "getitem".

        The decorated implementation has the signature
        (context, builder, sig, args).
        """
        ...
    
    def lower_getattr(self, ty, attr): # -> Callable[..., Any]:
        """
        Decorate an implementation of __getattr__ for type *ty* and
        the attribute *attr*.

        The decorated implementation will have the signature
        (context, builder, typ, val).
        """
        ...
    
    def lower_getattr_generic(self, ty): # -> Callable[..., Any]:
        """
        Decorate the fallback implementation of __getattr__ for type *ty*.

        The decorated implementation will have the signature
        (context, builder, typ, val, attr).  The implementation is
        called for attributes which haven't been explicitly registered
        with lower_getattr().
        """
        ...
    
    def lower_setattr(self, ty, attr): # -> Callable[..., Any]:
        """
        Decorate an implementation of __setattr__ for type *ty* and
        the attribute *attr*.

        The decorated implementation will have the signature
        (context, builder, sig, args).
        """
        ...
    
    def lower_setattr_generic(self, ty): # -> Callable[..., Any]:
        """
        Decorate the fallback implementation of __setattr__ for type *ty*.

        The decorated implementation will have the signature
        (context, builder, sig, args, attr).  The implementation is
        called for attributes which haven't been explicitly registered
        with lower_setattr().
        """
        ...
    
    def lower_cast(self, fromty, toty): # -> Callable[..., Any]:
        """
        Decorate the implementation of implicit conversion between
        *fromty* and *toty*.

        The decorated implementation will have the signature
        (context, builder, fromty, toty, val).
        """
        ...
    
    def lower_constant(self, ty): # -> Callable[..., Any]:
        """
        Decorate the implementation for creating a constant of type *ty*.

        The decorated implementation will have the signature
        (context, builder, ty, pyval).
        """
        ...
    
    def __repr__(self): # -> str:
        ...
    


class RegistryLoader(BaseRegistryLoader):
    """
    An incremental loader for a target registry.
    """
    registry_items = ...


builtin_registry = ...
lower_builtin = ...
lower_getattr = ...
lower_getattr_generic = ...
lower_setattr = ...
lower_setattr_generic = ...
lower_cast = ...
lower_constant = ...
def fix_returning_optional(context, builder, sig, status, retval):
    ...

def user_function(fndesc, libs): # -> Callable[..., Any]:
    """
    A wrapper inserting code calling Numba-compiled *fndesc*.
    """
    ...

def user_generator(gendesc, libs): # -> Callable[..., tuple[Any, Any]]:
    """
    A wrapper inserting code calling Numba-compiled *gendesc*.
    """
    ...

def iterator_impl(iterable_type, iterator_type): # -> Callable[..., Any]:
    """
    Decorator a given class as implementing *iterator_type*
    (by providing an `iternext()` method).
    """
    ...

class _IternextResult:
    """
    A result wrapper for iteration, passed by iternext_impl() into the
    wrapped function.
    """
    __slots__ = ...
    def __init__(self, context, builder, pairobj) -> None:
        ...
    
    def set_exhausted(self): # -> None:
        """
        Mark the iterator as exhausted.
        """
        ...
    
    def set_valid(self, is_valid=...): # -> None:
        """
        Mark the iterator as valid according to *is_valid* (which must
        be either a Python boolean or a LLVM inst).
        """
        ...
    
    def yield_(self, value): # -> None:
        """
        Mark the iterator as yielding the given *value* (a LLVM inst).
        """
        ...
    
    def is_valid(self):
        """
        Return whether the iterator is marked valid.
        """
        ...
    
    def yielded_value(self):
        """
        Return the iterator's yielded value, if any.
        """
        ...
    


class RefType(Enum):
    """
    Enumerate the reference type
    """
    NEW = ...
    BORROWED = ...
    UNTRACKED = ...


def iternext_impl(ref_type=...): # -> Callable[..., Callable[..., Any]]:
    """
    Wrap the given iternext() implementation so that it gets passed
    an _IternextResult() object easing the returning of the iternext()
    result pair.

    ref_type: a numba.targets.imputils.RefType value, the reference type used is
    that specified through the RefType enum.

    The wrapped function will be called with the following signature:
        (context, builder, sig, args, iternext_result)
    """
    ...

def call_getiter(context, builder, iterable_type, val):
    """
    Call the `getiter()` implementation for the given *iterable_type*
    of value *val*, and return the corresponding LLVM inst.
    """
    ...

def call_iternext(context, builder, iterator_type, val): # -> _IternextResult:
    """
    Call the `iternext()` implementation for the given *iterator_type*
    of value *val*, and return a convenience _IternextResult() object
    reflecting the results.
    """
    ...

def call_len(context, builder, ty, val): # -> None:
    """
    Call len() on the given value.  Return None if len() isn't defined on
    this type.
    """
    ...

_ForIterLoop = ...
@contextlib.contextmanager
def for_iter(context, builder, iterable_type, val): # -> Generator[_ForIterLoop, Any, None]:
    """
    Simulate a for loop on the given iterable.  Yields a namedtuple with
    the given members:
    - `value` is the value being yielded
    - `do_break` is a callable to early out of the loop
    """
    ...

def impl_ret_new_ref(ctx, builder, retty, ret):
    """
    The implementation returns a new reference.
    """
    ...

def impl_ret_borrowed(ctx, builder, retty, ret):
    """
    The implementation returns a borrowed reference.
    This function automatically incref so that the implementation is
    returning a new reference.
    """
    ...

def impl_ret_untracked(ctx, builder, retty, ret):
    """
    The return type is not a NRT object.
    """
    ...

@contextlib.contextmanager
def force_error_model(context, model_name=...): # -> Generator[None, Any, None]:
    """
    Temporarily change the context's error model.
    """
    ...

def numba_typeref_ctor(*args, **kwargs):
    """A stub for use internally by Numba when a call is emitted
    on a TypeRef.
    """
    ...

