"""
This type stub file was generated by pyright.
"""

from numba.core import types
from numba.core.pythonapi import box, reflect, unbox

"""
Boxing and unboxing of native Numba values to / from CPython objects.
"""
@box(types.Boolean)
def box_bool(typ, val, c):
    ...

@unbox(types.Boolean)
def unbox_boolean(typ, obj, c): # -> NativeValue:
    ...

@box(types.IntegerLiteral)
@box(types.BooleanLiteral)
def box_literal_integer(typ, val, c):
    ...

@box(types.Integer)
def box_integer(typ, val, c):
    ...

@unbox(types.Integer)
def unbox_integer(typ, obj, c): # -> NativeValue:
    ...

@box(types.Float)
def box_float(typ, val, c):
    ...

@unbox(types.Float)
def unbox_float(typ, obj, c): # -> NativeValue:
    ...

@box(types.Complex)
def box_complex(typ, val, c):
    ...

@unbox(types.Complex)
def unbox_complex(typ, obj, c): # -> NativeValue:
    ...

@box(types.NoneType)
def box_none(typ, val, c):
    ...

@unbox(types.NoneType)
@unbox(types.EllipsisType)
def unbox_none(typ, val, c): # -> NativeValue:
    ...

@box(types.NPDatetime)
def box_npdatetime(typ, val, c):
    ...

@unbox(types.NPDatetime)
def unbox_npdatetime(typ, obj, c): # -> NativeValue:
    ...

@box(types.NPTimedelta)
def box_nptimedelta(typ, val, c):
    ...

@unbox(types.NPTimedelta)
def unbox_nptimedelta(typ, obj, c): # -> NativeValue:
    ...

@box(types.RawPointer)
def box_raw_pointer(typ, val, c):
    """
    Convert a raw pointer to a Python int.
    """
    ...

@box(types.EnumMember)
def box_enum(typ, val, c):
    """
    Fetch an enum member given its native value.
    """
    ...

@unbox(types.EnumMember)
def unbox_enum(typ, obj, c):
    """
    Convert an enum member's value to its native value.
    """
    ...

@box(types.UndefVar)
def box_undefvar(typ, val, c):
    """This type cannot be boxed, there's no Python equivalent"""
    ...

@box(types.Record)
def box_record(typ, val, c):
    ...

@unbox(types.Record)
def unbox_record(typ, obj, c): # -> NativeValue:
    ...

@box(types.UnicodeCharSeq)
def box_unicodecharseq(typ, val, c):
    ...

@unbox(types.UnicodeCharSeq)
def unbox_unicodecharseq(typ, obj, c): # -> NativeValue:
    ...

@box(types.Bytes)
def box_bytes(typ, val, c):
    ...

@box(types.CharSeq)
def box_charseq(typ, val, c):
    ...

@unbox(types.CharSeq)
def unbox_charseq(typ, obj, c): # -> NativeValue:
    ...

@box(types.Optional)
def box_optional(typ, val, c):
    ...

@unbox(types.Optional)
def unbox_optional(typ, obj, c): # -> NativeValue:
    """
    Convert object *obj* to a native optional structure.
    """
    ...

@unbox(types.SliceType)
def unbox_slice(typ, obj, c): # -> NativeValue:
    """
    Convert object *obj* to a native slice structure.
    """
    ...

@box(types.SliceLiteral)
def box_slice_literal(typ, val, c):
    ...

@unbox(types.StringLiteral)
def unbox_string_literal(typ, obj, c): # -> NativeValue:
    ...

@box(types.Array)
def box_array(typ, val, c):
    ...

@unbox(types.Buffer)
def unbox_buffer(typ, obj, c): # -> NativeValue:
    """
    Convert a Py_buffer-providing object to a native array structure.
    """
    ...

@unbox(types.Array)
def unbox_array(typ, obj, c): # -> NativeValue:
    """
    Convert a Numpy array object to a native array structure.
    """
    ...

@box(types.Tuple)
@box(types.UniTuple)
def box_tuple(typ, val, c):
    """
    Convert native array or structure *val* to a tuple object.
    """
    ...

@box(types.NamedTuple)
@box(types.NamedUniTuple)
def box_namedtuple(typ, val, c):
    """
    Convert native array or structure *val* to a namedtuple object.
    """
    ...

@unbox(types.BaseTuple)
def unbox_tuple(typ, obj, c): # -> NativeValue:
    """
    Convert tuple *obj* to a native array (if homogeneous) or structure.
    """
    ...

@box(types.List)
def box_list(typ, val, c):
    """
    Convert native list *val* to a list object.
    """
    ...

class _NumbaTypeHelper:
    """A helper for acquiring `numba.typeof` for type checking.

    Usage
    -----

        # `c` is the boxing context.
        with _NumbaTypeHelper(c) as nth:
            # This contextmanager maintains the lifetime of the `numba.typeof`
            # function.
            the_numba_type = nth.typeof(some_object)
            # Do work on the type object
            do_checks(the_numba_type)
            # Cleanup
            c.pyapi.decref(the_numba_type)
        # At this point *nth* should not be used.
    """
    def __init__(self, c) -> None:
        ...
    
    def __enter__(self): # -> Self:
        ...
    
    def __exit__(self, *args, **kwargs): # -> None:
        ...
    
    def typeof(self, obj):
        ...
    


@unbox(types.List)
def unbox_list(typ, obj, c): # -> NativeValue:
    """
    Convert list *obj* to a native list.

    If list was previously unboxed, we reuse the existing native list
    to ensure consistency.
    """
    ...

@reflect(types.List)
def reflect_list(typ, val, c): # -> None:
    """
    Reflect the native list's contents into the Python object.
    """
    ...

@unbox(types.Set)
def unbox_set(typ, obj, c): # -> NativeValue:
    """
    Convert set *obj* to a native set.

    If set was previously unboxed, we reuse the existing native set
    to ensure consistency.
    """
    ...

@box(types.Set)
def box_set(typ, val, c):
    """
    Convert native set *val* to a set object.
    """
    ...

@reflect(types.Set)
def reflect_set(typ, val, c): # -> None:
    """
    Reflect the native set's contents into the Python object.
    """
    ...

@box(types.Generator)
def box_generator(typ, val, c):
    ...

@unbox(types.Generator)
def unbox_generator(typ, obj, c):
    ...

@box(types.DType)
def box_dtype(typ, val, c):
    ...

@unbox(types.DType)
def unbox_dtype(typ, val, c): # -> NativeValue:
    ...

@box(types.NumberClass)
def box_number_class(typ, val, c):
    ...

@unbox(types.NumberClass)
def unbox_number_class(typ, val, c): # -> NativeValue:
    ...

@box(types.PyObject)
@box(types.Object)
def box_pyobject(typ, val, c):
    ...

@unbox(types.PyObject)
@unbox(types.Object)
def unbox_pyobject(typ, obj, c): # -> NativeValue:
    ...

@unbox(types.ExternalFunctionPointer)
def unbox_funcptr(typ, obj, c): # -> NativeValue:
    ...

@box(types.DeferredType)
def box_deferred(typ, val, c):
    ...

@unbox(types.DeferredType)
def unbox_deferred(typ, obj, c): # -> NativeValue:
    ...

@unbox(types.Dispatcher)
def unbox_dispatcher(typ, obj, c): # -> NativeValue:
    ...

@box(types.Dispatcher)
def box_pyobject(typ, val, c):
    ...

def unbox_unsupported(typ, obj, c): # -> NativeValue:
    ...

def box_unsupported(typ, val, c):
    ...

@box(types.Literal)
def box_literal(typ, val, c):
    ...

@box(types.MemInfoPointer)
def box_meminfo_pointer(typ, val, c):
    ...

@unbox(types.MemInfoPointer)
def unbox_meminfo_pointer(typ, obj, c): # -> NativeValue:
    ...

@unbox(types.TypeRef)
def unbox_typeref(typ, val, c): # -> NativeValue:
    ...

@box(types.LiteralStrKeyDict)
def box_LiteralStrKeyDict(typ, val, c):
    ...

@unbox(types.NumPyRandomBitGeneratorType)
def unbox_numpy_random_bitgenerator(typ, obj, c): # -> NativeValue:
    """
    The bit_generator instance has a `.ctypes` attr which is a namedtuple
    with the following members (types):
    * state_address (Python int)
    * state (ctypes.c_void_p)
    * next_uint64 (ctypes.CFunctionType instance)
    * next_uint32 (ctypes.CFunctionType instance)
    * next_double (ctypes.CFunctionType instance)
    * bit_generator (ctypes.c_void_p)
    """
    ...

_bit_gen_type = ...
@unbox(types.NumPyRandomGeneratorType)
def unbox_numpy_random_generator(typ, obj, c): # -> NativeValue:
    """
    Here we're creating a NumPyRandomGeneratorType StructModel with following fields:
    * ('bit_generator', _bit_gen_type): The unboxed BitGenerator associated with
                                        this Generator object instance.
    * ('parent', types.pyobject): Pointer to the original Generator PyObject.
    * ('meminfo', types.MemInfoPointer(types.voidptr)): The information about the memory
        stored at the pointer (to the original Generator PyObject). This is useful for
        keeping track of reference counts within the Python runtime. Helps prevent cases
        where deletion happens in Python runtime without NRT being awareness of it. 
    """
    ...

@box(types.NumPyRandomGeneratorType)
def box_numpy_random_generator(typ, val, c):
    ...

