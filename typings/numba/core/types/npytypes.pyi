"""
This type stub file was generated by pyright.
"""

from functools import cached_property
from .abstract import DTypeSpec, IteratorType, MutableSequence, Type
from .common import Buffer, Opaque, SimpleIteratorType

class CharSeq(Type):
    """
    A fixed-length 8-bit character sequence.
    """
    mutable = ...
    def __init__(self, count) -> None:
        ...
    
    @property
    def key(self): # -> Any:
        ...
    
    def can_convert_from(self, typingctx, other): # -> Literal[Conversion.safe] | None:
        ...
    


class UnicodeCharSeq(Type):
    """
    A fixed-length unicode character sequence.
    """
    mutable = ...
    def __init__(self, count) -> None:
        ...
    
    @property
    def key(self): # -> Any:
        ...
    
    def can_convert_to(self, typingctx, other): # -> Literal[Conversion.safe] | None:
        ...
    
    def can_convert_from(self, typingctx, other): # -> Literal[Conversion.safe] | None:
        ...
    
    def __repr__(self): # -> str:
        ...
    


_RecordField = ...
class Record(Type):
    """
    A Record datatype can be mapped to a NumPy structured dtype.
    A record is very flexible since it is laid out as a list of bytes.
    Fields can be mapped to arbitrary points inside it, even if they overlap.

    *fields* is a list of `(name:str, data:dict)`.
        Where `data` is `{ type: Type, offset: int }`
    *size* is an int; the record size
    *aligned* is a boolean; whether the record is ABI aligned.
    """
    mutable = ...
    @classmethod
    def make_c_struct(cls, name_types): # -> Record:
        """Construct a Record type from a list of (name:str, type:Types).
        The layout of the structure will follow C.

        Note: only scalar types are supported currently.
        """
        ...
    
    def __init__(self, fields, size, aligned) -> None:
        ...
    
    @property
    def key(self): # -> Any:
        ...
    
    @property
    def mangling_args(self): # -> tuple[str, tuple[Any]]:
        ...
    
    def __len__(self): # -> int:
        """Returns the number of fields
        """
        ...
    
    def offset(self, key):
        """Get the byte offset of a field from the start of the structure.
        """
        ...
    
    def typeof(self, key):
        """Get the type of a field.
        """
        ...
    
    def alignof(self, key):
        """Get the specified alignment of the field.

        Since field alignment is optional, this may return None.
        """
        ...
    
    def has_titles(self): # -> bool:
        """Returns True the record uses titles.
        """
        ...
    
    def is_title(self, key):
        """Returns True if the field named *key* is a title.
        """
        ...
    
    @property
    def members(self): # -> list[tuple[Any, Any]]:
        """An ordered list of (name, type) for the fields.
        """
        ...
    
    @property
    def dtype(self): # -> dtype[Any]:
        ...
    
    def can_convert_to(self, typingctx, other): # -> Literal[Conversion.safe] | None:
        """
        Convert this Record to the *other*.

        This method only implements width subtyping for records.
        """
        ...
    
    def __repr__(self): # -> str:
        ...
    


class DType(DTypeSpec, Opaque):
    """
    Type class associated with the `np.dtype`.

    i.e. :code:`assert type(np.dtype('int32')) == np.dtype`

    np.dtype('int32')
    """
    def __init__(self, dtype) -> None:
        ...
    
    @property
    def key(self): # -> Type:
        ...
    
    @property
    def dtype(self): # -> Type:
        ...
    
    def __getitem__(self, arg): # -> Array:
        ...
    


class NumpyFlatType(SimpleIteratorType, MutableSequence):
    """
    Type class for `ndarray.flat()` objects.
    """
    def __init__(self, arrty) -> None:
        ...
    
    @property
    def key(self): # -> Any:
        ...
    


class NumpyNdEnumerateType(SimpleIteratorType):
    """
    Type class for `np.ndenumerate()` objects.
    """
    def __init__(self, arrty) -> None:
        ...
    
    @property
    def key(self): # -> Any:
        ...
    


class NumpyNdIterType(IteratorType):
    """
    Type class for `np.nditer()` objects.

    The layout denotes in which order the logical shape is iterated on.
    "C" means logical order (corresponding to in-memory order in C arrays),
    "F" means reverse logical order (corresponding to in-memory order in
    F arrays).
    """
    def __init__(self, arrays) -> None:
        ...
    
    @property
    def key(self): # -> tuple[Any, ...]:
        ...
    
    @property
    def views(self): # -> list[Array]:
        """
        The views yielded by the iterator.
        """
        ...
    
    @property
    def yield_type(self): # -> NamedUniTuple | NamedTuple | UniTuple | Tuple | Array | None:
        ...
    
    @cached_property
    def indexers(self): # -> list[Any]:
        """
        A list of (kind, start_dim, end_dim, indices) where:
        - `kind` is either "flat", "indexed", "0d" or "scalar"
        - `start_dim` and `end_dim` are the dimension numbers at which
          this indexing takes place
        - `indices` is the indices of the indexed arrays in self.arrays
        """
        ...
    
    @cached_property
    def need_shaped_indexing(self): # -> bool:
        """
        Whether iterating on this iterator requires keeping track of
        individual indices inside the shape.  If False, only a single index
        over the equivalent flat shape is required, which can make the
        iterator more efficient.
        """
        ...
    


class NumpyNdIndexType(SimpleIteratorType):
    """
    Type class for `np.ndindex()` objects.
    """
    def __init__(self, ndim) -> None:
        ...
    
    @property
    def key(self): # -> Any:
        ...
    


class Array(Buffer):
    """
    Type class for Numpy arrays.
    """
    def __init__(self, dtype, ndim, layout, readonly=..., name=..., aligned=...) -> None:
        ...
    
    @property
    def mangling_args(self): # -> tuple[str, list[Any]]:
        ...
    
    def copy(self, dtype=..., ndim=..., layout=..., readonly=...): # -> Array:
        ...
    
    @property
    def key(self): # -> tuple[Any, Any, Any, bool, bool]:
        ...
    
    def unify(self, typingctx, other): # -> Array | None:
        """
        Unify this with the *other* Array.
        """
        ...
    
    def can_convert_to(self, typingctx, other): # -> Literal[Conversion.safe] | None:
        """
        Convert this Array to the *other*.
        """
        ...
    
    def is_precise(self):
        ...
    
    @property
    def box_type(self): # -> type[ndarray[Any, Any]]:
        """Returns the Python type to box to.
        """
        ...
    
    def __repr__(self): # -> str:
        ...
    


class ArrayCTypes(Type):
    """
    This is the type for `np.ndarray.ctypes`.
    """
    def __init__(self, arytype) -> None:
        ...
    
    @property
    def key(self): # -> tuple[Any, Any]:
        ...
    
    def can_convert_to(self, typingctx, other): # -> Literal[Conversion.safe] | None:
        """
        Convert this type to the corresponding pointer type.
        This allows passing a array.ctypes object to a C function taking
        a raw pointer.

        Note that in pure Python, the array.ctypes object can only be
        passed to a ctypes function accepting a c_void_p, not a typed
        pointer.
        """
        ...
    


class ArrayFlags(Type):
    """
    This is the type for `np.ndarray.flags`.
    """
    def __init__(self, arytype) -> None:
        ...
    
    @property
    def key(self): # -> Any:
        ...
    


class NestedArray(Array):
    """
    A NestedArray is an array nested within a structured type (which are "void"
    type in NumPy parlance). Unlike an Array, the shape, and not just the number
    of dimensions is part of the type of a NestedArray.
    """
    def __init__(self, dtype, shape) -> None:
        ...
    
    @property
    def shape(self): # -> Any:
        ...
    
    @property
    def nitems(self): # -> Literal[1]:
        ...
    
    @property
    def size(self):
        ...
    
    @property
    def strides(self): # -> tuple[Any, ...]:
        ...
    
    @property
    def key(self): # -> tuple[Any, Any]:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class NumPyRandomBitGeneratorType(Type):
    def __init__(self, *args, **kwargs) -> None:
        ...
    


class NumPyRandomGeneratorType(Type):
    def __init__(self, *args, **kwargs) -> None:
        ...
    


class PolynomialType(Type):
    def __init__(self, coef, domain=..., window=..., n_args=...) -> None:
        ...
    


