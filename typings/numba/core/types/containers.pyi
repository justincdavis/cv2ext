"""
This type stub file was generated by pyright.
"""

from collections.abc import Sequence as pySequence
from .abstract import ConstSized, Container, Hashable, InitialValue, Literal, MutableSequence, Sequence, Type
from .common import Buffer, IterableType, SimpleIterableType, SimpleIteratorType

class Pair(Type):
    """
    A heterogeneous pair.
    """
    def __init__(self, first_type, second_type) -> None:
        ...
    
    @property
    def key(self): # -> tuple[Any, Any]:
        ...
    
    def unify(self, typingctx, other): # -> Pair | None:
        ...
    


class BaseContainerIterator(SimpleIteratorType):
    """
    Convenience base class for some container iterators.

    Derived classes must implement the *container_class* attribute.
    """
    def __init__(self, container) -> None:
        ...
    
    def unify(self, typingctx, other): # -> Self | None:
        ...
    
    @property
    def key(self): # -> Any:
        ...
    


class BaseContainerPayload(Type):
    """
    Convenience base class for some container payloads.

    Derived classes must implement the *container_class* attribute.
    """
    def __init__(self, container) -> None:
        ...
    
    @property
    def key(self): # -> Any:
        ...
    


class Bytes(Buffer):
    """
    Type class for Python 3.x bytes objects.
    """
    mutable = ...
    slice_is_copy = ...


class ByteArray(Buffer):
    """
    Type class for bytearray objects.
    """
    slice_is_copy = ...


class PyArray(Buffer):
    """
    Type class for array.array objects.
    """
    slice_is_copy = ...


class MemoryView(Buffer):
    """
    Type class for memoryview objects.
    """
    ...


def is_homogeneous(*tys): # -> bool:
    """Are the types homogeneous?
    """
    ...

class BaseTuple(ConstSized, Hashable):
    """
    The base class for all tuple types (with a known size).
    """
    @classmethod
    def from_types(cls, tys, pyclass=...): # -> NamedUniTuple | NamedTuple | UniTuple | Tuple | None:
        """
        Instantiate the right tuple type for the given element types.
        """
        ...
    


class BaseAnonymousTuple(BaseTuple):
    """
    Mixin for non-named tuples.
    """
    def can_convert_to(self, typingctx, other): # -> Literal[Conversion.safe] | None:
        """
        Convert this tuple to another one.  Note named tuples are rejected.
        """
        ...
    
    def __unliteral__(self): # -> NamedUniTuple | NamedTuple | UniTuple | Tuple | None:
        ...
    


class _HomogeneousTuple(Sequence, BaseTuple):
    @property
    def iterator_type(self): # -> UniTupleIter:
        ...
    
    def __getitem__(self, i):
        """
        Return element at position i
        """
        ...
    
    def __iter__(self):
        ...
    
    def __len__(self):
        ...
    
    @property
    def types(self):
        ...
    


class UniTuple(BaseAnonymousTuple, _HomogeneousTuple, Sequence):
    """
    Type class for homogeneous tuples.
    """
    def __init__(self, dtype, count) -> None:
        ...
    
    @property
    def mangling_args(self): # -> tuple[str, tuple[Any, Any]]:
        ...
    
    @property
    def key(self): # -> tuple[Any, Any]:
        ...
    
    def unify(self, typingctx, other): # -> UniTuple | None:
        """
        Unify UniTuples with their dtype
        """
        ...
    
    def __unliteral__(self): # -> Self:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class UniTupleIter(BaseContainerIterator):
    """
    Type class for homogeneous tuple iterators.
    """
    container_class = _HomogeneousTuple


class _HeterogeneousTuple(BaseTuple):
    def __getitem__(self, i):
        """
        Return element at position i
        """
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __iter__(self):
        ...
    
    @staticmethod
    def is_types_iterable(types): # -> None:
        ...
    


class UnionType(Type):
    def __init__(self, types) -> None:
        ...
    
    def get_type_tag(self, typ): # -> int:
        ...
    


class Tuple(BaseAnonymousTuple, _HeterogeneousTuple):
    def __new__(cls, types): # -> UniTuple | Tuple:
        ...
    
    def __init__(self, types) -> None:
        ...
    
    @property
    def mangling_args(self): # -> tuple[str, tuple[Any, ...]]:
        ...
    
    @property
    def key(self): # -> tuple[Any, ...]:
        ...
    
    def unify(self, typingctx, other): # -> UniTuple | Tuple | None:
        """
        Unify elements of Tuples/UniTuples
        """
        ...
    
    def __repr__(self): # -> str:
        ...
    


class _StarArgTupleMixin:
    ...


class StarArgTuple(_StarArgTupleMixin, Tuple):
    """To distinguish from Tuple() used as argument to a `*args`.
    """
    def __new__(cls, types): # -> StarArgUniTuple | StarArgTuple:
        ...
    


class StarArgUniTuple(_StarArgTupleMixin, UniTuple):
    """To distinguish from UniTuple() used as argument to a `*args`.
    """
    ...


class BaseNamedTuple(BaseTuple):
    ...


class NamedUniTuple(_HomogeneousTuple, BaseNamedTuple):
    def __init__(self, dtype, count, cls) -> None:
        ...
    
    @property
    def iterator_type(self): # -> UniTupleIter:
        ...
    
    @property
    def key(self): # -> tuple[Any, Any, Any]:
        ...
    


class NamedTuple(_HeterogeneousTuple, BaseNamedTuple):
    def __init__(self, types, cls) -> None:
        ...
    
    @property
    def key(self): # -> tuple[Any, tuple[Any, ...]]:
        ...
    


class List(MutableSequence, InitialValue):
    """
    Type class for (arbitrary-sized) homogeneous lists.
    """
    mutable = ...
    def __init__(self, dtype, reflected=..., initial_value=...) -> None:
        ...
    
    def copy(self, dtype=..., reflected=...): # -> List:
        ...
    
    def unify(self, typingctx, other): # -> List | None:
        ...
    
    @property
    def key(self): # -> tuple[Any, bool, str]:
        ...
    
    @property
    def iterator_type(self): # -> ListIter:
        ...
    
    def is_precise(self): # -> Any:
        ...
    
    def __getitem__(self, args): # -> Any:
        """
        Overrides the default __getitem__ from Type.
        """
        ...
    
    def __unliteral__(self): # -> List:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class LiteralList(Literal, ConstSized, Hashable):
    """A heterogeneous immutable list (basically a tuple with list semantics).
    """
    mutable = ...
    def __init__(self, literal_value) -> None:
        ...
    
    def __getitem__(self, i):
        """
        Return element at position i
        """
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __iter__(self): # -> Iterator[Any]:
        ...
    
    @classmethod
    def from_types(cls, tys): # -> LiteralList:
        ...
    
    @staticmethod
    def is_types_iterable(types): # -> None:
        ...
    
    @property
    def iterator_type(self): # -> ListIter:
        ...
    
    def __unliteral__(self): # -> Poison:
        ...
    
    def unify(self, typingctx, other): # -> LiteralList | None:
        """
        Unify this with the *other* one.
        """
        ...
    


class ListIter(BaseContainerIterator):
    """
    Type class for list iterators.
    """
    container_class = List


class ListPayload(BaseContainerPayload):
    """
    Internal type class for the dynamically-allocated payload of a list.
    """
    container_class = List


class Set(Container):
    """
    Type class for homogeneous sets.
    """
    mutable = ...
    def __init__(self, dtype, reflected=...) -> None:
        ...
    
    @property
    def key(self): # -> tuple[Hashable | Undefined, bool]:
        ...
    
    @property
    def iterator_type(self): # -> SetIter:
        ...
    
    def is_precise(self): # -> bool:
        ...
    
    def copy(self, dtype=..., reflected=...): # -> Set:
        ...
    
    def unify(self, typingctx, other): # -> Set | None:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class SetIter(BaseContainerIterator):
    """
    Type class for set iterators.
    """
    container_class = Set


class SetPayload(BaseContainerPayload):
    """
    Internal type class for the dynamically-allocated payload of a set.
    """
    container_class = Set


class SetEntry(Type):
    """
    Internal type class for the entries of a Set's hash table.
    """
    def __init__(self, set_type) -> None:
        ...
    
    @property
    def key(self): # -> Any:
        ...
    


class ListType(IterableType):
    """List type
    """
    mutable = ...
    def __init__(self, itemty) -> None:
        ...
    
    @property
    def key(self): # -> Any:
        ...
    
    def is_precise(self): # -> bool:
        ...
    
    @property
    def iterator_type(self): # -> Any:
        ...
    
    @classmethod
    def refine(cls, itemty): # -> Self:
        """Refine to a precise list type
        """
        ...
    
    def unify(self, typingctx, other): # -> Self | None:
        """
        Unify this with the *other* list.
        """
        ...
    
    def __repr__(self): # -> str:
        ...
    


class ListTypeIterableType(SimpleIterableType):
    """List iterable type
    """
    def __init__(self, parent) -> None:
        ...
    


class ListTypeIteratorType(SimpleIteratorType):
    def __init__(self, iterable) -> None:
        ...
    


class DictType(IterableType, InitialValue):
    """Dictionary type
    """
    def __init__(self, keyty, valty, initial_value=...) -> None:
        ...
    
    def is_precise(self): # -> bool:
        ...
    
    @property
    def iterator_type(self): # -> Any:
        ...
    
    @classmethod
    def refine(cls, keyty, valty): # -> Self:
        """Refine to a precise dictionary type
        """
        ...
    
    def unify(self, typingctx, other): # -> Self | DictType | None:
        """
        Unify this with the *other* dictionary.
        """
        ...
    
    @property
    def key(self): # -> tuple[Any, Any, str]:
        ...
    
    def __unliteral__(self): # -> DictType:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class LiteralStrKeyDict(Literal, ConstSized, Hashable):
    """A Dictionary of string keys to heterogeneous values (basically a
    namedtuple with dict semantics).
    """
    class FakeNamedTuple(pySequence):
        def __init__(self, name, keys) -> None:
            ...
        
        def __len__(self): # -> int:
            ...
        
        def __getitem__(self, key):
            ...
        
    
    
    mutable = ...
    def __init__(self, literal_value, value_index=...) -> None:
        ...
    
    def __unliteral__(self): # -> Poison:
        ...
    
    def unify(self, typingctx, other): # -> LiteralStrKeyDict | None:
        """
        Unify this with the *other* one.
        """
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __iter__(self): # -> Iterator[Any]:
        ...
    
    @property
    def key(self): # -> tuple[tuple[Any, ...], tuple[Any, ...], str]:
        ...
    


class DictItemsIterableType(SimpleIterableType):
    """Dictionary iterable type for .items()
    """
    def __init__(self, parent) -> None:
        ...
    


class DictKeysIterableType(SimpleIterableType):
    """Dictionary iterable type for .keys()
    """
    def __init__(self, parent) -> None:
        ...
    


class DictValuesIterableType(SimpleIterableType):
    """Dictionary iterable type for .values()
    """
    def __init__(self, parent) -> None:
        ...
    


class DictIteratorType(SimpleIteratorType):
    def __init__(self, iterable) -> None:
        ...
    


class StructRef(Type):
    """A mutable struct.
    """
    def __init__(self, fields) -> None:
        """
        Parameters
        ----------
        fields : Sequence
            A sequence of field descriptions, which is a 2-tuple-like object
            containing `(name, type)`, where `name` is a `str` for the field
            name, and `type` is a numba type for the field type.
        """
        ...
    
    def preprocess_fields(self, fields):
        """Subclasses can override this to do additional clean up on fields.

        The default is an identity function.

        Parameters:
        -----------
        fields : Sequence[Tuple[str, Type]]
        """
        ...
    
    @property
    def field_dict(self): # -> MappingProxyType[str, Type]:
        """Return an immutable mapping for the field names and their
        corresponding types.
        """
        ...
    
    def get_data_type(self): # -> StructRefPayload:
        """Get the payload type for the actual underlying structure referred
        to by this struct reference.

        See also: `ClassInstanceType.get_data_type`
        """
        ...
    


class StructRefPayload(Type):
    """The type of the payload of a mutable struct.
    """
    mutable = ...
    def __init__(self, typename, fields) -> None:
        ...
    
    @property
    def field_dict(self): # -> MappingProxyType[Any, Any]:
        ...
    


