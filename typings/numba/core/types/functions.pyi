"""
This type stub file was generated by pyright.
"""

from .abstract import Callable, DTypeSpec, Dummy, Literal, Type, weakref
from .common import Opaque

_logger = ...
_termcolor = ...
_FAILURE = ...
_termwidth = ...
_header_lead = ...
_header_template = ...
_reason_template = ...
_overload_template = ...
_err_reasons = ...
def argsnkwargs_to_str(args, kwargs): # -> str:
    ...

class _ResolutionFailures:
    """Collect and format function resolution failures.
    """
    def __init__(self, context, function_type, args, kwargs, depth=...) -> None:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def add_error(self, calltemplate, matched, error, literal): # -> None:
        """
        Args
        ----
        calltemplate : CallTemplate
        error : Exception or str
            Error message
        """
        ...
    
    def format(self): # -> str:
        """Return a formatted error message from all the gathered errors.
        """
        ...
    
    def format_error(self, error): # -> str:
        """Format error message or exception
        """
        ...
    
    def get_loc(self, classtemplate, error): # -> str | None:
        """Get source location information from the error message.
        """
        ...
    
    def raise_error(self):
        ...
    


class BaseFunction(Callable):
    """
    Base type class for some function types.
    """
    def __init__(self, template) -> None:
        ...
    
    @property
    def key(self): # -> tuple[Any, tuple[Any, ...] | tuple[Any]]:
        ...
    
    def augment(self, other): # -> Self | None:
        """
        Augment this function type with the other function types' templates,
        so as to support more input types.
        """
        ...
    
    def get_impl_key(self, sig):
        """
        Get the implementation key (used by the target context) for the
        given signature.
        """
        ...
    
    def get_call_type(self, context, args, kws): # -> None:
        ...
    
    def get_call_signatures(self): # -> tuple[Any | list[Any], bool]:
        ...
    


class Function(BaseFunction, Opaque):
    """
    Type class for builtin functions implemented by Numba.
    """
    ...


class BoundFunction(Callable, Opaque):
    """
    A function with an implicit first argument (denoted as *this* below).
    """
    def __init__(self, template, this) -> None:
        ...
    
    def unify(self, typingctx, other): # -> Self | None:
        ...
    
    def copy(self, this): # -> Self:
        ...
    
    @property
    def key(self): # -> tuple[Any, Any, Any | None]:
        ...
    
    def get_impl_key(self, sig): # -> Any:
        """
        Get the implementation key (used by the target context) for the
        given signature.
        """
        ...
    
    def get_call_type(self, context, args, kws): # -> Any | None:
        ...
    
    def get_call_signatures(self): # -> tuple[Any | list[Any], bool]:
        ...
    


class MakeFunctionLiteral(Literal, Opaque):
    ...


class _PickleableWeakRef(weakref.ref):
    """
    Allow a weakref to be pickled.

    Note that if the object referred to is not kept alive elsewhere in the
    pickle, the weakref will immediately expire after being constructed.
    """
    def __getnewargs__(self): # -> tuple[Any]:
        ...
    


class WeakType(Type):
    """
    Base class for types parametered by a mortal object, to which only
    a weak reference is kept.
    """
    @property
    def key(self): # -> _PickleableWeakRef:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    


class Dispatcher(WeakType, Callable, Dummy):
    """
    Type class for @jit-compiled functions.
    """
    def __init__(self, dispatcher) -> None:
        ...
    
    def dump(self, tab=...): # -> None:
        ...
    
    def get_call_type(self, context, args, kws): # -> None:
        """
        Resolve a call to this dispatcher using the given argument types.
        A signature returned and it is ensured that a compiled specialization
        is available for it.
        """
        ...
    
    def get_call_signatures(self): # -> tuple[Any, Literal[True]]:
        ...
    
    @property
    def dispatcher(self):
        """
        A strong reference to the underlying numba.dispatcher.Dispatcher
        instance.
        """
        ...
    
    def get_overload(self, sig):
        """
        Get the compiled overload for the given signature.
        """
        ...
    
    def get_impl_key(self, sig):
        """
        Get the implementation key for the given signature.
        """
        ...
    
    def unify(self, context, other): # -> UndefinedFunctionType | FunctionType | None:
        ...
    
    def can_convert_to(self, typingctx, other): # -> Literal[Conversion.safe] | None:
        ...
    


class ObjModeDispatcher(Dispatcher):
    """Dispatcher subclass that enters objectmode function.
    """
    ...


class ExternalFunctionPointer(BaseFunction):
    """
    A pointer to a native function (e.g. exported via ctypes or cffi).
    *get_pointer* is a Python function taking an object
    and returning the raw pointer value as an int.
    """
    def __init__(self, sig, get_pointer, cconv=...) -> None:
        ...
    
    @property
    def key(self): # -> tuple[Any, Any | None, Any]:
        ...
    


class ExternalFunction(Function):
    """
    A named native function (resolvable by LLVM) accepting an explicit
    signature. For internal use only.
    """
    def __init__(self, symbol, sig) -> None:
        ...
    
    @property
    def key(self): # -> tuple[Any, Any]:
        ...
    


class NamedTupleClass(Callable, Opaque):
    """
    Type class for namedtuple classes.
    """
    def __init__(self, instance_class) -> None:
        ...
    
    def get_call_type(self, context, args, kws): # -> None:
        ...
    
    def get_call_signatures(self): # -> tuple[tuple[()], Literal[True]]:
        ...
    
    def get_impl_key(self, sig): # -> type[Self]:
        ...
    
    @property
    def key(self): # -> Any:
        ...
    


class NumberClass(Callable, DTypeSpec, Opaque):
    """
    Type class for number classes (e.g. "np.float64").
    """
    def __init__(self, instance_type) -> None:
        ...
    
    def get_call_type(self, context, args, kws): # -> None:
        ...
    
    def get_call_signatures(self): # -> tuple[tuple[()], Literal[True]]:
        ...
    
    def get_impl_key(self, sig): # -> type[Self]:
        ...
    
    @property
    def key(self): # -> Any:
        ...
    
    @property
    def dtype(self): # -> Any:
        ...
    


_RecursiveCallOverloads = ...
class RecursiveCall(Opaque):
    """
    Recursive call to a Dispatcher.
    """
    _overloads = ...
    def __init__(self, dispatcher_type) -> None:
        ...
    
    def add_overloads(self, args, qualname, uid): # -> None:
        """Add an overload of the function.

        Parameters
        ----------
        args :
            argument types
        qualname :
            function qualifying name
        uid :
            unique id
        """
        ...
    
    def get_overloads(self, args):
        """Get the qualifying name and unique id for the overload given the
        argument types.
        """
        ...
    
    @property
    def key(self): # -> Dispatcher:
        ...
    


