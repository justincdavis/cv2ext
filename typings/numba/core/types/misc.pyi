"""
This type stub file was generated by pyright.
"""

from numba.core.types.abstract import Callable, Hashable, Literal, Type
from numba.core.types.common import Dummy, IterableType, Opaque, SimpleIteratorType

class PyObject(Dummy):
    """
    A generic CPython object.
    """
    def is_precise(self): # -> Literal[False]:
        ...
    


class Phantom(Dummy):
    """
    A type that cannot be materialized.  A Phantom cannot be used as
    argument or return type.
    """
    ...


class Undefined(Dummy):
    """
    A type that is left imprecise.  This is used as a temporaray placeholder
    during type inference in the hope that the type can be later refined.
    """
    def is_precise(self): # -> Literal[False]:
        ...
    


class UndefVar(Dummy):
    """
    A type that is created by Expr.undef to represent an undefined variable.
    This type can be promoted to any other type.
    This is introduced to handle Python 3.12 LOAD_FAST_AND_CLEAR.
    """
    def can_convert_to(self, typingctx, other): # -> Literal[Conversion.promote]:
        ...
    


class RawPointer(Opaque):
    """
    A raw pointer without any specific meaning.
    """
    ...


class StringLiteral(Literal, Dummy):
    def can_convert_to(self, typingctx, other): # -> Literal[Conversion.safe] | None:
        ...
    


def unliteral(lit_type): # -> Any:
    """
    Get base type from Literal type.
    """
    ...

def literal(value): # -> Literal:
    """Returns a Literal instance or raise LiteralTypingError
    """
    ...

def maybe_literal(value): # -> Literal | None:
    """Get a Literal type for the value or None.
    """
    ...

class Omitted(Opaque):
    """
    An omitted function argument with a default value.
    """
    def __init__(self, value) -> None:
        ...
    
    @property
    def key(self): # -> tuple[Any, Any | int]:
        ...
    
    @property
    def value(self): # -> Any:
        ...
    


class VarArg(Type):
    """
    Special type representing a variable number of arguments at the
    end of a function's signature.  Only used for signature matching,
    not for actual values.
    """
    def __init__(self, dtype) -> None:
        ...
    
    @property
    def key(self): # -> Any:
        ...
    


class Module(Dummy):
    def __init__(self, pymod) -> None:
        ...
    
    @property
    def key(self): # -> Any:
        ...
    


class MemInfoPointer(Type):
    """
    Pointer to a Numba "meminfo" (i.e. the information for a managed
    piece of memory).
    """
    mutable = ...
    def __init__(self, dtype) -> None:
        ...
    
    @property
    def key(self): # -> Any:
        ...
    


class CPointer(Type):
    """
    Type class for pointers to other types.

    Attributes
    ----------
        dtype : The pointee type
        addrspace : int
            The address space pointee belongs to.
    """
    mutable = ...
    def __init__(self, dtype, addrspace=...) -> None:
        ...
    
    @property
    def key(self): # -> tuple[Any, Any | None]:
        ...
    


class EphemeralPointer(CPointer):
    """
    Type class for pointers which aren't guaranteed to last long - e.g.
    stack-allocated slots.  The data model serializes such pointers
    by copying the data pointed to.
    """
    ...


class EphemeralArray(Type):
    """
    Similar to EphemeralPointer, but pointing to an array of elements,
    rather than a single one.  The array size must be known at compile-time.
    """
    def __init__(self, dtype, count) -> None:
        ...
    
    @property
    def key(self): # -> tuple[Any, Any]:
        ...
    


class Object(Type):
    mutable = ...
    def __init__(self, clsobj) -> None:
        ...
    
    @property
    def key(self): # -> Any:
        ...
    


class Optional(Type):
    """
    Type class for optional types, i.e. union { some type, None }
    """
    def __init__(self, typ) -> None:
        ...
    
    @property
    def key(self): # -> Any:
        ...
    
    def can_convert_to(self, typingctx, other): # -> Conversion | None:
        ...
    
    def can_convert_from(self, typingctx, other): # -> Conversion | None:
        ...
    
    def unify(self, typingctx, other): # -> Optional | None:
        ...
    


class NoneType(Opaque):
    """
    The type for None.
    """
    def unify(self, typingctx, other): # -> Optional | NoneType:
        """
        Turn anything to a Optional type;
        """
        ...
    


class EllipsisType(Opaque):
    """
    The type for the Ellipsis singleton.
    """
    ...


class ExceptionClass(Callable, Phantom):
    """
    The type of exception classes (not instances).
    """
    def __init__(self, exc_class) -> None:
        ...
    
    def get_call_type(self, context, args, kws): # -> Signature:
        ...
    
    def get_call_signatures(self): # -> tuple[list[Signature], Literal[False]]:
        ...
    
    def get_impl_key(self, sig): # -> type[Self]:
        ...
    
    @property
    def key(self): # -> type[BaseException]:
        ...
    


class ExceptionInstance(Phantom):
    """
    The type of exception instances.  *exc_class* should be the
    exception class.
    """
    def __init__(self, exc_class) -> None:
        ...
    
    @property
    def key(self): # -> type[BaseException]:
        ...
    


class SliceType(Type):
    def __init__(self, name, members) -> None:
        ...
    
    @property
    def key(self): # -> Any:
        ...
    


class SliceLiteral(Literal, SliceType):
    def __init__(self, value) -> None:
        ...
    
    @property
    def key(self): # -> tuple[Any, Any, Any]:
        ...
    


class ClassInstanceType(Type):
    """
    The type of a jitted class *instance*.  It will be the return-type
    of the constructor of the class.
    """
    mutable = ...
    name_prefix = ...
    def __init__(self, class_type) -> None:
        ...
    
    def get_data_type(self): # -> ClassDataType:
        ...
    
    def get_reference_type(self): # -> Self:
        ...
    
    @property
    def key(self):
        ...
    
    @property
    def classname(self):
        ...
    
    @property
    def jit_props(self):
        ...
    
    @property
    def jit_static_methods(self):
        ...
    
    @property
    def jit_methods(self):
        ...
    
    @property
    def struct(self):
        ...
    
    @property
    def methods(self):
        ...
    
    @property
    def static_methods(self):
        ...
    


class ClassType(Callable, Opaque):
    """
    The type of the jitted class (not instance).  When the type of a class
    is called, its constructor is invoked.
    """
    mutable = ...
    name_prefix = ...
    instance_type_class = ClassInstanceType
    def __init__(self, class_def, ctor_template_cls, struct, jit_methods, jit_props, jit_static_methods) -> None:
        ...
    
    def get_call_type(self, context, args, kws): # -> Any:
        ...
    
    def get_call_signatures(self): # -> tuple[tuple[()], Literal[True]]:
        ...
    
    def get_impl_key(self, sig): # -> type[Self]:
        ...
    
    @property
    def methods(self): # -> dict[Any, Any]:
        ...
    
    @property
    def static_methods(self): # -> dict[Any, Any]:
        ...
    
    @property
    def instance_type(self): # -> ClassInstanceType:
        ...
    
    @property
    def ctor_template(self): # -> Any:
        ...
    


class DeferredType(Type):
    """
    Represents a type that will be defined later.  It must be defined
    before it is materialized (used in the compiler).  Once defined, it
    behaves exactly as the type it is defining.
    """
    def __init__(self) -> None:
        ...
    
    def get(self): # -> Type:
        ...
    
    def define(self, typ): # -> None:
        ...
    
    def unify(self, typingctx, other):
        ...
    


class ClassDataType(Type):
    """
    Internal only.
    Represents the data of the instance.  The representation of
    ClassInstanceType contains a pointer to a ClassDataType which represents
    a C structure that contains all the data fields of the class instance.
    """
    def __init__(self, classtyp) -> None:
        ...
    


class ContextManager(Callable, Phantom):
    """
    An overly-simple ContextManager type that cannot be materialized.
    """
    def __init__(self, cm) -> None:
        ...
    
    def get_call_signatures(self): # -> tuple[tuple[()], Literal[False]]:
        ...
    
    def get_call_type(self, context, args, kws): # -> Signature:
        ...
    
    def get_impl_key(self, sig): # -> type[Self]:
        ...
    


class UnicodeType(IterableType, Hashable):
    def __init__(self, name) -> None:
        ...
    
    @property
    def iterator_type(self): # -> UnicodeIteratorType:
        ...
    


class UnicodeIteratorType(SimpleIteratorType):
    def __init__(self, dtype) -> None:
        ...
    


